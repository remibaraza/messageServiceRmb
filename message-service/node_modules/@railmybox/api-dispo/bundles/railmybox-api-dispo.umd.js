(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@railmybox/api-dispo', ['exports', '@angular/core', '@angular/common/http'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.railmybox = global.railmybox || {}, global.railmybox["api-dispo"] = {}), global.ng.core, global.ng.common.http));
})(this, (function (exports, i0, i1) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    /**
     * Custom HttpParameterCodec
     * Workaround for https://github.com/angular/angular/issues/18261
     */
    var CustomHttpParameterCodec = /** @class */ (function () {
        function CustomHttpParameterCodec() {
        }
        CustomHttpParameterCodec.prototype.encodeKey = function (k) {
            return encodeURIComponent(k);
        };
        CustomHttpParameterCodec.prototype.encodeValue = function (v) {
            return encodeURIComponent(v);
        };
        CustomHttpParameterCodec.prototype.decodeKey = function (k) {
            return decodeURIComponent(k);
        };
        CustomHttpParameterCodec.prototype.decodeValue = function (v) {
            return decodeURIComponent(v);
        };
        return CustomHttpParameterCodec;
    }());

    var BASE_PATH = new i0.InjectionToken('basePath');
    var COLLECTION_FORMATS = {
        'csv': ',',
        'tsv': '   ',
        'ssv': ' ',
        'pipes': '|'
    };

    var Configuration = /** @class */ (function () {
        function Configuration(configurationParameters) {
            var _this = this;
            if (configurationParameters === void 0) { configurationParameters = {}; }
            this.apiKeys = configurationParameters.apiKeys;
            this.username = configurationParameters.username;
            this.password = configurationParameters.password;
            this.accessToken = configurationParameters.accessToken;
            this.basePath = configurationParameters.basePath;
            this.withCredentials = configurationParameters.withCredentials;
            this.encoder = configurationParameters.encoder;
            if (configurationParameters.credentials) {
                this.credentials = configurationParameters.credentials;
            }
            else {
                this.credentials = {};
            }
            // init default api_key credential
            if (!this.credentials['api_key']) {
                this.credentials['api_key'] = function () {
                    if (_this.apiKeys === null || _this.apiKeys === undefined) {
                        return undefined;
                    }
                    else {
                        return _this.apiKeys['api_key'] || _this.apiKeys['x-api-key'];
                    }
                };
            }
            // init default main_auth credential
            if (!this.credentials['main_auth']) {
                this.credentials['main_auth'] = function () {
                    if (_this.apiKeys === null || _this.apiKeys === undefined) {
                        return undefined;
                    }
                    else {
                        return _this.apiKeys['main_auth'] || _this.apiKeys['Authorization'];
                    }
                };
            }
        }
        /**
         * Select the correct content-type to use for a request.
         * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param contentTypes - the array of content types that are available for selection
         * @returns the selected content-type or <code>undefined</code> if no selection could be made.
         */
        Configuration.prototype.selectHeaderContentType = function (contentTypes) {
            var _this = this;
            if (contentTypes.length === 0) {
                return undefined;
            }
            var type = contentTypes.find(function (x) { return _this.isJsonMime(x); });
            if (type === undefined) {
                return contentTypes[0];
            }
            return type;
        };
        /**
         * Select the correct accept content-type to use for a request.
         * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param accepts - the array of content types that are available for selection.
         * @returns the selected content-type or <code>undefined</code> if no selection could be made.
         */
        Configuration.prototype.selectHeaderAccept = function (accepts) {
            var _this = this;
            if (accepts.length === 0) {
                return undefined;
            }
            var type = accepts.find(function (x) { return _this.isJsonMime(x); });
            if (type === undefined) {
                return accepts[0];
            }
            return type;
        };
        /**
         * Check if the given MIME is a JSON MIME.
         * JSON MIME examples:
         *   application/json
         *   application/json; charset=UTF8
         *   APPLICATION/JSON
         *   application/vnd.company+json
         * @param mime - MIME (Multipurpose Internet Mail Extensions)
         * @return True if the given MIME is JSON, false otherwise.
         */
        Configuration.prototype.isJsonMime = function (mime) {
            var jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
            return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
        };
        Configuration.prototype.lookupCredential = function (key) {
            var value = this.credentials[key];
            return typeof value === 'function'
                ? value()
                : value;
        };
        return Configuration;
    }());

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var AC03Service = /** @class */ (function () {
        function AC03Service(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        AC03Service.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        AC03Service.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        AC03Service.prototype.processAc03Message = function (aC03MessageModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (aC03MessageModel === null || aC03MessageModel === undefined) {
                throw new Error('Required parameter aC03MessageModel was null or undefined when calling processAc03Message.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (api_key) required
            credential = this.configuration.lookupCredential('api_key');
            if (credential) {
                headers = headers.set('x-api-key', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/external/ac03", aC03MessageModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return AC03Service;
    }());
    AC03Service.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function AC03Service_Factory() { return new AC03Service(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: AC03Service, providedIn: "root" });
    AC03Service.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    AC03Service.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var BOSISService = /** @class */ (function () {
        function BOSISService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        BOSISService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        BOSISService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        BOSISService.prototype.processBosisMessage = function (bosisMessageModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (bosisMessageModel === null || bosisMessageModel === undefined) {
                throw new Error('Required parameter bosisMessageModel was null or undefined when calling processBosisMessage.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (api_key) required
            credential = this.configuration.lookupCredential('api_key');
            if (credential) {
                headers = headers.set('x-api-key', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/external/bosis", bosisMessageModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return BOSISService;
    }());
    BOSISService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function BOSISService_Factory() { return new BOSISService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: BOSISService, providedIn: "root" });
    BOSISService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    BOSISService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var CachesService = /** @class */ (function () {
        function CachesService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        CachesService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        CachesService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        CachesService.prototype.invalidateCaches = function (observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/caches/invalidate", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return CachesService;
    }());
    CachesService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function CachesService_Factory() { return new CachesService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: CachesService, providedIn: "root" });
    CachesService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    CachesService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ChangesService = /** @class */ (function () {
        function ChangesService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        ChangesService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        ChangesService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        ChangesService.prototype.getChanges = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/changes", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return ChangesService;
    }());
    ChangesService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ChangesService_Factory() { return new ChangesService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: ChangesService, providedIn: "root" });
    ChangesService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    ChangesService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var DispoService = /** @class */ (function () {
        function DispoService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        DispoService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        DispoService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        DispoService.prototype.getChanges = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/changes", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.getDispoOrder = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrder.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.getDispoOrderForBooking = function (bookingref, dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (bookingref === null || bookingref === undefined) {
                throw new Error('Required parameter bookingref was null or undefined when calling getDispoOrderForBooking.');
            }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderForBooking.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/dispo-orders/" + encodeURIComponent(String(bookingref)) + "/" + encodeURIComponent(String(dispoOrderId)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.getDispoOrderMessages = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderMessages.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/messages", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.getProblems = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/problems", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.getScenarios = function (observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/troubleshooting/scenarios", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.listDispoOrdersForBooking = function (bookingref, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (bookingref === null || bookingref === undefined) {
                throw new Error('Required parameter bookingref was null or undefined when calling listDispoOrdersForBooking.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/dispo-orders/" + encodeURIComponent(String(bookingref)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.searchDispoOrders = function (dispoOrderSearch, limit, offset, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var queryParameters = new i1.HttpParams({ encoder: this.encoder });
            if (dispoOrderSearch !== undefined && dispoOrderSearch !== null) {
                queryParameters = this.addToHttpParams(queryParameters, dispoOrderSearch, 'dispoOrderSearch');
            }
            if (limit !== undefined && limit !== null) {
                queryParameters = this.addToHttpParams(queryParameters, limit, 'limit');
            }
            if (offset !== undefined && offset !== null) {
                queryParameters = this.addToHttpParams(queryParameters, offset, 'offset');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders", {
                params: queryParameters,
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DispoService.prototype.updateDispoOrder = function (dispoOrderId, dispoOrderUpdateModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');
            }
            if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {
                throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.patch(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)), dispoOrderUpdateModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return DispoService;
    }());
    DispoService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function DispoService_Factory() { return new DispoService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: DispoService, providedIn: "root" });
    DispoService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    DispoService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ExternalService = /** @class */ (function () {
        function ExternalService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        ExternalService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        ExternalService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        ExternalService.prototype.processAc03Message = function (aC03MessageModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (aC03MessageModel === null || aC03MessageModel === undefined) {
                throw new Error('Required parameter aC03MessageModel was null or undefined when calling processAc03Message.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (api_key) required
            credential = this.configuration.lookupCredential('api_key');
            if (credential) {
                headers = headers.set('x-api-key', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/external/ac03", aC03MessageModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        ExternalService.prototype.processBosisMessage = function (bosisMessageModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (bosisMessageModel === null || bosisMessageModel === undefined) {
                throw new Error('Required parameter bosisMessageModel was null or undefined when calling processBosisMessage.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (api_key) required
            credential = this.configuration.lookupCredential('api_key');
            if (credential) {
                headers = headers.set('x-api-key', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/external/bosis", bosisMessageModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return ExternalService;
    }());
    ExternalService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ExternalService_Factory() { return new ExternalService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: ExternalService, providedIn: "root" });
    ExternalService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    ExternalService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var HelpdeskService = /** @class */ (function () {
        function HelpdeskService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        HelpdeskService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        HelpdeskService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        HelpdeskService.prototype.getChanges = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/changes", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        HelpdeskService.prototype.getDispoOrder = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrder.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        HelpdeskService.prototype.getDispoOrderMessages = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderMessages.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/messages", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        HelpdeskService.prototype.getProblems = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/problems", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        HelpdeskService.prototype.searchDispoOrders = function (dispoOrderSearch, limit, offset, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var queryParameters = new i1.HttpParams({ encoder: this.encoder });
            if (dispoOrderSearch !== undefined && dispoOrderSearch !== null) {
                queryParameters = this.addToHttpParams(queryParameters, dispoOrderSearch, 'dispoOrderSearch');
            }
            if (limit !== undefined && limit !== null) {
                queryParameters = this.addToHttpParams(queryParameters, limit, 'limit');
            }
            if (offset !== undefined && offset !== null) {
                queryParameters = this.addToHttpParams(queryParameters, offset, 'offset');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders", {
                params: queryParameters,
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        HelpdeskService.prototype.updateDispoOrder = function (dispoOrderId, dispoOrderUpdateModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');
            }
            if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {
                throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.patch(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)), dispoOrderUpdateModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return HelpdeskService;
    }());
    HelpdeskService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function HelpdeskService_Factory() { return new HelpdeskService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: HelpdeskService, providedIn: "root" });
    HelpdeskService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    HelpdeskService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var OrdersService = /** @class */ (function () {
        function OrdersService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        OrdersService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        OrdersService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        OrdersService.prototype.getDispoOrderForBooking = function (bookingref, dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (bookingref === null || bookingref === undefined) {
                throw new Error('Required parameter bookingref was null or undefined when calling getDispoOrderForBooking.');
            }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderForBooking.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/dispo-orders/" + encodeURIComponent(String(bookingref)) + "/" + encodeURIComponent(String(dispoOrderId)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        OrdersService.prototype.getScenarios = function (observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/troubleshooting/scenarios", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        OrdersService.prototype.listDispoOrdersForBooking = function (bookingref, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (bookingref === null || bookingref === undefined) {
                throw new Error('Required parameter bookingref was null or undefined when calling listDispoOrdersForBooking.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/dispo-orders/" + encodeURIComponent(String(bookingref)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        OrdersService.prototype.updateDispoOrder = function (dispoOrderId, dispoOrderUpdateModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');
            }
            if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {
                throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.patch(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)), dispoOrderUpdateModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return OrdersService;
    }());
    OrdersService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function OrdersService_Factory() { return new OrdersService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: OrdersService, providedIn: "root" });
    OrdersService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    OrdersService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ProblemService = /** @class */ (function () {
        function ProblemService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        ProblemService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        ProblemService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        ProblemService.prototype.getProblems = function (dispoOrderId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (dispoOrderId === null || dispoOrderId === undefined) {
                throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/dispo-orders/" + encodeURIComponent(String(dispoOrderId)) + "/problems", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return ProblemService;
    }());
    ProblemService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ProblemService_Factory() { return new ProblemService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: ProblemService, providedIn: "root" });
    ProblemService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    ProblemService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var TrainVisitService = /** @class */ (function () {
        function TrainVisitService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        TrainVisitService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        TrainVisitService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        TrainVisitService.prototype.getTrainVisit = function (trainVisitId, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (trainVisitId === null || trainVisitId === undefined) {
                throw new Error('Required parameter trainVisitId was null or undefined when calling getTrainVisit.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/train-visits/" + encodeURIComponent(String(trainVisitId)), {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        TrainVisitService.prototype.searchTrainVisits = function (trainStatus, trainIdOperator, shippingDateStart, shippingDateEnd, limit, offset, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var queryParameters = new i1.HttpParams({ encoder: this.encoder });
            if (trainStatus !== undefined && trainStatus !== null) {
                queryParameters = this.addToHttpParams(queryParameters, trainStatus, 'trainStatus');
            }
            if (trainIdOperator !== undefined && trainIdOperator !== null) {
                queryParameters = this.addToHttpParams(queryParameters, trainIdOperator, 'trainIdOperator');
            }
            if (shippingDateStart !== undefined && shippingDateStart !== null) {
                queryParameters = this.addToHttpParams(queryParameters, shippingDateStart, 'shippingDateStart');
            }
            if (shippingDateEnd !== undefined && shippingDateEnd !== null) {
                queryParameters = this.addToHttpParams(queryParameters, shippingDateEnd, 'shippingDateEnd');
            }
            if (limit !== undefined && limit !== null) {
                queryParameters = this.addToHttpParams(queryParameters, limit, 'limit');
            }
            if (offset !== undefined && offset !== null) {
                queryParameters = this.addToHttpParams(queryParameters, offset, 'offset');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/train-visits", {
                params: queryParameters,
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        TrainVisitService.prototype.updateTrainVisit = function (trainVisitId, trainVisitModel, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (trainVisitId === null || trainVisitId === undefined) {
                throw new Error('Required parameter trainVisitId was null or undefined when calling updateTrainVisit.');
            }
            if (trainVisitModel === null || trainVisitModel === undefined) {
                throw new Error('Required parameter trainVisitModel was null or undefined when calling updateTrainVisit.');
            }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            var consumes = [
                'application/json'
            ];
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/admin/train-visits/" + encodeURIComponent(String(trainVisitId)), trainVisitModel, {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return TrainVisitService;
    }());
    TrainVisitService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function TrainVisitService_Factory() { return new TrainVisitService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: TrainVisitService, providedIn: "root" });
    TrainVisitService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    TrainVisitService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var TroubleshootingService = /** @class */ (function () {
        function TroubleshootingService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://api.dev.railmybox.io/dispo';
            this.defaultHeaders = new i1.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        TroubleshootingService.prototype.addToHttpParams = function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        TroubleshootingService.prototype.addToHttpParamsRecursive = function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        TroubleshootingService.prototype.getScenarios = function (observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            var headers = this.defaultHeaders;
            var credential;
            // authentication (main_auth) required
            credential = this.configuration.lookupCredential('main_auth');
            if (credential) {
                headers = headers.set('Authorization', credential);
            }
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                var httpHeaderAccepts = [
                    'application/json',
                    'application/problem+json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            var responseType_ = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/admin/troubleshooting/scenarios", {
                responseType: responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        return TroubleshootingService;
    }());
    TroubleshootingService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function TroubleshootingService_Factory() { return new TroubleshootingService(i0__namespace.ɵɵinject(i1__namespace.HttpClient), i0__namespace.ɵɵinject(BASE_PATH, 8), i0__namespace.ɵɵinject(Configuration, 8)); }, token: TroubleshootingService, providedIn: "root" });
    TroubleshootingService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    TroubleshootingService.ctorParameters = function () { return [
        { type: i1.HttpClient },
        { type: String, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: i0.Optional }] }
    ]; };

    var APIS = [AC03Service, BOSISService, CachesService, ChangesService, DispoService, ExternalService, HelpdeskService, OrdersService, ProblemService, TrainVisitService, TroubleshootingService];

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    exports.AC03MessageModel = void 0;
    (function (AC03MessageModel) {
        AC03MessageModel.ReferenceTypeEnum = {
            Response: 'Response',
            Error: 'Error',
            StatusInformation: 'StatusInformation',
            ErrorMessage: 'ErrorMessage',
            Deletion: 'Deletion'
        };
    })(exports.AC03MessageModel || (exports.AC03MessageModel = {}));

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var AddressTypeModel = {
        Location: 'LOCATION',
        Loadpoint: 'LOADPOINT',
        Station: 'STATION',
        Depot: 'DEPOT',
        Customs: 'CUSTOMS',
        Vet: 'VET',
        Weighing: 'WEIGHING',
        Cpa: 'CPA',
        Port: 'PORT'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var BookingStatusTypeModel = {
        InCapture: 'IN_CAPTURE',
        Verification: 'VERIFICATION',
        Accepted: 'ACCEPTED',
        MissingData: 'MISSING_DATA',
        MissingDataUrgent: 'MISSING_DATA_URGENT',
        Denied: 'DENIED',
        Rebooking: 'REBOOKING',
        Cancelled: 'CANCELLED',
        Dispatched: 'DISPATCHED',
        BookingClosed: 'BOOKING_CLOSED',
        InProgress: 'IN_PROGRESS',
        TransportProblem: 'TRANSPORT_PROBLEM',
        Done: 'DONE',
        Invoiced: 'INVOICED',
        UnderReview: 'UNDER_REVIEW',
        RequestCancellation: 'REQUEST_CANCELLATION',
        Arrived: 'ARRIVED'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ChangeTypeModel = {
        Add: 'ADD',
        Change: 'CHANGE',
        Delete: 'DELETE'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ContainerStatusTypeModel = {
        Done: 'DONE',
        Accepted: 'ACCEPTED'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var CustomsTypeModel = {
        Empty: 'EMPTY',
        Community: 'COMMUNITY',
        Dgcons: 'DGCONS'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    exports.DispoOrderStatusModel = void 0;
    (function (DispoOrderStatusModel) {
        DispoOrderStatusModel.StatusTypeEnum = {
            SendOrder: 'SendOrder',
            StatusInformation: 'StatusInformation',
            ErrorMessage: 'ErrorMessage'
        };
    })(exports.DispoOrderStatusModel || (exports.DispoOrderStatusModel = {}));

    exports.DispoOrderStatusSendOrderAllOfModel = void 0;
    (function (DispoOrderStatusSendOrderAllOfModel) {
        DispoOrderStatusSendOrderAllOfModel.MessageStatusEnum = {
            New: 'NEW',
            Send: 'SEND',
            Done: 'DONE',
            Error: 'ERROR'
        };
    })(exports.DispoOrderStatusSendOrderAllOfModel || (exports.DispoOrderStatusSendOrderAllOfModel = {}));

    exports.DispoOrderStatusSendOrderModel = void 0;
    (function (DispoOrderStatusSendOrderModel) {
        DispoOrderStatusSendOrderModel.MessageStatusEnum = {
            New: 'NEW',
            Send: 'SEND',
            Done: 'DONE',
            Error: 'ERROR'
        };
    })(exports.DispoOrderStatusSendOrderModel || (exports.DispoOrderStatusSendOrderModel = {}));

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var DispoOrderStatusTypeModel = {
        Verification: 'VERIFICATION',
        Accepted: 'ACCEPTED',
        MissingData: 'MISSING_DATA',
        Denied: 'DENIED',
        Cancelled: 'CANCELLED',
        Dispatched: 'DISPATCHED',
        BookingClosed: 'BOOKING_CLOSED',
        InProgress: 'IN_PROGRESS',
        TransportProblem: 'TRANSPORT_PROBLEM',
        Rebooking: 'REBOOKING',
        Done: 'DONE',
        RequestCancellation: 'REQUEST_CANCELLATION',
        RebookingCancelled: 'REBOOKING_CANCELLED',
        Arrived: 'ARRIVED'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ProblemCategoryTypeModel = {
        LoadingPoint: 'LOADING_POINT',
        Damages: 'DAMAGES',
        Traffic: 'TRAFFIC'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var ProblemStatusTypeModel = {
        Open: 'OPEN',
        Reopened: 'REOPENED',
        Pending: 'PENDING',
        Done: 'DONE',
        Cancelled: 'CANCELLED'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var SendMessageTypeModel = {
        TransportOrder: 'TRANSPORT_ORDER',
        Cancel: 'CANCEL'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var TrainStatusTypeModel = {
        Active: 'ACTIVE',
        InProgress: 'IN_PROGRESS',
        Done: 'DONE',
        Cancelled: 'CANCELLED',
        Delayed: 'DELAYED'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    var TransportSectionModel = {
        Vesselrun: 'VESSELRUN',
        Prerun: 'PRERUN',
        Mainrun: 'MAINRUN',
        Postrun: 'POSTRUN'
    };

    /**
     * Disposition
     * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
     *
     * The version of the OpenAPI document: 1.0.52
     * Contact: developer@railmybox.io
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */

    var ApiModule = /** @class */ (function () {
        function ApiModule(parentModule, http) {
            if (parentModule) {
                throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
            }
            if (!http) {
                throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                    'See also https://github.com/angular/angular/issues/20575');
            }
        }
        ApiModule.forRoot = function (configurationFactory) {
            return {
                ngModule: ApiModule,
                providers: [{ provide: Configuration, useFactory: configurationFactory }]
            };
        };
        return ApiModule;
    }());
    ApiModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: [],
                    providers: []
                },] }
    ];
    ApiModule.ctorParameters = function () { return [
        { type: ApiModule, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
        { type: i1.HttpClient, decorators: [{ type: i0.Optional }] }
    ]; };

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AC03Service = AC03Service;
    exports.APIS = APIS;
    exports.AddressTypeModel = AddressTypeModel;
    exports.ApiModule = ApiModule;
    exports.BASE_PATH = BASE_PATH;
    exports.BOSISService = BOSISService;
    exports.BookingStatusTypeModel = BookingStatusTypeModel;
    exports.COLLECTION_FORMATS = COLLECTION_FORMATS;
    exports.CachesService = CachesService;
    exports.ChangeTypeModel = ChangeTypeModel;
    exports.ChangesService = ChangesService;
    exports.Configuration = Configuration;
    exports.ContainerStatusTypeModel = ContainerStatusTypeModel;
    exports.CustomsTypeModel = CustomsTypeModel;
    exports.DispoOrderStatusTypeModel = DispoOrderStatusTypeModel;
    exports.DispoService = DispoService;
    exports.ExternalService = ExternalService;
    exports.HelpdeskService = HelpdeskService;
    exports.OrdersService = OrdersService;
    exports.ProblemCategoryTypeModel = ProblemCategoryTypeModel;
    exports.ProblemService = ProblemService;
    exports.ProblemStatusTypeModel = ProblemStatusTypeModel;
    exports.SendMessageTypeModel = SendMessageTypeModel;
    exports.TrainStatusTypeModel = TrainStatusTypeModel;
    exports.TrainVisitService = TrainVisitService;
    exports.TransportSectionModel = TransportSectionModel;
    exports.TroubleshootingService = TroubleshootingService;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=railmybox-api-dispo.umd.js.map
