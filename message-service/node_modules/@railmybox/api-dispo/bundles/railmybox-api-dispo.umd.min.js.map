{"version":3,"names":["CustomHttpParameterCodec","prototype","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeURIComponent","decodeValue","BASE_PATH","InjectionToken","Configuration","configurationParameters","_this","this","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","credentials","undefined","selectHeaderContentType","contentTypes","length","type","find","x","isJsonMime","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","lookupCredential","key","value","AC03Service","httpClient","configuration","defaultHeaders","HttpHeaders","addToHttpParams","httpParams","Date","addToHttpParamsRecursive","Array","isArray","forEach","elem","Error","append","toISOString","substr","Object","keys","processAc03Message","aC03MessageModel","observe","reportProgress","options","credential","headers","set","httpHeaderAcceptSelected","httpHeaderAccept","httpContentTypeSelected","responseType_","startsWith","post","responseType","Injectable","args","providedIn","HttpClient","Optional","Inject","decorators","BOSISService","processBosisMessage","bosisMessageModel","CachesService","invalidateCaches","get","ChangesService","getChanges","dispoOrderId","String","DispoService","getDispoOrder","getDispoOrderForBooking","bookingref","getDispoOrderMessages","getProblems","getScenarios","listDispoOrdersForBooking","searchDispoOrders","dispoOrderSearch","limit","offset","queryParameters","HttpParams","params","updateDispoOrder","dispoOrderUpdateModel","patch","ExternalService","HelpdeskService","OrdersService","ProblemService","TrainVisitService","getTrainVisit","trainVisitId","searchTrainVisits","trainStatus","trainIdOperator","shippingDateStart","shippingDateEnd","updateTrainVisit","trainVisitModel","put","TroubleshootingService","APIS","AC03MessageModel","ReferenceTypeEnum","Response","StatusInformation","ErrorMessage","Deletion","DispoOrderStatusModel","StatusTypeEnum","SendOrder","DispoOrderStatusSendOrderAllOfModel","MessageStatusEnum","New","Send","Done","DispoOrderStatusSendOrderModel","ApiModule","parentModule","http","forRoot","configurationFactory","ngModule","providers","provide","useFactory","NgModule","imports","declarations","exports","SkipSelf","Location","Loadpoint","Station","Depot","Customs","Vet","Weighing","Cpa","Port","InCapture","Verification","Accepted","MissingData","MissingDataUrgent","Denied","Rebooking","Cancelled","Dispatched","BookingClosed","InProgress","TransportProblem","Invoiced","UnderReview","RequestCancellation","Arrived","csv","tsv","ssv","pipes","Add","Change","Delete","Empty","Community","Dgcons","RebookingCancelled","LoadingPoint","Damages","Traffic","Open","Reopened","Pending","TransportOrder","Cancel","Active","Delayed","Vesselrun","Prerun","Mainrun","Postrun"],"sources":["../../encoder.ts","../../variables.ts","../../configuration.ts","../../api/ac03.service.ts","../../api/bosis.service.ts","../../api/caches.service.ts","../../api/changes.service.ts","../../api/dispo.service.ts","../../api/external.service.ts","../../api/helpdesk.service.ts","../../api/orders.service.ts","../../api/problem.service.ts","../../api/train-visit.service.ts","../../api/troubleshooting.service.ts","../../api/api.ts","../../model/ac03-message.model.ts","../../model/dispo-order-status.model.ts","../../model/dispo-order-status-send-order-all-of.model.ts","../../model/dispo-order-status-send-order.model.ts","../../model/dispo-order-status-type.model.ts","../../api.module.ts","../../model/address-type.model.ts","../../model/booking-status-type.model.ts","../../model/change-type.model.ts","../../model/container-status-type.model.ts","../../model/customs-type.model.ts","../../model/problem-category-type.model.ts","../../model/problem-status-type.model.ts","../../model/send-message-type.model.ts","../../model/train-status-type.model.ts","../../model/transport-section.model.ts"],"sourcesContent":["import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials?: {[ key: string ]: string | (() => string | undefined)};\n}\n\nexport class Configuration {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials: {[ key: string ]: string | (() => string | undefined)};\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n        if (configurationParameters.credentials) {\n            this.credentials = configurationParameters.credentials;\n        }\n        else {\n            this.credentials = {};\n        }\n\n        // init default api_key credential\n        if (!this.credentials['api_key']) {\n            this.credentials['api_key'] = () => {\n                if (this.apiKeys === null || this.apiKeys === undefined) {\n                    return undefined;\n                } else {\n                    return this.apiKeys['api_key'] || this.apiKeys['x-api-key'];\n                }\n            };\n        }\n\n        // init default main_auth credential\n        if (!this.credentials['main_auth']) {\n            this.credentials['main_auth'] = () => {\n                if (this.apiKeys === null || this.apiKeys === undefined) {\n                    return undefined;\n                } else {\n                    return this.apiKeys['main_auth'] || this.apiKeys['Authorization'];\n                }\n            };\n        }\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n\n    public lookupCredential(key: string): string | undefined {\n        const value = this.credentials[key];\n        return typeof value === 'function'\n            ? value()\n            : value;\n    }\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { AC03MessageModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AC03Service {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Process an AC03 status message\n     * Post status messages and responses from AC03 operators. This can be either a Response, StatusInformation, ErrorMessage or Deletion. Based on the type, different fields need to be passed in the request. \n     * @param aC03MessageModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any>;\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpResponse<any>>;\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpEvent<any>>;\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any> {\n        if (aC03MessageModel === null || aC03MessageModel === undefined) {\n            throw new Error('Required parameter aC03MessageModel was null or undefined when calling processAc03Message.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (api_key) required\n        credential = this.configuration.lookupCredential('api_key');\n        if (credential) {\n            headers = headers.set('x-api-key', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/external/ac03`,\n            aC03MessageModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { BosisMessageModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class BOSISService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Process an BOSIS status message\n     * Post status messages and responses from BOSIS. \n     * @param bosisMessageModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any>;\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpResponse<any>>;\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpEvent<any>>;\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any> {\n        if (bosisMessageModel === null || bosisMessageModel === undefined) {\n            throw new Error('Required parameter bosisMessageModel was null or undefined when calling processBosisMessage.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (api_key) required\n        credential = this.configuration.lookupCredential('api_key');\n        if (credential) {\n            headers = headers.set('x-api-key', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/external/bosis`,\n            bosisMessageModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CachesService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Invalidate caches\n     * Invalidate all caches in the server \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public invalidateCaches(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any>;\n    public invalidateCaches(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpResponse<any>>;\n    public invalidateCaches(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpEvent<any>>;\n    public invalidateCaches(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/admin/caches/invalidate`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ChangeEntryModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ChangesService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get changes for a dispo order\n     * Get information about all database operations on a given object \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getChanges(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<ChangeEntryModel>>;\n    public getChanges(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<ChangeEntryModel>>>;\n    public getChanges(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<ChangeEntryModel>>>;\n    public getChanges(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<ChangeEntryModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/changes`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ChangeEntryModel } from '../model/models';\nimport { DispoOrderInfoModel } from '../model/models';\nimport { DispoOrderStatusModel } from '../model/models';\nimport { DispoOrderUpdateModel } from '../model/models';\nimport { DispoProblemModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\nimport { TroubleScenarioModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DispoService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get changes for a dispo order\n     * Get information about all database operations on a given object \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getChanges(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<ChangeEntryModel>>;\n    public getChanges(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<ChangeEntryModel>>>;\n    public getChanges(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<ChangeEntryModel>>>;\n    public getChanges(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<ChangeEntryModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/changes`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a single dispo order\n     * Get detailed information about a single dispo order for the helpdesk \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDispoOrder(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public getDispoOrder(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public getDispoOrder(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public getDispoOrder(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrder.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<DispoOrderInfoModel>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a single dispo order\n     * Get detailed information about a single dispo order for the helpdesk \n     * @param bookingref \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (bookingref === null || bookingref === undefined) {\n            throw new Error('Required parameter bookingref was null or undefined when calling getDispoOrderForBooking.');\n        }\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderForBooking.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<DispoOrderInfoModel>(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}/${encodeURIComponent(String(dispoOrderId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get communication messages for a dispo order\n     * Get a communication overview for the dispo order. This contains all messages that have been send out to the service providers as well as all status or error responses. \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDispoOrderMessages(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoOrderStatusModel>>;\n    public getDispoOrderMessages(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoOrderStatusModel>>>;\n    public getDispoOrderMessages(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoOrderStatusModel>>>;\n    public getDispoOrderMessages(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderMessages.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoOrderStatusModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/messages`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get problems for a dispo order\n     * Get information about all problems related to a dispo order \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getProblems(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoProblemModel>>;\n    public getProblems(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoProblemModel>>>;\n    public getProblems(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoProblemModel>>>;\n    public getProblems(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoProblemModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/problems`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of all scenarios\n     * Get detailed information about all scenarios \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getScenarios(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<TroubleScenarioModel>>;\n    public getScenarios(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<TroubleScenarioModel>>>;\n    public getScenarios(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<TroubleScenarioModel>>>;\n    public getScenarios(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<TroubleScenarioModel>>(`${this.configuration.basePath}/admin/troubleshooting/scenarios`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List dispo orders\n     * Search and filter throught the booking for the customer \n     * @param bookingref \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDispoOrdersForBooking(bookingref: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoOrderInfoModel>>;\n    public listDispoOrdersForBooking(bookingref: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoOrderInfoModel>>>;\n    public listDispoOrdersForBooking(bookingref: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoOrderInfoModel>>>;\n    public listDispoOrdersForBooking(bookingref: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (bookingref === null || bookingref === undefined) {\n            throw new Error('Required parameter bookingref was null or undefined when calling listDispoOrdersForBooking.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoOrderInfoModel>>(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List dispo orders\n     * Search and filter throught the booking for the helpdesk \n     * @param dispoOrderSearch \n     * @param limit Client suggested limit to restrict the number of entries per page\n     * @param offset Numeric offset of the first element on the page\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoOrderInfoModel>>;\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoOrderInfoModel>>>;\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoOrderInfoModel>>>;\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (dispoOrderSearch !== undefined && dispoOrderSearch !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>dispoOrderSearch, 'dispoOrderSearch');\n        }\n        if (limit !== undefined && limit !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>limit, 'limit');\n        }\n        if (offset !== undefined && offset !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>offset, 'offset');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoOrderInfoModel>>(`${this.configuration.basePath}/admin/dispo-orders`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * update a dispo order\n     * update information about a single dispo order for the helpdesk \n     * @param dispoOrderId \n     * @param dispoOrderUpdateModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');\n        }\n        if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {\n            throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.patch<DispoOrderInfoModel>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`,\n            dispoOrderUpdateModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { AC03MessageModel } from '../model/models';\nimport { BosisMessageModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ExternalService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Process an AC03 status message\n     * Post status messages and responses from AC03 operators. This can be either a Response, StatusInformation, ErrorMessage or Deletion. Based on the type, different fields need to be passed in the request. \n     * @param aC03MessageModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any>;\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpResponse<any>>;\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpEvent<any>>;\n    public processAc03Message(aC03MessageModel: AC03MessageModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any> {\n        if (aC03MessageModel === null || aC03MessageModel === undefined) {\n            throw new Error('Required parameter aC03MessageModel was null or undefined when calling processAc03Message.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (api_key) required\n        credential = this.configuration.lookupCredential('api_key');\n        if (credential) {\n            headers = headers.set('x-api-key', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/external/ac03`,\n            aC03MessageModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Process an BOSIS status message\n     * Post status messages and responses from BOSIS. \n     * @param bosisMessageModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any>;\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpResponse<any>>;\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<HttpEvent<any>>;\n    public processBosisMessage(bosisMessageModel: BosisMessageModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/problem+json'}): Observable<any> {\n        if (bosisMessageModel === null || bosisMessageModel === undefined) {\n            throw new Error('Required parameter bosisMessageModel was null or undefined when calling processBosisMessage.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (api_key) required\n        credential = this.configuration.lookupCredential('api_key');\n        if (credential) {\n            headers = headers.set('x-api-key', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/external/bosis`,\n            bosisMessageModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ChangeEntryModel } from '../model/models';\nimport { DispoOrderInfoModel } from '../model/models';\nimport { DispoOrderStatusModel } from '../model/models';\nimport { DispoOrderUpdateModel } from '../model/models';\nimport { DispoProblemModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class HelpdeskService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get changes for a dispo order\n     * Get information about all database operations on a given object \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getChanges(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<ChangeEntryModel>>;\n    public getChanges(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<ChangeEntryModel>>>;\n    public getChanges(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<ChangeEntryModel>>>;\n    public getChanges(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<ChangeEntryModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/changes`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a single dispo order\n     * Get detailed information about a single dispo order for the helpdesk \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDispoOrder(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public getDispoOrder(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public getDispoOrder(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public getDispoOrder(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrder.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<DispoOrderInfoModel>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get communication messages for a dispo order\n     * Get a communication overview for the dispo order. This contains all messages that have been send out to the service providers as well as all status or error responses. \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDispoOrderMessages(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoOrderStatusModel>>;\n    public getDispoOrderMessages(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoOrderStatusModel>>>;\n    public getDispoOrderMessages(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoOrderStatusModel>>>;\n    public getDispoOrderMessages(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderMessages.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoOrderStatusModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/messages`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get problems for a dispo order\n     * Get information about all problems related to a dispo order \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getProblems(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoProblemModel>>;\n    public getProblems(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoProblemModel>>>;\n    public getProblems(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoProblemModel>>>;\n    public getProblems(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoProblemModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/problems`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List dispo orders\n     * Search and filter throught the booking for the helpdesk \n     * @param dispoOrderSearch \n     * @param limit Client suggested limit to restrict the number of entries per page\n     * @param offset Numeric offset of the first element on the page\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoOrderInfoModel>>;\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoOrderInfoModel>>>;\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoOrderInfoModel>>>;\n    public searchDispoOrders(dispoOrderSearch?: object, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (dispoOrderSearch !== undefined && dispoOrderSearch !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>dispoOrderSearch, 'dispoOrderSearch');\n        }\n        if (limit !== undefined && limit !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>limit, 'limit');\n        }\n        if (offset !== undefined && offset !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>offset, 'offset');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoOrderInfoModel>>(`${this.configuration.basePath}/admin/dispo-orders`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * update a dispo order\n     * update information about a single dispo order for the helpdesk \n     * @param dispoOrderId \n     * @param dispoOrderUpdateModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');\n        }\n        if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {\n            throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.patch<DispoOrderInfoModel>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`,\n            dispoOrderUpdateModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DispoOrderInfoModel } from '../model/models';\nimport { DispoOrderUpdateModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\nimport { TroubleScenarioModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class OrdersService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get a single dispo order\n     * Get detailed information about a single dispo order for the helpdesk \n     * @param bookingref \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public getDispoOrderForBooking(bookingref: string, dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (bookingref === null || bookingref === undefined) {\n            throw new Error('Required parameter bookingref was null or undefined when calling getDispoOrderForBooking.');\n        }\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderForBooking.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<DispoOrderInfoModel>(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}/${encodeURIComponent(String(dispoOrderId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of all scenarios\n     * Get detailed information about all scenarios \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getScenarios(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<TroubleScenarioModel>>;\n    public getScenarios(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<TroubleScenarioModel>>>;\n    public getScenarios(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<TroubleScenarioModel>>>;\n    public getScenarios(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<TroubleScenarioModel>>(`${this.configuration.basePath}/admin/troubleshooting/scenarios`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List dispo orders\n     * Search and filter throught the booking for the customer \n     * @param bookingref \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDispoOrdersForBooking(bookingref: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoOrderInfoModel>>;\n    public listDispoOrdersForBooking(bookingref: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoOrderInfoModel>>>;\n    public listDispoOrdersForBooking(bookingref: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoOrderInfoModel>>>;\n    public listDispoOrdersForBooking(bookingref: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (bookingref === null || bookingref === undefined) {\n            throw new Error('Required parameter bookingref was null or undefined when calling listDispoOrdersForBooking.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoOrderInfoModel>>(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * update a dispo order\n     * update information about a single dispo order for the helpdesk \n     * @param dispoOrderId \n     * @param dispoOrderUpdateModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<DispoOrderInfoModel>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<DispoOrderInfoModel>>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<DispoOrderInfoModel>>;\n    public updateDispoOrder(dispoOrderId: string, dispoOrderUpdateModel: DispoOrderUpdateModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');\n        }\n        if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {\n            throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.patch<DispoOrderInfoModel>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`,\n            dispoOrderUpdateModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DispoProblemModel } from '../model/models';\nimport { ProblemModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProblemService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get problems for a dispo order\n     * Get information about all problems related to a dispo order \n     * @param dispoOrderId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getProblems(dispoOrderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<DispoProblemModel>>;\n    public getProblems(dispoOrderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<DispoProblemModel>>>;\n    public getProblems(dispoOrderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<DispoProblemModel>>>;\n    public getProblems(dispoOrderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (dispoOrderId === null || dispoOrderId === undefined) {\n            throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<DispoProblemModel>>(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/problems`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProblemModel } from '../model/models';\nimport { TrainStatusTypeModel } from '../model/models';\nimport { TrainVisitModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TrainVisitService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * getTrainVisit\n     * @param trainVisitId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTrainVisit(trainVisitId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<TrainVisitModel>;\n    public getTrainVisit(trainVisitId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<TrainVisitModel>>;\n    public getTrainVisit(trainVisitId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<TrainVisitModel>>;\n    public getTrainVisit(trainVisitId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (trainVisitId === null || trainVisitId === undefined) {\n            throw new Error('Required parameter trainVisitId was null or undefined when calling getTrainVisit.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<TrainVisitModel>(`${this.configuration.basePath}/admin/train-visits/${encodeURIComponent(String(trainVisitId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * searchTrainVisits\n     * @param trainStatus \n     * @param trainIdOperator \n     * @param shippingDateStart \n     * @param shippingDateEnd \n     * @param limit Client suggested limit to restrict the number of entries per page\n     * @param offset Numeric offset of the first element on the page\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public searchTrainVisits(trainStatus?: TrainStatusTypeModel, trainIdOperator?: string, shippingDateStart?: string, shippingDateEnd?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<TrainVisitModel>>;\n    public searchTrainVisits(trainStatus?: TrainStatusTypeModel, trainIdOperator?: string, shippingDateStart?: string, shippingDateEnd?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<TrainVisitModel>>>;\n    public searchTrainVisits(trainStatus?: TrainStatusTypeModel, trainIdOperator?: string, shippingDateStart?: string, shippingDateEnd?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<TrainVisitModel>>>;\n    public searchTrainVisits(trainStatus?: TrainStatusTypeModel, trainIdOperator?: string, shippingDateStart?: string, shippingDateEnd?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (trainStatus !== undefined && trainStatus !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>trainStatus, 'trainStatus');\n        }\n        if (trainIdOperator !== undefined && trainIdOperator !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>trainIdOperator, 'trainIdOperator');\n        }\n        if (shippingDateStart !== undefined && shippingDateStart !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>shippingDateStart, 'shippingDateStart');\n        }\n        if (shippingDateEnd !== undefined && shippingDateEnd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>shippingDateEnd, 'shippingDateEnd');\n        }\n        if (limit !== undefined && limit !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>limit, 'limit');\n        }\n        if (offset !== undefined && offset !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>offset, 'offset');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<TrainVisitModel>>(`${this.configuration.basePath}/admin/train-visits`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * updateTrainVisit\n     * Updates a trainvisit\n     * @param trainVisitId \n     * @param trainVisitModel \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateTrainVisit(trainVisitId: string, trainVisitModel: TrainVisitModel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<TrainVisitModel>;\n    public updateTrainVisit(trainVisitId: string, trainVisitModel: TrainVisitModel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<TrainVisitModel>>;\n    public updateTrainVisit(trainVisitId: string, trainVisitModel: TrainVisitModel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<TrainVisitModel>>;\n    public updateTrainVisit(trainVisitId: string, trainVisitModel: TrainVisitModel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n        if (trainVisitId === null || trainVisitId === undefined) {\n            throw new Error('Required parameter trainVisitId was null or undefined when calling updateTrainVisit.');\n        }\n        if (trainVisitModel === null || trainVisitModel === undefined) {\n            throw new Error('Required parameter trainVisitModel was null or undefined when calling updateTrainVisit.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.put<TrainVisitModel>(`${this.configuration.basePath}/admin/train-visits/${encodeURIComponent(String(trainVisitId))}`,\n            trainVisitModel,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProblemModel } from '../model/models';\nimport { TroubleScenarioModel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TroubleshootingService {\n\n    protected basePath = 'http://api.dev.railmybox.io/dispo';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get list of all scenarios\n     * Get detailed information about all scenarios \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getScenarios(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<Array<TroubleScenarioModel>>;\n    public getScenarios(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpResponse<Array<TroubleScenarioModel>>>;\n    public getScenarios(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<HttpEvent<Array<TroubleScenarioModel>>>;\n    public getScenarios(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/problem+json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (main_auth) required\n        credential = this.configuration.lookupCredential('main_auth');\n        if (credential) {\n            headers = headers.set('Authorization', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/problem+json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<TroubleScenarioModel>>(`${this.configuration.basePath}/admin/troubleshooting/scenarios`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './ac03.service';\nimport { AC03Service } from './ac03.service';\nexport * from './bosis.service';\nimport { BOSISService } from './bosis.service';\nexport * from './caches.service';\nimport { CachesService } from './caches.service';\nexport * from './changes.service';\nimport { ChangesService } from './changes.service';\nexport * from './dispo.service';\nimport { DispoService } from './dispo.service';\nexport * from './external.service';\nimport { ExternalService } from './external.service';\nexport * from './helpdesk.service';\nimport { HelpdeskService } from './helpdesk.service';\nexport * from './orders.service';\nimport { OrdersService } from './orders.service';\nexport * from './problem.service';\nimport { ProblemService } from './problem.service';\nexport * from './train-visit.service';\nimport { TrainVisitService } from './train-visit.service';\nexport * from './troubleshooting.service';\nimport { TroubleshootingService } from './troubleshooting.service';\nexport const APIS = [AC03Service, BOSISService, CachesService, ChangesService, DispoService, ExternalService, HelpdeskService, OrdersService, ProblemService, TrainVisitService, TroubleshootingService];\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AC03MessageModel { \n    /**\n     * Document/Metainfo - ExchangeNumber\n     */\n    exchangeNo: string;\n    /**\n     * Document/Metainfo/Communication/Participants/Code (SENDER)\n     */\n    sender: string;\n    /**\n     * Document/Metainfo/Communication/Participants/Code (RECEIPIENT)\n     */\n    receiver: string;\n    /**\n     * Document/Metainfo/Communication/CreationTime\n     */\n    creationTs: string;\n    /**\n     * Document/Metainfo/Application\n     */\n    application?: string;\n    /**\n     * Status - referenceType * `Response` Positive response message from sender * `Error` Negative response message from sender * `StatusInformation` Status information * `ErrorMessage` Error messages * `Deletion` Cancellations of order / containers \n     */\n    referenceType: AC03MessageModel.ReferenceTypeEnum;\n    /**\n     * Message - ReferenceNumber\n     */\n    referenceNo: string;\n    /**\n     * Test=1, Production=0\n     */\n    testInd?: string;\n}\nexport namespace AC03MessageModel {\n    export type ReferenceTypeEnum = 'Response' | 'Error' | 'StatusInformation' | 'ErrorMessage' | 'Deletion';\n    export const ReferenceTypeEnum = {\n        Response: 'Response' as ReferenceTypeEnum,\n        Error: 'Error' as ReferenceTypeEnum,\n        StatusInformation: 'StatusInformation' as ReferenceTypeEnum,\n        ErrorMessage: 'ErrorMessage' as ReferenceTypeEnum,\n        Deletion: 'Deletion' as ReferenceTypeEnum\n    };\n}\n\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface DispoOrderStatusModel { \n    /**\n     * Identification key of the object\n     */\n    id: string;\n    /**\n     * Status - referenceType * `SendOrder` Order update send by railMybox * `StatusInformation` Status information from service provider * `ErrorMessage` Error messages from service provider \n     */\n    statusType: DispoOrderStatusModel.StatusTypeEnum;\n    /**\n     * A string encoded date and time including timezone description. According to RFC 3339, section 5.6\n     */\n    date: string;\n    /**\n     * Message - ReferenceNumber\n     */\n    messageReferenceNo?: string;\n}\nexport namespace DispoOrderStatusModel {\n    export type StatusTypeEnum = 'SendOrder' | 'StatusInformation' | 'ErrorMessage';\n    export const StatusTypeEnum = {\n        SendOrder: 'SendOrder' as StatusTypeEnum,\n        StatusInformation: 'StatusInformation' as StatusTypeEnum,\n        ErrorMessage: 'ErrorMessage' as StatusTypeEnum\n    };\n}\n\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { TrainVisitModel } from './train-visit.model';\nimport { SendMessageTypeModel } from './send-message-type.model';\n\n\nexport interface DispoOrderStatusSendOrderAllOfModel { \n    trainVisit?: TrainVisitModel;\n    /**\n     * The railMybox dispo reference. Booking reference plus container sequence\n     */\n    reference?: string;\n    messageStatus?: DispoOrderStatusSendOrderAllOfModel.MessageStatusEnum;\n    /**\n     * Communication channel, e.g. AC03\n     */\n    messageChannel?: string;\n    messageType?: SendMessageTypeModel;\n    /**\n     * Send version\n     */\n    sendVersion?: string;\n    /**\n     * In case of error responses, the number of retries\n     */\n    retryCount?: number;\n    /**\n     * Error Code in case of an error status\n     */\n    errorCode?: string;\n    /**\n     * Error Text in case of an error status\n     */\n    errorText?: string;\n}\nexport namespace DispoOrderStatusSendOrderAllOfModel {\n    export type MessageStatusEnum = 'NEW' | 'SEND' | 'DONE' | 'ERROR';\n    export const MessageStatusEnum = {\n        New: 'NEW' as MessageStatusEnum,\n        Send: 'SEND' as MessageStatusEnum,\n        Done: 'DONE' as MessageStatusEnum,\n        Error: 'ERROR' as MessageStatusEnum\n    };\n}\n\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { TrainVisitModel } from './train-visit.model';\nimport { DispoOrderStatusModel } from './dispo-order-status.model';\nimport { SendMessageTypeModel } from './send-message-type.model';\nimport { DispoOrderStatusSendOrderAllOfModel } from './dispo-order-status-send-order-all-of.model';\n\n\nexport interface DispoOrderStatusSendOrderModel extends DispoOrderStatusModel { \n    trainVisit?: TrainVisitModel;\n    /**\n     * The railMybox dispo reference. Booking reference plus container sequence\n     */\n    reference?: string;\n    messageStatus?: DispoOrderStatusSendOrderModel.MessageStatusEnum;\n    /**\n     * Communication channel, e.g. AC03\n     */\n    messageChannel?: string;\n    messageType?: SendMessageTypeModel;\n    /**\n     * Send version\n     */\n    sendVersion?: string;\n    /**\n     * In case of error responses, the number of retries\n     */\n    retryCount?: number;\n    /**\n     * Error Code in case of an error status\n     */\n    errorCode?: string;\n    /**\n     * Error Text in case of an error status\n     */\n    errorText?: string;\n}\nexport namespace DispoOrderStatusSendOrderModel {\n    export type MessageStatusEnum = 'NEW' | 'SEND' | 'DONE' | 'ERROR';\n    export const MessageStatusEnum = {\n        New: 'NEW' as MessageStatusEnum,\n        Send: 'SEND' as MessageStatusEnum,\n        Done: 'DONE' as MessageStatusEnum,\n        Error: 'ERROR' as MessageStatusEnum\n    };\n}\n\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport type DispoOrderStatusTypeModel = 'VERIFICATION' | 'ACCEPTED' | 'MISSING_DATA' | 'DENIED' | 'CANCELLED' | 'DISPATCHED' | 'BOOKING_CLOSED' | 'IN_PROGRESS' | 'TRANSPORT_PROBLEM' | 'REBOOKING' | 'DONE' | 'REQUEST_CANCELLATION' | 'REBOOKING_CANCELLED' | 'ARRIVED';\n\nexport const DispoOrderStatusTypeModel = {\n    Verification: 'VERIFICATION' as DispoOrderStatusTypeModel,\n    Accepted: 'ACCEPTED' as DispoOrderStatusTypeModel,\n    MissingData: 'MISSING_DATA' as DispoOrderStatusTypeModel,\n    Denied: 'DENIED' as DispoOrderStatusTypeModel,\n    Cancelled: 'CANCELLED' as DispoOrderStatusTypeModel,\n    Dispatched: 'DISPATCHED' as DispoOrderStatusTypeModel,\n    BookingClosed: 'BOOKING_CLOSED' as DispoOrderStatusTypeModel,\n    InProgress: 'IN_PROGRESS' as DispoOrderStatusTypeModel,\n    TransportProblem: 'TRANSPORT_PROBLEM' as DispoOrderStatusTypeModel,\n    Rebooking: 'REBOOKING' as DispoOrderStatusTypeModel,\n    Done: 'DONE' as DispoOrderStatusTypeModel,\n    RequestCancellation: 'REQUEST_CANCELLATION' as DispoOrderStatusTypeModel,\n    RebookingCancelled: 'REBOOKING_CANCELLED' as DispoOrderStatusTypeModel,\n    Arrived: 'ARRIVED' as DispoOrderStatusTypeModel\n};\n\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\nimport { AC03Service } from './api/ac03.service';\nimport { BOSISService } from './api/bosis.service';\nimport { CachesService } from './api/caches.service';\nimport { ChangesService } from './api/changes.service';\nimport { DispoService } from './api/dispo.service';\nimport { ExternalService } from './api/external.service';\nimport { HelpdeskService } from './api/helpdesk.service';\nimport { OrdersService } from './api/orders.service';\nimport { ProblemService } from './api/problem.service';\nimport { TrainVisitService } from './api/train-visit.service';\nimport { TroubleshootingService } from './api/troubleshooting.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: []\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders<ApiModule> {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Type of address:   * `LOCATION` - Customer address   * `LOADPOINT` - A loadpoint of a sea station   * `STATION` - A rail station   * `DEPOT` - An address for a depot   * `CUSTOMS` - Customs office address   * `VET` - Veterinary office   * `WEIGHING` - Container Weighing station   * `CPA` - Container check facility (in Hamburg)   * `PORT` - Origin port for vessel transports (automatic) \n */\nexport type AddressTypeModel = 'LOCATION' | 'LOADPOINT' | 'STATION' | 'DEPOT' | 'CUSTOMS' | 'VET' | 'WEIGHING' | 'CPA' | 'PORT';\n\nexport const AddressTypeModel = {\n    Location: 'LOCATION' as AddressTypeModel,\n    Loadpoint: 'LOADPOINT' as AddressTypeModel,\n    Station: 'STATION' as AddressTypeModel,\n    Depot: 'DEPOT' as AddressTypeModel,\n    Customs: 'CUSTOMS' as AddressTypeModel,\n    Vet: 'VET' as AddressTypeModel,\n    Weighing: 'WEIGHING' as AddressTypeModel,\n    Cpa: 'CPA' as AddressTypeModel,\n    Port: 'PORT' as AddressTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * The status of the order: * `IN_CAPTURE` - Created and not placed yet * `VERIFICATION` - Order has be placed for booking and is being sent to the providers * `ACCEPTED` - Order has been accepted by all providers * `MISSING_DATA` - Data is missing for transport * `MISSING_DATA_URGENT` - Data is missing for transport and deadline is nearly hit * `DENIED` - Rejected by a provider * `REBOOKING` - The customer must rebook the order, since deadlines are not met or transport problem * `CANCELLED` - Booking cancelled * `DISPATCHED` - Dispatched * `BOOKING_CLOSED` - The booking is closed and no changes are possible * `IN_PROGRESS` - Transport is in progress * `TRANSPORT_PROBLEM` - A transport problem has occured * `DONE` - The transport is finished and the order is done * `INVOICED` - Invoice has been created * `UNDER_REVIEW` - Order is under review ie. in case of embargo * `REQUEST_CANCELLATION` - User has requested the cancellation of the booking * `ARRIVED` - The transport has arrived at station, import only \n */\nexport type BookingStatusTypeModel = 'IN_CAPTURE' | 'VERIFICATION' | 'ACCEPTED' | 'MISSING_DATA' | 'MISSING_DATA_URGENT' | 'DENIED' | 'REBOOKING' | 'CANCELLED' | 'DISPATCHED' | 'BOOKING_CLOSED' | 'IN_PROGRESS' | 'TRANSPORT_PROBLEM' | 'DONE' | 'INVOICED' | 'UNDER_REVIEW' | 'REQUEST_CANCELLATION' | 'ARRIVED';\n\nexport const BookingStatusTypeModel = {\n    InCapture: 'IN_CAPTURE' as BookingStatusTypeModel,\n    Verification: 'VERIFICATION' as BookingStatusTypeModel,\n    Accepted: 'ACCEPTED' as BookingStatusTypeModel,\n    MissingData: 'MISSING_DATA' as BookingStatusTypeModel,\n    MissingDataUrgent: 'MISSING_DATA_URGENT' as BookingStatusTypeModel,\n    Denied: 'DENIED' as BookingStatusTypeModel,\n    Rebooking: 'REBOOKING' as BookingStatusTypeModel,\n    Cancelled: 'CANCELLED' as BookingStatusTypeModel,\n    Dispatched: 'DISPATCHED' as BookingStatusTypeModel,\n    BookingClosed: 'BOOKING_CLOSED' as BookingStatusTypeModel,\n    InProgress: 'IN_PROGRESS' as BookingStatusTypeModel,\n    TransportProblem: 'TRANSPORT_PROBLEM' as BookingStatusTypeModel,\n    Done: 'DONE' as BookingStatusTypeModel,\n    Invoiced: 'INVOICED' as BookingStatusTypeModel,\n    UnderReview: 'UNDER_REVIEW' as BookingStatusTypeModel,\n    RequestCancellation: 'REQUEST_CANCELLATION' as BookingStatusTypeModel,\n    Arrived: 'ARRIVED' as BookingStatusTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * The type of change\n */\nexport type ChangeTypeModel = 'ADD' | 'CHANGE' | 'DELETE';\n\nexport const ChangeTypeModel = {\n    Add: 'ADD' as ChangeTypeModel,\n    Change: 'CHANGE' as ChangeTypeModel,\n    Delete: 'DELETE' as ChangeTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Container run type\n */\nexport type ContainerStatusTypeModel = 'DONE' | 'ACCEPTED';\n\nexport const ContainerStatusTypeModel = {\n    Done: 'DONE' as ContainerStatusTypeModel,\n    Accepted: 'ACCEPTED' as ContainerStatusTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * The type of customs method\n */\nexport type CustomsTypeModel = 'EMPTY' | 'COMMUNITY' | 'DGCONS';\n\nexport const CustomsTypeModel = {\n    Empty: 'EMPTY' as CustomsTypeModel,\n    Community: 'COMMUNITY' as CustomsTypeModel,\n    Dgcons: 'DGCONS' as CustomsTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Indicate the category of a problem \n */\nexport type ProblemCategoryTypeModel = 'LOADING_POINT' | 'DAMAGES' | 'TRAFFIC';\n\nexport const ProblemCategoryTypeModel = {\n    LoadingPoint: 'LOADING_POINT' as ProblemCategoryTypeModel,\n    Damages: 'DAMAGES' as ProblemCategoryTypeModel,\n    Traffic: 'TRAFFIC' as ProblemCategoryTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Indicate the status of a problem \n */\nexport type ProblemStatusTypeModel = 'OPEN' | 'REOPENED' | 'PENDING' | 'DONE' | 'CANCELLED';\n\nexport const ProblemStatusTypeModel = {\n    Open: 'OPEN' as ProblemStatusTypeModel,\n    Reopened: 'REOPENED' as ProblemStatusTypeModel,\n    Pending: 'PENDING' as ProblemStatusTypeModel,\n    Done: 'DONE' as ProblemStatusTypeModel,\n    Cancelled: 'CANCELLED' as ProblemStatusTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * The message type. * `TRANSPORT_ORDER` - An update for a transport order * `CANCEL` - Cancellation of a transport order \n */\nexport type SendMessageTypeModel = 'TRANSPORT_ORDER' | 'CANCEL';\n\nexport const SendMessageTypeModel = {\n    TransportOrder: 'TRANSPORT_ORDER' as SendMessageTypeModel,\n    Cancel: 'CANCEL' as SendMessageTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport type TrainStatusTypeModel = 'ACTIVE' | 'IN_PROGRESS' | 'DONE' | 'CANCELLED' | 'DELAYED';\n\nexport const TrainStatusTypeModel = {\n    Active: 'ACTIVE' as TrainStatusTypeModel,\n    InProgress: 'IN_PROGRESS' as TrainStatusTypeModel,\n    Done: 'DONE' as TrainStatusTypeModel,\n    Cancelled: 'CANCELLED' as TrainStatusTypeModel,\n    Delayed: 'DELAYED' as TrainStatusTypeModel\n};\n\n","/**\n * Disposition\n * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers. \n *\n * The version of the OpenAPI document: 1.0.52\n * Contact: developer@railmybox.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Container run type. * `VESSELRUN` - Voyage attached for import * `PRERUN` - Truck run before train * `MAINRUN` - Train run * `POSTRUN` - Truck run after train \n */\nexport type TransportSectionModel = 'VESSELRUN' | 'PRERUN' | 'MAINRUN' | 'POSTRUN';\n\nexport const TransportSectionModel = {\n    Vesselrun: 'VESSELRUN' as TransportSectionModel,\n    Prerun: 'PRERUN' as TransportSectionModel,\n    Mainrun: 'MAINRUN' as TransportSectionModel,\n    Postrun: 'POSTRUN' as TransportSectionModel\n};\n\n"],"mappings":"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"}