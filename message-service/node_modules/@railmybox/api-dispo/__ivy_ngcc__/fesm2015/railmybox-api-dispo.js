import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, NgModule, SkipSelf } from '@angular/core';
import * as i1 from '@angular/common/http';
import { HttpHeaders, HttpClient, HttpParams } from '@angular/common/http';

/**
 * Custom HttpParameterCodec
 * Workaround for https://github.com/angular/angular/issues/18261
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
class CustomHttpParameterCodec {
    encodeKey(k) {
        return encodeURIComponent(k);
    }
    encodeValue(v) {
        return encodeURIComponent(v);
    }
    decodeKey(k) {
        return decodeURIComponent(k);
    }
    decodeValue(v) {
        return decodeURIComponent(v);
    }
}

const BASE_PATH = new InjectionToken('basePath');
const COLLECTION_FORMATS = {
    'csv': ',',
    'tsv': '   ',
    'ssv': ' ',
    'pipes': '|'
};

class Configuration {
    constructor(configurationParameters = {}) {
        this.apiKeys = configurationParameters.apiKeys;
        this.username = configurationParameters.username;
        this.password = configurationParameters.password;
        this.accessToken = configurationParameters.accessToken;
        this.basePath = configurationParameters.basePath;
        this.withCredentials = configurationParameters.withCredentials;
        this.encoder = configurationParameters.encoder;
        if (configurationParameters.credentials) {
            this.credentials = configurationParameters.credentials;
        }
        else {
            this.credentials = {};
        }
        // init default api_key credential
        if (!this.credentials['api_key']) {
            this.credentials['api_key'] = () => {
                if (this.apiKeys === null || this.apiKeys === undefined) {
                    return undefined;
                }
                else {
                    return this.apiKeys['api_key'] || this.apiKeys['x-api-key'];
                }
            };
        }
        // init default main_auth credential
        if (!this.credentials['main_auth']) {
            this.credentials['main_auth'] = () => {
                if (this.apiKeys === null || this.apiKeys === undefined) {
                    return undefined;
                }
                else {
                    return this.apiKeys['main_auth'] || this.apiKeys['Authorization'];
                }
            };
        }
    }
    /**
     * Select the correct content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param contentTypes - the array of content types that are available for selection
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderContentType(contentTypes) {
        if (contentTypes.length === 0) {
            return undefined;
        }
        const type = contentTypes.find((x) => this.isJsonMime(x));
        if (type === undefined) {
            return contentTypes[0];
        }
        return type;
    }
    /**
     * Select the correct accept content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param accepts - the array of content types that are available for selection.
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderAccept(accepts) {
        if (accepts.length === 0) {
            return undefined;
        }
        const type = accepts.find((x) => this.isJsonMime(x));
        if (type === undefined) {
            return accepts[0];
        }
        return type;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
    lookupCredential(key) {
        const value = this.credentials[key];
        return typeof value === 'function'
            ? value()
            : value;
    }
}

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class AC03Service {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    processAc03Message(aC03MessageModel, observe = 'body', reportProgress = false, options) {
        if (aC03MessageModel === null || aC03MessageModel === undefined) {
            throw new Error('Required parameter aC03MessageModel was null or undefined when calling processAc03Message.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (api_key) required
        credential = this.configuration.lookupCredential('api_key');
        if (credential) {
            headers = headers.set('x-api-key', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/external/ac03`, aC03MessageModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
AC03Service.ɵfac = function AC03Service_Factory(t) { return new (t || AC03Service)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
AC03Service.ɵprov = i0.ɵɵdefineInjectable({ factory: function AC03Service_Factory() { return new AC03Service(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: AC03Service, providedIn: "root" });
AC03Service.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AC03Service, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class BOSISService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    processBosisMessage(bosisMessageModel, observe = 'body', reportProgress = false, options) {
        if (bosisMessageModel === null || bosisMessageModel === undefined) {
            throw new Error('Required parameter bosisMessageModel was null or undefined when calling processBosisMessage.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (api_key) required
        credential = this.configuration.lookupCredential('api_key');
        if (credential) {
            headers = headers.set('x-api-key', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/external/bosis`, bosisMessageModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
BOSISService.ɵfac = function BOSISService_Factory(t) { return new (t || BOSISService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
BOSISService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BOSISService_Factory() { return new BOSISService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: BOSISService, providedIn: "root" });
BOSISService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BOSISService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class CachesService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    invalidateCaches(observe = 'body', reportProgress = false, options) {
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/caches/invalidate`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
CachesService.ɵfac = function CachesService_Factory(t) { return new (t || CachesService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
CachesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CachesService_Factory() { return new CachesService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: CachesService, providedIn: "root" });
CachesService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CachesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ChangesService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getChanges(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/changes`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ChangesService.ɵfac = function ChangesService_Factory(t) { return new (t || ChangesService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
ChangesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ChangesService_Factory() { return new ChangesService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: ChangesService, providedIn: "root" });
ChangesService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChangesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class DispoService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getChanges(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/changes`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDispoOrder(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrder.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDispoOrderForBooking(bookingref, dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (bookingref === null || bookingref === undefined) {
            throw new Error('Required parameter bookingref was null or undefined when calling getDispoOrderForBooking.');
        }
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderForBooking.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}/${encodeURIComponent(String(dispoOrderId))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDispoOrderMessages(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderMessages.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/messages`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getProblems(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/problems`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getScenarios(observe = 'body', reportProgress = false, options) {
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/troubleshooting/scenarios`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    listDispoOrdersForBooking(bookingref, observe = 'body', reportProgress = false, options) {
        if (bookingref === null || bookingref === undefined) {
            throw new Error('Required parameter bookingref was null or undefined when calling listDispoOrdersForBooking.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchDispoOrders(dispoOrderSearch, limit, offset, observe = 'body', reportProgress = false, options) {
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (dispoOrderSearch !== undefined && dispoOrderSearch !== null) {
            queryParameters = this.addToHttpParams(queryParameters, dispoOrderSearch, 'dispoOrderSearch');
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = this.addToHttpParams(queryParameters, limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = this.addToHttpParams(queryParameters, offset, 'offset');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders`, {
            params: queryParameters,
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateDispoOrder(dispoOrderId, dispoOrderUpdateModel, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');
        }
        if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {
            throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.patch(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`, dispoOrderUpdateModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
DispoService.ɵfac = function DispoService_Factory(t) { return new (t || DispoService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
DispoService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DispoService_Factory() { return new DispoService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: DispoService, providedIn: "root" });
DispoService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DispoService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ExternalService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    processAc03Message(aC03MessageModel, observe = 'body', reportProgress = false, options) {
        if (aC03MessageModel === null || aC03MessageModel === undefined) {
            throw new Error('Required parameter aC03MessageModel was null or undefined when calling processAc03Message.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (api_key) required
        credential = this.configuration.lookupCredential('api_key');
        if (credential) {
            headers = headers.set('x-api-key', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/external/ac03`, aC03MessageModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    processBosisMessage(bosisMessageModel, observe = 'body', reportProgress = false, options) {
        if (bosisMessageModel === null || bosisMessageModel === undefined) {
            throw new Error('Required parameter bosisMessageModel was null or undefined when calling processBosisMessage.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (api_key) required
        credential = this.configuration.lookupCredential('api_key');
        if (credential) {
            headers = headers.set('x-api-key', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/external/bosis`, bosisMessageModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ExternalService.ɵfac = function ExternalService_Factory(t) { return new (t || ExternalService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
ExternalService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ExternalService_Factory() { return new ExternalService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: ExternalService, providedIn: "root" });
ExternalService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ExternalService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class HelpdeskService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getChanges(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getChanges.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/changes`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDispoOrder(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrder.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDispoOrderMessages(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderMessages.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/messages`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getProblems(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/problems`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchDispoOrders(dispoOrderSearch, limit, offset, observe = 'body', reportProgress = false, options) {
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (dispoOrderSearch !== undefined && dispoOrderSearch !== null) {
            queryParameters = this.addToHttpParams(queryParameters, dispoOrderSearch, 'dispoOrderSearch');
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = this.addToHttpParams(queryParameters, limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = this.addToHttpParams(queryParameters, offset, 'offset');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders`, {
            params: queryParameters,
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateDispoOrder(dispoOrderId, dispoOrderUpdateModel, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');
        }
        if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {
            throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.patch(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`, dispoOrderUpdateModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
HelpdeskService.ɵfac = function HelpdeskService_Factory(t) { return new (t || HelpdeskService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
HelpdeskService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HelpdeskService_Factory() { return new HelpdeskService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: HelpdeskService, providedIn: "root" });
HelpdeskService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HelpdeskService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class OrdersService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getDispoOrderForBooking(bookingref, dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (bookingref === null || bookingref === undefined) {
            throw new Error('Required parameter bookingref was null or undefined when calling getDispoOrderForBooking.');
        }
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getDispoOrderForBooking.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}/${encodeURIComponent(String(dispoOrderId))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getScenarios(observe = 'body', reportProgress = false, options) {
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/troubleshooting/scenarios`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    listDispoOrdersForBooking(bookingref, observe = 'body', reportProgress = false, options) {
        if (bookingref === null || bookingref === undefined) {
            throw new Error('Required parameter bookingref was null or undefined when calling listDispoOrdersForBooking.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/dispo-orders/${encodeURIComponent(String(bookingref))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateDispoOrder(dispoOrderId, dispoOrderUpdateModel, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling updateDispoOrder.');
        }
        if (dispoOrderUpdateModel === null || dispoOrderUpdateModel === undefined) {
            throw new Error('Required parameter dispoOrderUpdateModel was null or undefined when calling updateDispoOrder.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.patch(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}`, dispoOrderUpdateModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
OrdersService.ɵfac = function OrdersService_Factory(t) { return new (t || OrdersService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
OrdersService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OrdersService_Factory() { return new OrdersService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: OrdersService, providedIn: "root" });
OrdersService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OrdersService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class ProblemService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getProblems(dispoOrderId, observe = 'body', reportProgress = false, options) {
        if (dispoOrderId === null || dispoOrderId === undefined) {
            throw new Error('Required parameter dispoOrderId was null or undefined when calling getProblems.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/dispo-orders/${encodeURIComponent(String(dispoOrderId))}/problems`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
ProblemService.ɵfac = function ProblemService_Factory(t) { return new (t || ProblemService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
ProblemService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProblemService_Factory() { return new ProblemService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: ProblemService, providedIn: "root" });
ProblemService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ProblemService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class TrainVisitService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getTrainVisit(trainVisitId, observe = 'body', reportProgress = false, options) {
        if (trainVisitId === null || trainVisitId === undefined) {
            throw new Error('Required parameter trainVisitId was null or undefined when calling getTrainVisit.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/train-visits/${encodeURIComponent(String(trainVisitId))}`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    searchTrainVisits(trainStatus, trainIdOperator, shippingDateStart, shippingDateEnd, limit, offset, observe = 'body', reportProgress = false, options) {
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (trainStatus !== undefined && trainStatus !== null) {
            queryParameters = this.addToHttpParams(queryParameters, trainStatus, 'trainStatus');
        }
        if (trainIdOperator !== undefined && trainIdOperator !== null) {
            queryParameters = this.addToHttpParams(queryParameters, trainIdOperator, 'trainIdOperator');
        }
        if (shippingDateStart !== undefined && shippingDateStart !== null) {
            queryParameters = this.addToHttpParams(queryParameters, shippingDateStart, 'shippingDateStart');
        }
        if (shippingDateEnd !== undefined && shippingDateEnd !== null) {
            queryParameters = this.addToHttpParams(queryParameters, shippingDateEnd, 'shippingDateEnd');
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = this.addToHttpParams(queryParameters, limit, 'limit');
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = this.addToHttpParams(queryParameters, offset, 'offset');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/train-visits`, {
            params: queryParameters,
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateTrainVisit(trainVisitId, trainVisitModel, observe = 'body', reportProgress = false, options) {
        if (trainVisitId === null || trainVisitId === undefined) {
            throw new Error('Required parameter trainVisitId was null or undefined when calling updateTrainVisit.');
        }
        if (trainVisitModel === null || trainVisitModel === undefined) {
            throw new Error('Required parameter trainVisitModel was null or undefined when calling updateTrainVisit.');
        }
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/admin/train-visits/${encodeURIComponent(String(trainVisitId))}`, trainVisitModel, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
TrainVisitService.ɵfac = function TrainVisitService_Factory(t) { return new (t || TrainVisitService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
TrainVisitService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TrainVisitService_Factory() { return new TrainVisitService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: TrainVisitService, providedIn: "root" });
TrainVisitService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TrainVisitService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class TroubleshootingService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://api.dev.railmybox.io/dispo';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                value.forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, value.toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    getScenarios(observe = 'body', reportProgress = false, options) {
        let headers = this.defaultHeaders;
        let credential;
        // authentication (main_auth) required
        credential = this.configuration.lookupCredential('main_auth');
        if (credential) {
            headers = headers.set('Authorization', credential);
        }
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts = [
                'application/json',
                'application/problem+json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        let responseType_ = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType_ = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/admin/troubleshooting/scenarios`, {
            responseType: responseType_,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
TroubleshootingService.ɵfac = function TroubleshootingService_Factory(t) { return new (t || TroubleshootingService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
TroubleshootingService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TroubleshootingService_Factory() { return new TroubleshootingService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8)); }, token: TroubleshootingService, providedIn: "root" });
TroubleshootingService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TroubleshootingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();

const APIS = [AC03Service, BOSISService, CachesService, ChangesService, DispoService, ExternalService, HelpdeskService, OrdersService, ProblemService, TrainVisitService, TroubleshootingService];

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var AC03MessageModel;
(function (AC03MessageModel) {
    AC03MessageModel.ReferenceTypeEnum = {
        Response: 'Response',
        Error: 'Error',
        StatusInformation: 'StatusInformation',
        ErrorMessage: 'ErrorMessage',
        Deletion: 'Deletion'
    };
})(AC03MessageModel || (AC03MessageModel = {}));

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const AddressTypeModel = {
    Location: 'LOCATION',
    Loadpoint: 'LOADPOINT',
    Station: 'STATION',
    Depot: 'DEPOT',
    Customs: 'CUSTOMS',
    Vet: 'VET',
    Weighing: 'WEIGHING',
    Cpa: 'CPA',
    Port: 'PORT'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BookingStatusTypeModel = {
    InCapture: 'IN_CAPTURE',
    Verification: 'VERIFICATION',
    Accepted: 'ACCEPTED',
    MissingData: 'MISSING_DATA',
    MissingDataUrgent: 'MISSING_DATA_URGENT',
    Denied: 'DENIED',
    Rebooking: 'REBOOKING',
    Cancelled: 'CANCELLED',
    Dispatched: 'DISPATCHED',
    BookingClosed: 'BOOKING_CLOSED',
    InProgress: 'IN_PROGRESS',
    TransportProblem: 'TRANSPORT_PROBLEM',
    Done: 'DONE',
    Invoiced: 'INVOICED',
    UnderReview: 'UNDER_REVIEW',
    RequestCancellation: 'REQUEST_CANCELLATION',
    Arrived: 'ARRIVED'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ChangeTypeModel = {
    Add: 'ADD',
    Change: 'CHANGE',
    Delete: 'DELETE'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ContainerStatusTypeModel = {
    Done: 'DONE',
    Accepted: 'ACCEPTED'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const CustomsTypeModel = {
    Empty: 'EMPTY',
    Community: 'COMMUNITY',
    Dgcons: 'DGCONS'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var DispoOrderStatusModel;
(function (DispoOrderStatusModel) {
    DispoOrderStatusModel.StatusTypeEnum = {
        SendOrder: 'SendOrder',
        StatusInformation: 'StatusInformation',
        ErrorMessage: 'ErrorMessage'
    };
})(DispoOrderStatusModel || (DispoOrderStatusModel = {}));

var DispoOrderStatusSendOrderAllOfModel;
(function (DispoOrderStatusSendOrderAllOfModel) {
    DispoOrderStatusSendOrderAllOfModel.MessageStatusEnum = {
        New: 'NEW',
        Send: 'SEND',
        Done: 'DONE',
        Error: 'ERROR'
    };
})(DispoOrderStatusSendOrderAllOfModel || (DispoOrderStatusSendOrderAllOfModel = {}));

var DispoOrderStatusSendOrderModel;
(function (DispoOrderStatusSendOrderModel) {
    DispoOrderStatusSendOrderModel.MessageStatusEnum = {
        New: 'NEW',
        Send: 'SEND',
        Done: 'DONE',
        Error: 'ERROR'
    };
})(DispoOrderStatusSendOrderModel || (DispoOrderStatusSendOrderModel = {}));

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const DispoOrderStatusTypeModel = {
    Verification: 'VERIFICATION',
    Accepted: 'ACCEPTED',
    MissingData: 'MISSING_DATA',
    Denied: 'DENIED',
    Cancelled: 'CANCELLED',
    Dispatched: 'DISPATCHED',
    BookingClosed: 'BOOKING_CLOSED',
    InProgress: 'IN_PROGRESS',
    TransportProblem: 'TRANSPORT_PROBLEM',
    Rebooking: 'REBOOKING',
    Done: 'DONE',
    RequestCancellation: 'REQUEST_CANCELLATION',
    RebookingCancelled: 'REBOOKING_CANCELLED',
    Arrived: 'ARRIVED'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ProblemCategoryTypeModel = {
    LoadingPoint: 'LOADING_POINT',
    Damages: 'DAMAGES',
    Traffic: 'TRAFFIC'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const ProblemStatusTypeModel = {
    Open: 'OPEN',
    Reopened: 'REOPENED',
    Pending: 'PENDING',
    Done: 'DONE',
    Cancelled: 'CANCELLED'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const SendMessageTypeModel = {
    TransportOrder: 'TRANSPORT_ORDER',
    Cancel: 'CANCEL'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const TrainStatusTypeModel = {
    Active: 'ACTIVE',
    InProgress: 'IN_PROGRESS',
    Done: 'DONE',
    Cancelled: 'CANCELLED',
    Delayed: 'DELAYED'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const TransportSectionModel = {
    Vesselrun: 'VESSELRUN',
    Prerun: 'PRERUN',
    Mainrun: 'MAINRUN',
    Postrun: 'POSTRUN'
};

/**
 * Disposition
 * This is the OpenAPI description for the disposition service. The disposition service is used to communicate with other service providers.
 *
 * The version of the OpenAPI document: 1.0.52
 * Contact: developer@railmybox.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

class ApiModule {
    constructor(parentModule, http) {
        if (parentModule) {
            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
        }
        if (!http) {
            throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                'See also https://github.com/angular/angular/issues/20575');
        }
    }
    static forRoot(configurationFactory) {
        return {
            ngModule: ApiModule,
            providers: [{ provide: Configuration, useFactory: configurationFactory }]
        };
    }
}
ApiModule.ɵfac = function ApiModule_Factory(t) { return new (t || ApiModule)(ɵngcc0.ɵɵinject(ApiModule, 12), ɵngcc0.ɵɵinject(ɵngcc1.HttpClient, 8)); };
ApiModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ApiModule });
ApiModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
ApiModule.ctorParameters = () => [
    { type: ApiModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: HttpClient, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ApiModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [],
                exports: [],
                providers: []
            }]
    }], function () { return [{ type: ApiModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }, { type: ɵngcc1.HttpClient, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { AC03MessageModel, AC03Service, APIS, AddressTypeModel, ApiModule, BASE_PATH, BOSISService, BookingStatusTypeModel, COLLECTION_FORMATS, CachesService, ChangeTypeModel, ChangesService, Configuration, ContainerStatusTypeModel, CustomsTypeModel, DispoOrderStatusModel, DispoOrderStatusSendOrderAllOfModel, DispoOrderStatusSendOrderModel, DispoOrderStatusTypeModel, DispoService, ExternalService, HelpdeskService, OrdersService, ProblemCategoryTypeModel, ProblemService, ProblemStatusTypeModel, SendMessageTypeModel, TrainStatusTypeModel, TrainVisitService, TransportSectionModel, TroubleshootingService };

//# sourceMappingURL=railmybox-api-dispo.js.map