{"ast":null,"code":"import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, NgModule } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, Observable, throwError, timer, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, take, switchMap, retryWhen, catchError, retry, concatMap, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\n  constructor(http) {\n    this.http = http;\n  }\n\n  get(url, params) {\n    return this.http.get(url, params);\n  }\n\n  post(url, body, params) {\n    return this.http.post(url, body, params);\n  }\n\n}\n\nHttpBaseService.ɵfac = function HttpBaseService_Factory(t) {\n  return new (t || HttpBaseService)(i0.ɵɵinject(i1.HttpClient));\n};\n\nHttpBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HttpBaseService,\n  factory: HttpBaseService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HttpBaseService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpClient\n    }];\n  }, null);\n})();\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\n\nclass DataService {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n  }\n\n  get(url, config, token) {\n    const headers = this.prepareHeaders(token);\n    const params = this.prepareParams(config);\n    return this.httpClient.get(url, {\n      headers,\n      params\n    });\n  }\n\n  post(url, body, config, headersParams) {\n    const headers = headersParams || this.prepareHeaders();\n    const params = this.prepareParams(config);\n    return this.httpClient.post(url, body, {\n      headers,\n      params\n    });\n  }\n\n  prepareHeaders(token) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Accept', 'application/json');\n\n    if (!!token) {\n      headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n    }\n\n    return headers;\n  }\n\n  prepareParams(config) {\n    let params = new HttpParams();\n    const {\n      ngswBypass\n    } = config;\n\n    if (ngswBypass) {\n      params = params.set(NGSW_CUSTOM_PARAM, '');\n    }\n\n    return params;\n  }\n\n}\n\nDataService.ɵfac = function DataService_Factory(t) {\n  return new (t || DataService)(i0.ɵɵinject(HttpBaseService));\n};\n\nDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DataService,\n  factory: DataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: HttpBaseService\n    }];\n  }, null);\n})(); // eslint-disable-next-line no-shadow\n\n\nvar EventTypes;\n\n(function (EventTypes) {\n  /**\r\n   *  This only works in the AppModule Constructor\r\n   */\n  EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\n  EventTypes[EventTypes[\"CheckingAuth\"] = 1] = \"CheckingAuth\";\n  EventTypes[EventTypes[\"CheckingAuthFinished\"] = 2] = \"CheckingAuthFinished\";\n  EventTypes[EventTypes[\"CheckingAuthFinishedWithError\"] = 3] = \"CheckingAuthFinishedWithError\";\n  EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 4] = \"ConfigLoadingFailed\";\n  EventTypes[EventTypes[\"CheckSessionReceived\"] = 5] = \"CheckSessionReceived\";\n  EventTypes[EventTypes[\"UserDataChanged\"] = 6] = \"UserDataChanged\";\n  EventTypes[EventTypes[\"NewAuthenticationResult\"] = 7] = \"NewAuthenticationResult\";\n  EventTypes[EventTypes[\"TokenExpired\"] = 8] = \"TokenExpired\";\n  EventTypes[EventTypes[\"IdTokenExpired\"] = 9] = \"IdTokenExpired\";\n  EventTypes[EventTypes[\"SilentRenewStarted\"] = 10] = \"SilentRenewStarted\";\n})(EventTypes || (EventTypes = {}));\n\nvar LogLevel;\n\n(function (LogLevel) {\n  LogLevel[LogLevel[\"None\"] = 0] = \"None\";\n  LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n  LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\n  LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\n})(LogLevel || (LogLevel = {}));\n/**\r\n * Implement this class-interface to create a custom logger service.\r\n */\n\n\nclass AbstractLoggerService {}\n\nAbstractLoggerService.ɵfac = function AbstractLoggerService_Factory(t) {\n  return new (t || AbstractLoggerService)();\n};\n\nAbstractLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractLoggerService,\n  factory: AbstractLoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractLoggerService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass LoggerService {\n  constructor(abstractLoggerService) {\n    this.abstractLoggerService = abstractLoggerService;\n  }\n\n  logError(configuration, message, ...args) {\n    if (this.loggingIsTurnedOff(configuration)) {\n      return;\n    }\n\n    const {\n      configId\n    } = configuration;\n    const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\n\n    if (!!args && !!args.length) {\n      this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`, ...args);\n    } else {\n      this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`);\n    }\n  }\n\n  logWarning(configuration, message, ...args) {\n    if (!this.logLevelIsSet(configuration)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configuration)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Warn)) {\n      return;\n    }\n\n    const {\n      configId\n    } = configuration;\n    const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\n\n    if (!!args && !!args.length) {\n      this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`, ...args);\n    } else {\n      this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`);\n    }\n  }\n\n  logDebug(configuration, message, ...args) {\n    if (!this.logLevelIsSet(configuration)) {\n      return;\n    }\n\n    if (this.loggingIsTurnedOff(configuration)) {\n      return;\n    }\n\n    if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Debug)) {\n      return;\n    }\n\n    const {\n      configId\n    } = configuration;\n    const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\n\n    if (!!args && !!args.length) {\n      this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`, ...args);\n    } else {\n      this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`);\n    }\n  }\n\n  currentLogLevelIsEqualOrSmallerThan(configuration, logLevelToCompare) {\n    const {\n      logLevel\n    } = configuration || {};\n    return logLevel <= logLevelToCompare;\n  }\n\n  logLevelIsSet(configuration) {\n    const {\n      logLevel\n    } = configuration || {};\n\n    if (logLevel === null) {\n      return false;\n    }\n\n    if (logLevel === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  loggingIsTurnedOff(configuration) {\n    const {\n      logLevel\n    } = configuration || {};\n    return logLevel === LogLevel.None;\n  }\n\n  isObject(possibleObject) {\n    return Object.prototype.toString.call(possibleObject) === '[object Object]';\n  }\n\n}\n\nLoggerService.ɵfac = function LoggerService_Factory(t) {\n  return new (t || LoggerService)(i0.ɵɵinject(AbstractLoggerService));\n};\n\nLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoggerService,\n  factory: LoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AbstractLoggerService\n    }];\n  }, null);\n})();\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\n\n\nclass AbstractSecurityStorage {}\n\nAbstractSecurityStorage.ɵfac = function AbstractSecurityStorage_Factory(t) {\n  return new (t || AbstractSecurityStorage)();\n};\n\nAbstractSecurityStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AbstractSecurityStorage,\n  factory: AbstractSecurityStorage.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AbstractSecurityStorage, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass BrowserStorageService {\n  constructor(loggerService, abstractSecurityStorage) {\n    this.loggerService = loggerService;\n    this.abstractSecurityStorage = abstractSecurityStorage;\n  }\n\n  read(key, configuration) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to read '${key}' but Storage was undefined`);\n      return null;\n    }\n\n    const storedConfig = this.abstractSecurityStorage.read(configId);\n\n    if (!storedConfig) {\n      return null;\n    }\n\n    return JSON.parse(storedConfig);\n  }\n\n  write(value, configuration) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to write '${value}' but Storage was falsy`);\n      return false;\n    }\n\n    value = value || null;\n    this.abstractSecurityStorage.write(configId, JSON.stringify(value));\n    return true;\n  }\n\n  remove(key, configuration) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to remove '${key}' but Storage was falsy`);\n      return false;\n    } // const storage = this.getStorage(configuration);\n    // if (!storage) {\n    //   this.loggerService.logDebug(configuration, `Wanted to write '${key}' but Storage was falsy`);\n    //   return false;\n    // }\n\n\n    this.abstractSecurityStorage.remove(key);\n    return true;\n  } // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\n\n\n  clear(configuration) {\n    if (!this.hasStorage()) {\n      this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\n      return false;\n    } // const storage = this.getStorage(configuration);\n    // if (!storage) {\n    //   this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\n    //   return false;\n    // }\n\n\n    this.abstractSecurityStorage.clear();\n    return true;\n  }\n\n  hasStorage() {\n    return typeof Storage !== 'undefined';\n  }\n\n}\n\nBrowserStorageService.ɵfac = function BrowserStorageService_Factory(t) {\n  return new (t || BrowserStorageService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AbstractSecurityStorage));\n};\n\nBrowserStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: BrowserStorageService,\n  factory: BrowserStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BrowserStorageService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AbstractSecurityStorage\n    }];\n  }, null);\n})();\n\nclass StoragePersistenceService {\n  constructor(browserStorageService) {\n    this.browserStorageService = browserStorageService;\n  }\n\n  read(key, config) {\n    const storedConfig = this.browserStorageService.read(key, config) || {};\n    return storedConfig[key];\n  }\n\n  write(key, value, config) {\n    const storedConfig = this.browserStorageService.read(key, config) || {};\n    storedConfig[key] = value;\n    return this.browserStorageService.write(storedConfig, config);\n  }\n\n  remove(key, config) {\n    const storedConfig = this.browserStorageService.read(key, config) || {};\n    delete storedConfig[key];\n    this.browserStorageService.write(storedConfig, config);\n  }\n\n  clear(config) {\n    this.browserStorageService.clear(config);\n  }\n\n  resetStorageFlowData(config) {\n    this.remove('session_state', config);\n    this.remove('storageSilentRenewRunning', config);\n    this.remove('storageCodeFlowInProgress', config);\n    this.remove('codeVerifier', config);\n    this.remove('userData', config);\n    this.remove('storageCustomParamsAuthRequest', config);\n    this.remove('access_token_expires_at', config);\n    this.remove('storageCustomParamsRefresh', config);\n    this.remove('storageCustomParamsEndSession', config);\n    this.remove('reusable_refresh_token', config);\n  }\n\n  resetAuthStateInStorage(config) {\n    this.remove('authzData', config);\n    this.remove('reusable_refresh_token', config);\n    this.remove('authnResult', config);\n  }\n\n  getAccessToken(config) {\n    return this.read('authzData', config);\n  }\n\n  getIdToken(config) {\n    return this.read('authnResult', config)?.id_token;\n  }\n\n  getRefreshToken(config) {\n    let refreshToken = this.read('authnResult', config)?.refresh_token;\n\n    if (!refreshToken && config.allowUnsafeReuseRefreshToken) {\n      return this.read('reusable_refresh_token', config);\n    }\n\n    return refreshToken;\n  }\n\n  getAuthenticationResult(config) {\n    return this.read('authnResult', config);\n  }\n\n}\n\nStoragePersistenceService.ɵfac = function StoragePersistenceService_Factory(t) {\n  return new (t || StoragePersistenceService)(i0.ɵɵinject(BrowserStorageService));\n};\n\nStoragePersistenceService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StoragePersistenceService,\n  factory: StoragePersistenceService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoragePersistenceService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: BrowserStorageService\n    }];\n  }, null);\n})();\n\nclass PublicEventsService {\n  constructor() {\n    this.notify = new ReplaySubject(1);\n  }\n  /**\r\n   * Fires a new event.\r\n   *\r\n   * @param type The event type.\r\n   * @param value The event value.\r\n   */\n\n\n  fireEvent(type, value) {\n    this.notify.next({\n      type,\n      value\n    });\n  }\n  /**\r\n   * Wires up the event notification observable.\r\n   */\n\n\n  registerForEvents() {\n    return this.notify.asObservable();\n  }\n\n}\n\nPublicEventsService.ɵfac = function PublicEventsService_Factory(t) {\n  return new (t || PublicEventsService)();\n};\n\nPublicEventsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PublicEventsService,\n  factory: PublicEventsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PublicEventsService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst PARTS_OF_TOKEN = 3;\n\nclass TokenHelperService {\n  constructor(loggerService, document) {\n    this.loggerService = loggerService;\n    this.document = document;\n  }\n\n  getTokenExpirationDate(dataIdToken) {\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\n      return new Date(new Date().toUTCString());\n    }\n\n    const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    date.setUTCSeconds(dataIdToken.exp);\n    return date;\n  }\n\n  getSigningInputFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return '';\n    }\n\n    const header = this.getHeaderFromToken(token, encoded, configuration);\n    const payload = this.getPayloadFromToken(token, encoded, configuration);\n    return [header, payload].join('.');\n  }\n\n  getHeaderFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 0, encoded);\n  }\n\n  getPayloadFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 1, encoded);\n  }\n\n  getSignatureFromToken(token, encoded, configuration) {\n    if (!this.tokenIsValid(token, configuration)) {\n      return {};\n    }\n\n    return this.getPartOfToken(token, 2, encoded);\n  }\n\n  getPartOfToken(token, index, encoded) {\n    const partOfToken = this.extractPartOfToken(token, index);\n\n    if (encoded) {\n      return partOfToken;\n    }\n\n    const result = this.urlBase64Decode(partOfToken);\n    return JSON.parse(result);\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, '+').replace(/_/g, '/');\n\n    switch (output.length % 4) {\n      case 0:\n        break;\n\n      case 2:\n        output += '==';\n        break;\n\n      case 3:\n        output += '=';\n        break;\n\n      default:\n        throw Error('Illegal base64url string!');\n    }\n\n    const decoded = typeof this.document.defaultView !== 'undefined' ? this.document.defaultView.atob(output) : Buffer.from(output, 'base64').toString('binary');\n\n    try {\n      // Going backwards: from byte stream, to percent-encoding, to original string.\n      return decodeURIComponent(decoded.split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));\n    } catch (err) {\n      return decoded;\n    }\n  }\n\n  tokenIsValid(token, configuration) {\n    if (!token) {\n      this.loggerService.logError(configuration, `token '${token}' is not valid --> token falsy`);\n      return false;\n    }\n\n    if (!token.includes('.')) {\n      this.loggerService.logError(configuration, `token '${token}' is not valid --> no dots included`);\n      return false;\n    }\n\n    const parts = token.split('.');\n\n    if (parts.length !== PARTS_OF_TOKEN) {\n      this.loggerService.logError(configuration, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\n      return false;\n    }\n\n    return true;\n  }\n\n  extractPartOfToken(token, index) {\n    return token.split('.')[index];\n  }\n\n}\n\nTokenHelperService.ɵfac = function TokenHelperService_Factory(t) {\n  return new (t || TokenHelperService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(DOCUMENT));\n};\n\nTokenHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenHelperService,\n  factory: TokenHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwkExtractor {\n  static buildErrorName(name) {\n    return JwkExtractor.name + ': ' + name;\n  }\n\n  extractJwk(keys, spec, throwOnEmpty = true) {\n    if (0 === keys.length) {\n      throw JwkExtractor.InvalidArgumentError;\n    }\n\n    let foundKeys = keys.filter(k => spec?.kid ? k['kid'] === spec.kid : true).filter(k => spec?.use ? k['use'] === spec.use : true).filter(k => spec?.kty ? k['kty'] === spec.kty : true);\n\n    if (foundKeys.length === 0 && throwOnEmpty) {\n      throw JwkExtractor.NoMatchingKeysError;\n    }\n\n    if (foundKeys.length > 1 && (null === spec || undefined === spec)) {\n      throw JwkExtractor.SeveralMatchingKeysError;\n    }\n\n    return foundKeys;\n  }\n\n}\n\nJwkExtractor.InvalidArgumentError = {\n  name: JwkExtractor.buildErrorName('InvalidArgumentError'),\n  message: 'Array of keys was empty. Unable to extract'\n};\nJwkExtractor.NoMatchingKeysError = {\n  name: JwkExtractor.buildErrorName('NoMatchingKeysError'),\n  message: 'No key found matching the spec'\n};\nJwkExtractor.SeveralMatchingKeysError = {\n  name: JwkExtractor.buildErrorName('SeveralMatchingKeysError'),\n  message: 'More than one key found. Please use spec to filter'\n};\n\nJwkExtractor.ɵfac = function JwkExtractor_Factory(t) {\n  return new (t || JwkExtractor)();\n};\n\nJwkExtractor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwkExtractor,\n  factory: JwkExtractor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwkExtractor, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass CryptoService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  getCrypto() {\n    // support for IE,  (window.crypto || window.msCrypto)\n    return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\n  }\n\n}\n\nCryptoService.ɵfac = function CryptoService_Factory(t) {\n  return new (t || CryptoService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CryptoService,\n  factory: CryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CryptoService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwkWindowCryptoService {\n  constructor(cryptoService) {\n    this.cryptoService = cryptoService;\n  }\n\n  importVerificationKey(key, algorithm) {\n    return this.cryptoService.getCrypto().subtle.importKey('jwk', key, algorithm, false, ['verify']);\n  }\n\n  verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput) {\n    return this.cryptoService.getCrypto().subtle.verify(verifyAlgorithm, cryptoKey, signature, new TextEncoder().encode(signingInput));\n  }\n\n}\n\nJwkWindowCryptoService.ɵfac = function JwkWindowCryptoService_Factory(t) {\n  return new (t || JwkWindowCryptoService)(i0.ɵɵinject(CryptoService));\n};\n\nJwkWindowCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwkWindowCryptoService,\n  factory: JwkWindowCryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwkWindowCryptoService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CryptoService\n    }];\n  }, null);\n})();\n\nclass JwtWindowCryptoService {\n  constructor(cryptoService) {\n    this.cryptoService = cryptoService;\n  }\n\n  generateCodeChallenge(codeVerifier) {\n    return this.calcHash(codeVerifier).pipe(map(challengeRaw => this.base64UrlEncode(challengeRaw)));\n  }\n\n  generateAtHash(accessToken, algorithm) {\n    return this.calcHash(accessToken, algorithm).pipe(map(tokenHash => {\n      let substr = tokenHash.substr(0, tokenHash.length / 2);\n      const tokenHashBase64 = btoa(substr);\n      return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    }));\n  }\n\n  calcHash(valueToHash, algorithm = 'SHA-256') {\n    const msgBuffer = new TextEncoder().encode(valueToHash);\n    return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map(hashBuffer => {\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return this.toHashString(hashArray);\n    }));\n  }\n\n  toHashString(byteArray) {\n    let result = '';\n\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n\n    return result;\n  }\n\n  base64UrlEncode(str) {\n    const base64 = btoa(str);\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  }\n\n}\n\nJwtWindowCryptoService.ɵfac = function JwtWindowCryptoService_Factory(t) {\n  return new (t || JwtWindowCryptoService)(i0.ɵɵinject(CryptoService));\n};\n\nJwtWindowCryptoService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: JwtWindowCryptoService,\n  factory: JwtWindowCryptoService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JwtWindowCryptoService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CryptoService\n    }];\n  }, null);\n})(); // http://openid.net/specs/openid-connect-implicit-1_0.html\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\n// Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\n// in the ID Token.\n\n\nclass TokenValidationService {\n  constructor(tokenHelperService, loggerService, jwkExtractor, jwkWindowCryptoService, jwtWindowCryptoService, document) {\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.jwkExtractor = jwkExtractor;\n    this.jwkWindowCryptoService = jwkWindowCryptoService;\n    this.jwtWindowCryptoService = jwtWindowCryptoService;\n    this.document = document;\n    this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  hasIdTokenExpired(token, configuration, offsetSeconds, disableIdTokenValidation) {\n    const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configuration);\n    return !this.validateIdTokenExpNotExpired(decoded, configuration, offsetSeconds, disableIdTokenValidation);\n  } // id_token C7: The current time MUST be before the time represented by the exp Claim\n  // (possibly allowing for some small leeway to account for clock skew).\n\n\n  validateIdTokenExpNotExpired(decodedIdToken, configuration, offsetSeconds, disableIdTokenValidation) {\n    if (disableIdTokenValidation) {\n      return true;\n    }\n\n    const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (!tokenExpirationDate) {\n      return false;\n    }\n\n    const tokenExpirationValue = tokenExpirationDate.valueOf();\n    const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\n    const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configuration, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\n    return tokenNotExpired;\n  }\n\n  validateAccessTokenNotExpired(accessTokenExpiresAt, configuration, offsetSeconds) {\n    // value is optional, so if it does not exist, then it has not expired\n    if (!accessTokenExpiresAt) {\n      return true;\n    }\n\n    offsetSeconds = offsetSeconds || 0;\n    const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\n    const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\n    const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\n    this.loggerService.logDebug(configuration, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\n    return tokenNotExpired;\n  } // iss\n  // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\n  // https scheme that contains scheme, host,\n  // and optionally, port number and path components and no query or fragment components.\n  //\n  // sub\n  // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n  // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n  // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n  //\n  // aud\n  // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\n  // audience value.\n  // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n  // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n  //\n  // exp\n  // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n  // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n  // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n  // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\n  // the date/ time.\n  // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n  //\n  // iat\n  // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\n  // 1970- 01 - 01T00: 00: 00Z as measured\n  // in UTC until the date/ time.\n\n\n  validateRequiredIdToken(dataIdToken, configuration) {\n    let validated = true;\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iss')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'iss is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'sub')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'sub is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'aud')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'aud is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'exp is missing, this is required in the id_token');\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\n      validated = false;\n      this.loggerService.logWarning(configuration, 'iat is missing, this is required in the id_token');\n    }\n\n    return validated;\n  } // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n  // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n\n\n  validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configuration) {\n    if (disableIatOffsetValidation) {\n      return true;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\n      return false;\n    }\n\n    const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\n\n    dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\n    maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\n    const nowInUtc = new Date(new Date().toUTCString());\n    const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\n    const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\n    this.loggerService.logDebug(configuration, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\n\n    if (diff > 0) {\n      return diff < maxOffsetAllowedInMilliseconds;\n    }\n\n    return -diff < maxOffsetAllowedInMilliseconds;\n  } // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n  // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n  // The precise method for detecting replay attacks is Client specific.\n  // However the nonce claim SHOULD not be present for the refresh_token grant type\n  // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\n  // The current spec is ambiguous and KeyCloak does send it.\n\n\n  validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configuration) {\n    const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\n\n    if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\n      this.loggerService.logDebug(configuration, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\n      return false;\n    }\n\n    return true;\n  } // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n  // MUST exactly match the value of the iss (issuer) Claim.\n\n\n  validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configuration) {\n    if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\n      this.loggerService.logDebug(configuration, 'Validate_id_token_iss failed, dataIdToken.iss: ' + dataIdToken.iss + ' authWellKnownEndpoints issuer:' + authWellKnownEndpointsIssuer);\n      return false;\n    }\n\n    return true;\n  } // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n  // by the iss (issuer) Claim as an audience.\n  // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n  // not trusted by the Client.\n\n\n  validateIdTokenAud(dataIdToken, aud, configuration) {\n    if (Array.isArray(dataIdToken.aud)) {\n      const result = dataIdToken.aud.includes(aud);\n\n      if (!result) {\n        this.loggerService.logDebug(configuration, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n        return false;\n      }\n\n      return true;\n    } else if (dataIdToken.aud !== aud) {\n      this.loggerService.logDebug(configuration, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n      return false;\n    }\n\n    return true;\n  }\n\n  validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\n    if (!dataIdToken) {\n      return false;\n    }\n\n    if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\n      return false;\n    }\n\n    return true;\n  } // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\n\n  validateIdTokenAzpValid(dataIdToken, clientId) {\n    if (!dataIdToken?.azp) {\n      return true;\n    }\n\n    if (dataIdToken.azp === clientId) {\n      return true;\n    }\n\n    return false;\n  }\n\n  validateStateFromHashCallback(state, localState, configuration) {\n    if (state !== localState) {\n      this.loggerService.logDebug(configuration, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\n      return false;\n    }\n\n    return true;\n  } // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n  // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n  // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n  // OpenID Connect Core 1.0 [OpenID.Core] specification.\n\n\n  validateSignatureIdToken(idToken, jwtkeys, configuration) {\n    if (!jwtkeys || !jwtkeys.keys) {\n      return of(false);\n    }\n\n    const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configuration);\n\n    if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\n      this.loggerService.logWarning(configuration, 'id token has no header data');\n      return of(false);\n    }\n\n    const kid = headerData.kid;\n    let alg = headerData.alg;\n    let keys = jwtkeys.keys;\n    let foundKeys;\n    let key;\n\n    if (!this.keyAlgorithms.includes(alg)) {\n      this.loggerService.logWarning(configuration, 'alg not supported', alg);\n      return of(false);\n    }\n\n    const kty = this.alg2kty(alg);\n    const use = 'sig';\n\n    try {\n      foundKeys = kid ? this.jwkExtractor.extractJwk(keys, {\n        kid,\n        kty,\n        use\n      }, false) : this.jwkExtractor.extractJwk(keys, {\n        kty,\n        use\n      }, false);\n\n      if (foundKeys.length === 0) {\n        foundKeys = kid ? this.jwkExtractor.extractJwk(keys, {\n          kid,\n          kty\n        }) : this.jwkExtractor.extractJwk(keys, {\n          kty\n        });\n      }\n\n      key = foundKeys[0];\n    } catch (e) {\n      this.loggerService.logError(configuration, e);\n      return of(false);\n    }\n\n    const algorithm = this.getImportAlg(alg);\n    const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configuration);\n    const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configuration);\n    const agent = this.document.defaultView.navigator.userAgent.toLowerCase();\n\n    if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\n      key.alg = '';\n    }\n\n    return from(this.jwkWindowCryptoService.importVerificationKey(key, algorithm)).pipe(mergeMap(cryptoKey => {\n      const signature = base64url.parse(rawSignature, {\n        loose: true\n      });\n      const verifyAlgorithm = this.getVerifyAlg(alg);\n      return from(this.jwkWindowCryptoService.verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput));\n    }), tap(isValid => {\n      if (!isValid) {\n        this.loggerService.logWarning(configuration, 'incorrect Signature, validation failed for id_token');\n      }\n    }));\n  }\n\n  getImportAlg(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        if (alg.includes('256')) {\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-256'\n          };\n        } else if (alg.includes('384')) {\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-384'\n          };\n        } else if (alg.includes('512')) {\n          return {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: 'SHA-512'\n          };\n        } else {\n          return null;\n        }\n\n      case 'E':\n        if (alg.includes('256')) {\n          return {\n            name: 'ECDSA',\n            namedCurve: 'P-256'\n          };\n        } else if (alg.includes('384')) {\n          return {\n            name: 'ECDSA',\n            namedCurve: 'P-384'\n          };\n        } else {\n          return null;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  getVerifyAlg(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        return {\n          name: 'RSASSA-PKCS1-v1_5',\n          hash: 'SHA-256'\n        };\n\n      case 'E':\n        if (alg.includes('256')) {\n          return {\n            name: 'ECDSA',\n            hash: 'SHA-256'\n          };\n        } else if (alg.includes('384')) {\n          return {\n            name: 'ECDSA',\n            hash: 'SHA-384'\n          };\n        } else {\n          return null;\n        }\n\n      default:\n        return null;\n    }\n  }\n\n  alg2kty(alg) {\n    switch (alg.charAt(0)) {\n      case 'R':\n        return 'RSA';\n\n      case 'E':\n        return 'EC';\n\n      default:\n        throw new Error('Cannot infer kty from alg: ' + alg);\n    }\n  } // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n  //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n  ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n  ////    if (!header_data.hasOwnProperty('kid')) {\n  ////        // no kid defined in Jose header\n  ////        if (jwtkeys.keys.length != 1) {\n  ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n  ////            return false;\n  ////        }\n  ////    }\n  ////    return true;\n  //// }\n  // Access Token Validation\n  // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n  // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n  // access_token C2: Take the left- most half of the hash and base64url- encode it.\n  // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n  // is present in the ID Token.\n\n\n  validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configuration) {\n    this.loggerService.logDebug(configuration, 'at_hash from the server:' + atHash); // 'sha256' 'sha384' 'sha512'\n\n    let sha = 'SHA-256';\n\n    if (idTokenAlg.includes('384')) {\n      sha = 'SHA-384';\n    } else if (idTokenAlg.includes('512')) {\n      sha = 'SHA-512';\n    }\n\n    return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap(hash => {\n      this.loggerService.logDebug(configuration, 'at_hash client validation not decoded:' + hash);\n\n      if (hash === atHash) {\n        return of(true); // isValid;\n      } else {\n        return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map(newHash => {\n          this.loggerService.logDebug(configuration, '-gen access--' + hash);\n          return newHash === atHash;\n        }));\n      }\n    }));\n  }\n\n  millisToMinutesAndSeconds(millis) {\n    const minutes = Math.floor(millis / 60000);\n    const seconds = (millis % 60000 / 1000).toFixed(0);\n    return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\n  }\n\n  calculateNowWithOffset(offsetSeconds) {\n    return new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\n  }\n\n}\n\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\n\nTokenValidationService.ɵfac = function TokenValidationService_Factory(t) {\n  return new (t || TokenValidationService)(i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(JwkExtractor), i0.ɵɵinject(JwkWindowCryptoService), i0.ɵɵinject(JwtWindowCryptoService), i0.ɵɵinject(DOCUMENT));\n};\n\nTokenValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: TokenValidationService,\n  factory: TokenValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TokenValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: JwkExtractor\n    }, {\n      type: JwkWindowCryptoService\n    }, {\n      type: JwtWindowCryptoService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nconst DEFAULT_AUTHRESULT = {\n  isAuthenticated: false,\n  allConfigsAuthenticated: []\n};\n\nclass AuthStateService {\n  constructor(storagePersistenceService, loggerService, publicEventsService, tokenValidationService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.tokenValidationService = tokenValidationService;\n    this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\n  }\n\n  get authenticated$() {\n    return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\n  }\n\n  setAuthenticatedAndFireEvent(allConfigs) {\n    const result = this.composeAuthenticatedResult(allConfigs);\n    this.authenticatedInternal$.next(result);\n  }\n\n  setUnauthenticatedAndFireEvent(currentConfig, allConfigs) {\n    this.storagePersistenceService.resetAuthStateInStorage(currentConfig);\n    const result = this.composeUnAuthenticatedResult(allConfigs);\n    this.authenticatedInternal$.next(result);\n  }\n\n  updateAndPublishAuthState(authenticationResult) {\n    this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\n  }\n\n  setAuthorizationData(accessToken, authResult, currentConfig, allConfigs) {\n    this.loggerService.logDebug(currentConfig, `storing the accessToken '${accessToken}'`);\n    this.storagePersistenceService.write('authzData', accessToken, currentConfig);\n    this.persistAccessTokenExpirationTime(authResult, currentConfig);\n    this.setAuthenticatedAndFireEvent(allConfigs);\n  }\n\n  getAccessToken(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getAccessToken(configuration);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getIdToken(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getIdToken(configuration);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getRefreshToken(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    const token = this.storagePersistenceService.getRefreshToken(configuration);\n    return this.decodeURIComponentSafely(token);\n  }\n\n  getAuthenticationResult(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return null;\n    }\n\n    return this.storagePersistenceService.getAuthenticationResult(configuration);\n  }\n\n  areAuthStorageTokensValid(configuration) {\n    if (!this.isAuthenticated(configuration)) {\n      return false;\n    }\n\n    if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configuration)) {\n      this.loggerService.logDebug(configuration, 'persisted idToken is expired');\n      return false;\n    }\n\n    if (this.hasAccessTokenExpiredIfExpiryExists(configuration)) {\n      this.loggerService.logDebug(configuration, 'persisted accessToken is expired');\n      return false;\n    }\n\n    this.loggerService.logDebug(configuration, 'persisted idToken and accessToken are valid');\n    return true;\n  }\n\n  hasIdTokenExpiredAndRenewCheckIsEnabled(configuration) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds,\n      enableIdTokenExpiredValidationInRenew,\n      disableIdTokenValidation\n    } = configuration;\n\n    if (!enableIdTokenExpiredValidationInRenew) {\n      return false;\n    }\n\n    const tokenToCheck = this.storagePersistenceService.getIdToken(configuration);\n    const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configuration, renewTimeBeforeTokenExpiresInSeconds, disableIdTokenValidation);\n\n    if (idTokenExpired) {\n      this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\n    }\n\n    return idTokenExpired;\n  }\n\n  hasAccessTokenExpiredIfExpiryExists(configuration) {\n    const {\n      renewTimeBeforeTokenExpiresInSeconds\n    } = configuration;\n    const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configuration);\n    const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configuration, renewTimeBeforeTokenExpiresInSeconds);\n    const hasExpired = !accessTokenHasNotExpired;\n\n    if (hasExpired) {\n      this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\n    }\n\n    return hasExpired;\n  }\n\n  isAuthenticated(configuration) {\n    const hasAccessToken = !!this.storagePersistenceService.getAccessToken(configuration);\n    const hasIdToken = !!this.storagePersistenceService.getIdToken(configuration);\n    return hasAccessToken && hasIdToken;\n  }\n\n  decodeURIComponentSafely(token) {\n    if (token) {\n      return decodeURIComponent(token);\n    } else {\n      return '';\n    }\n  }\n\n  persistAccessTokenExpirationTime(authResult, configuration) {\n    if (authResult?.expires_in) {\n      const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\n      this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configuration);\n    }\n  }\n\n  composeAuthenticatedResult(allConfigs) {\n    if (allConfigs.length === 1) {\n      const {\n        configId\n      } = allConfigs[0];\n      return {\n        isAuthenticated: true,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: true\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\n  }\n\n  composeUnAuthenticatedResult(allConfigs) {\n    if (allConfigs.length === 1) {\n      const {\n        configId\n      } = allConfigs[0];\n      return {\n        isAuthenticated: false,\n        allConfigsAuthenticated: [{\n          configId,\n          isAuthenticated: false\n        }]\n      };\n    }\n\n    return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\n  }\n\n  checkAllConfigsIfTheyAreAuthenticated(allConfigs) {\n    const allConfigsAuthenticated = allConfigs.map(config => ({\n      configId: config.configId,\n      isAuthenticated: this.isAuthenticated(config)\n    }));\n    const isAuthenticated = allConfigsAuthenticated.every(x => !!x.isAuthenticated);\n    return {\n      allConfigsAuthenticated,\n      isAuthenticated\n    };\n  }\n\n}\n\nAuthStateService.ɵfac = function AuthStateService_Factory(t) {\n  return new (t || AuthStateService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(TokenValidationService));\n};\n\nAuthStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthStateService,\n  factory: AuthStateService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthStateService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: TokenValidationService\n    }];\n  }, null);\n})();\n\nclass IFrameService {\n  constructor(doc, loggerService) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n  }\n\n  getExistingIFrame(identifier) {\n    const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnParent)) {\n      return iFrameOnParent;\n    }\n\n    const iFrameOnSelf = this.getIFrameFromWindow(identifier);\n\n    if (this.isIFrameElement(iFrameOnSelf)) {\n      return iFrameOnSelf;\n    }\n\n    return null;\n  }\n\n  addIFrameToWindowBody(identifier, config) {\n    const sessionIframe = this.doc.createElement('iframe');\n    sessionIframe.id = identifier;\n    sessionIframe.title = identifier;\n    this.loggerService.logDebug(config, sessionIframe);\n    sessionIframe.style.display = 'none';\n    this.doc.body.appendChild(sessionIframe);\n    return sessionIframe;\n  }\n\n  getIFrameFromParentWindow(identifier) {\n    try {\n      const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\n\n      if (this.isIFrameElement(iFrameElement)) {\n        return iFrameElement;\n      }\n\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  getIFrameFromWindow(identifier) {\n    const iFrameElement = this.doc.getElementById(identifier);\n\n    if (this.isIFrameElement(iFrameElement)) {\n      return iFrameElement;\n    }\n\n    return null;\n  }\n\n  isIFrameElement(element) {\n    return !!element && element instanceof HTMLIFrameElement;\n  }\n\n}\n\nIFrameService.ɵfac = function IFrameService_Factory(t) {\n  return new (t || IFrameService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService));\n};\n\nIFrameService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IFrameService,\n  factory: IFrameService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IFrameService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession'; // http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\nclass CheckSessionService {\n  constructor(storagePersistenceService, loggerService, iFrameService, eventService, zone, document) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.iFrameService = iFrameService;\n    this.eventService = eventService;\n    this.zone = zone;\n    this.document = document;\n    this.checkSessionReceived = false;\n    this.lastIFrameRefresh = 0;\n    this.outstandingMessages = 0;\n    this.heartBeatInterval = 3000;\n    this.iframeRefreshInterval = 60000;\n    this.checkSessionChangedInternal$ = new BehaviorSubject(false);\n  }\n\n  get checkSessionChanged$() {\n    return this.checkSessionChangedInternal$.asObservable();\n  }\n\n  isCheckSessionConfigured(configuration) {\n    const {\n      startCheckSession\n    } = configuration;\n    return startCheckSession;\n  }\n\n  start(configuration) {\n    if (!!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    const {\n      clientId\n    } = configuration;\n    this.pollServerSession(clientId, configuration);\n  }\n\n  stop() {\n    if (!this.scheduledHeartBeatRunning) {\n      return;\n    }\n\n    this.clearScheduledHeartBeat();\n    this.checkSessionReceived = false;\n  }\n\n  serverStateChanged(configuration) {\n    const {\n      startCheckSession\n    } = configuration;\n    return startCheckSession && this.checkSessionReceived;\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n  }\n\n  init(configuration) {\n    if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n      return of(undefined);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(configuration, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\n      return of();\n    }\n\n    const existingIframe = this.getOrCreateIframe(configuration);\n    const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\n\n    if (checkSessionIframe) {\n      existingIframe.contentWindow.location.replace(checkSessionIframe);\n    } else {\n      this.loggerService.logWarning(configuration, 'CheckSession - init check session: checkSessionIframe is not configured to run');\n    }\n\n    return new Observable(observer => {\n      existingIframe.onload = () => {\n        this.lastIFrameRefresh = Date.now();\n        observer.next();\n        observer.complete();\n      };\n    });\n  }\n\n  pollServerSession(clientId, configuration) {\n    this.outstandingMessages = 0;\n\n    const pollServerSessionRecur = () => {\n      this.init(configuration).pipe(take(1)).subscribe(() => {\n        const existingIframe = this.getExistingIframe();\n\n        if (existingIframe && clientId) {\n          this.loggerService.logDebug(configuration, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n          const sessionState = this.storagePersistenceService.read('session_state', configuration);\n          const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n          if (sessionState && authWellKnownEndPoints?.checkSessionIframe) {\n            const iframeOrigin = new URL(authWellKnownEndPoints.checkSessionIframe)?.origin;\n            this.outstandingMessages++;\n            existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\n          } else {\n            this.loggerService.logDebug(configuration, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\n            this.checkSessionChangedInternal$.next(true);\n          }\n        } else {\n          this.loggerService.logWarning(configuration, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\n        } // after sending three messages with no response, fail.\n\n\n        if (this.outstandingMessages > 3) {\n          this.loggerService.logError(configuration, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\n        }\n\n        this.zone.runOutsideAngular(() => {\n          this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\n        });\n      });\n    };\n\n    pollServerSessionRecur();\n  }\n\n  clearScheduledHeartBeat() {\n    clearTimeout(this.scheduledHeartBeatRunning);\n    this.scheduledHeartBeatRunning = null;\n  }\n\n  messageHandler(configuration, e) {\n    const existingIFrame = this.getExistingIframe();\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const startsWith = !!authWellKnownEndPoints?.checkSessionIframe?.startsWith(e.origin);\n    this.outstandingMessages = 0;\n\n    if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\n      if (e.data === 'error') {\n        this.loggerService.logWarning(configuration, 'CheckSession - error from check session messageHandler');\n      } else if (e.data === 'changed') {\n        this.loggerService.logDebug(configuration, `CheckSession - ${e} from check session messageHandler`);\n        this.checkSessionReceived = true;\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.checkSessionChangedInternal$.next(true);\n      } else {\n        this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\n        this.loggerService.logDebug(configuration, `CheckSession - ${e.data} from check session messageHandler`);\n      }\n    }\n  }\n\n  bindMessageEventToIframe(configId) {\n    const iframeMessageEvent = this.messageHandler.bind(this, configId);\n    this.document.defaultView.addEventListener('message', iframeMessageEvent, false);\n  }\n\n  getOrCreateIframe(configuration) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configuration);\n      const {\n        configId\n      } = configuration;\n      this.bindMessageEventToIframe(configId);\n      return frame;\n    }\n\n    return existingIframe;\n  }\n\n}\n\nCheckSessionService.ɵfac = function CheckSessionService_Factory(t) {\n  return new (t || CheckSessionService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(IFrameService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n};\n\nCheckSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckSessionService,\n  factory: CheckSessionService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckSessionService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: IFrameService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass CurrentUrlService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  getStateParamFromCurrentUrl() {\n    const currentUrl = this.getCurrentUrl();\n    const parsedUrl = new URL(currentUrl);\n    const urlParams = new URLSearchParams(parsedUrl.search);\n    const stateFromUrl = urlParams.get('state');\n    return stateFromUrl;\n  }\n\n  currentUrlHasStateParam() {\n    return !!this.getStateParamFromCurrentUrl();\n  }\n\n  getCurrentUrl() {\n    return this.doc.defaultView.location.toString();\n  }\n\n}\n\nCurrentUrlService.ɵfac = function CurrentUrlService_Factory(t) {\n  return new (t || CurrentUrlService)(i0.ɵɵinject(DOCUMENT));\n};\n\nCurrentUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CurrentUrlService,\n  factory: CurrentUrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CurrentUrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[\"NotSet\"] = \"NotSet\";\n  ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\n  ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\n  ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\n  ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\n  ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\n  ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\n  ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\n  ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\n  ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\n  ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\n  ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\n  ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\n  ValidationResult[\"Ok\"] = \"Ok\";\n  ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\n  ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\n})(ValidationResult || (ValidationResult = {}));\n\nclass UriEncoder {\n  encodeKey(key) {\n    return encodeURIComponent(key);\n  }\n\n  encodeValue(value) {\n    return encodeURIComponent(value);\n  }\n\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n\n}\n\nclass RandomService {\n  constructor(cryptoService, loggerService) {\n    this.cryptoService = cryptoService;\n    this.loggerService = loggerService;\n  }\n\n  createRandom(requiredLength, configuration) {\n    if (requiredLength <= 0) {\n      return '';\n    }\n\n    if (requiredLength > 0 && requiredLength < 7) {\n      this.loggerService.logWarning(configuration, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\n      requiredLength = 10;\n    }\n\n    const length = requiredLength - 6;\n    const arr = new Uint8Array(Math.floor(length / 2));\n    const crypto = this.cryptoService.getCrypto();\n\n    if (crypto) {\n      crypto.getRandomValues(arr);\n    }\n\n    return Array.from(arr, this.toHex).join('') + this.randomString(7);\n  }\n\n  toHex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n  }\n\n  randomString(length) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const values = new Uint32Array(length);\n    const crypto = this.cryptoService.getCrypto();\n\n    if (crypto) {\n      crypto.getRandomValues(values);\n\n      for (let i = 0; i < length; i++) {\n        result += characters[values[i] % characters.length];\n      }\n    }\n\n    return result;\n  }\n\n}\n\nRandomService.ɵfac = function RandomService_Factory(t) {\n  return new (t || RandomService)(i0.ɵɵinject(CryptoService), i0.ɵɵinject(LoggerService));\n};\n\nRandomService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RandomService,\n  factory: RandomService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RandomService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CryptoService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowsDataService {\n  constructor(storagePersistenceService, randomService, loggerService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.randomService = randomService;\n    this.loggerService = loggerService;\n  }\n\n  createNonce(configuration) {\n    const nonce = this.randomService.createRandom(40, configuration);\n    this.loggerService.logDebug(configuration, 'Nonce created. nonce:' + nonce);\n    this.setNonce(nonce, configuration);\n    return nonce;\n  }\n\n  setNonce(nonce, configuration) {\n    this.storagePersistenceService.write('authNonce', nonce, configuration);\n  }\n\n  getAuthStateControl(configuration) {\n    return this.storagePersistenceService.read('authStateControl', configuration);\n  }\n\n  setAuthStateControl(authStateControl, configuration) {\n    return this.storagePersistenceService.write('authStateControl', authStateControl, configuration);\n  }\n\n  getExistingOrCreateAuthStateControl(configuration) {\n    let state = this.storagePersistenceService.read('authStateControl', configuration);\n\n    if (!state) {\n      state = this.randomService.createRandom(40, configuration);\n      this.storagePersistenceService.write('authStateControl', state, configuration);\n    }\n\n    return state;\n  }\n\n  setSessionState(sessionState, configuration) {\n    this.storagePersistenceService.write('session_state', sessionState, configuration);\n  }\n\n  resetStorageFlowData(configuration) {\n    this.storagePersistenceService.resetStorageFlowData(configuration);\n  }\n\n  getCodeVerifier(configuration) {\n    return this.storagePersistenceService.read('codeVerifier', configuration);\n  }\n\n  createCodeVerifier(configuration) {\n    const codeVerifier = this.randomService.createRandom(67, configuration);\n    this.storagePersistenceService.write('codeVerifier', codeVerifier, configuration);\n    return codeVerifier;\n  }\n\n  isCodeFlowInProgress(configuration) {\n    const storageObject = this.getCodeFlowInProgressStorageEntry(configuration);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    return storageObject.state === 'in progress';\n  }\n\n  setCodeFlowInProgress(configuration) {\n    const storageObject = {\n      state: 'in progress'\n    };\n    this.storagePersistenceService.write('storageCodeFlowInProgress', JSON.stringify(storageObject), configuration);\n  }\n\n  resetCodeFlowInProgress(configuration) {\n    this.storagePersistenceService.write('storageCodeFlowInProgress', '', configuration);\n  }\n\n  getCodeFlowInProgressStorageEntry(configuration) {\n    const storageEntry = this.storagePersistenceService.read('storageCodeFlowInProgress', configuration);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n  isSilentRenewRunning(configuration) {\n    const {\n      configId,\n      silentRenewTimeoutInSeconds\n    } = configuration;\n    const storageObject = this.getSilentRenewRunningStorageEntry(configuration);\n\n    if (!storageObject) {\n      return false;\n    }\n\n    const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\n    const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\n    const currentDateUtc = Date.parse(new Date().toISOString());\n    const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\n    const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\n\n    if (isProbablyStuck) {\n      this.loggerService.logDebug(configuration, 'silent renew process is probably stuck, state will be reset.', configId);\n      this.resetSilentRenewRunning(configuration);\n      return false;\n    }\n\n    return storageObject.state === 'running';\n  }\n\n  setSilentRenewRunning(configuration) {\n    const storageObject = {\n      state: 'running',\n      dateOfLaunchedProcessUtc: new Date().toISOString()\n    };\n    this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configuration);\n  }\n\n  resetSilentRenewRunning(configuration) {\n    this.storagePersistenceService.write('storageSilentRenewRunning', '', configuration);\n  }\n\n  getSilentRenewRunningStorageEntry(configuration) {\n    const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configuration);\n\n    if (!storageEntry) {\n      return null;\n    }\n\n    return JSON.parse(storageEntry);\n  }\n\n}\n\nFlowsDataService.ɵfac = function FlowsDataService_Factory(t) {\n  return new (t || FlowsDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RandomService), i0.ɵɵinject(LoggerService));\n};\n\nFlowsDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsDataService,\n  factory: FlowsDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: RandomService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass FlowHelper {\n  isCurrentFlowCodeFlow(configuration) {\n    return this.currentFlowIs('code', configuration);\n  }\n\n  isCurrentFlowAnyImplicitFlow(configuration) {\n    return this.isCurrentFlowImplicitFlowWithAccessToken(configuration) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configuration);\n  }\n\n  isCurrentFlowCodeFlowWithRefreshTokens(configuration) {\n    const {\n      useRefreshToken\n    } = configuration;\n\n    if (this.isCurrentFlowCodeFlow(configuration) && useRefreshToken) {\n      return true;\n    }\n\n    return false;\n  }\n\n  isCurrentFlowImplicitFlowWithAccessToken(configuration) {\n    return this.currentFlowIs('id_token token', configuration);\n  }\n\n  currentFlowIs(flowTypes, configuration) {\n    const {\n      responseType\n    } = configuration;\n\n    if (Array.isArray(flowTypes)) {\n      return flowTypes.some(x => responseType === x);\n    }\n\n    return responseType === flowTypes;\n  }\n\n  isCurrentFlowImplicitFlowWithoutAccessToken(configuration) {\n    return this.currentFlowIs('id_token', configuration);\n  }\n\n}\n\nFlowHelper.ɵfac = function FlowHelper_Factory(t) {\n  return new (t || FlowHelper)();\n};\n\nFlowHelper.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowHelper,\n  factory: FlowHelper.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowHelper, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\nconst AUTH0_ENDPOINT = 'auth0.com';\n\nclass UrlService {\n  constructor(loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.flowHelper = flowHelper;\n    this.storagePersistenceService = storagePersistenceService;\n    this.jwtWindowCryptoService = jwtWindowCryptoService;\n  }\n\n  getUrlParameter(urlToCheck, name) {\n    if (!urlToCheck) {\n      return '';\n    }\n\n    if (!name) {\n      return '';\n    }\n\n    name = name.replace(/[[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n    const regex = new RegExp('[\\\\?&#]' + name + '=([^&#]*)');\n    const results = regex.exec(urlToCheck);\n    return results === null ? '' : decodeURIComponent(results[1]);\n  }\n\n  isCallbackFromSts(currentUrl) {\n    return CALLBACK_PARAMS_TO_CHECK.some(x => !!this.getUrlParameter(currentUrl, x));\n  }\n\n  getRefreshSessionSilentRenewUrl(config, customParams) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n      return this.createUrlCodeFlowWithSilentRenew(config, customParams);\n    }\n\n    return of(this.createUrlImplicitFlowWithSilentRenew(config, customParams) || '');\n  }\n\n  getAuthorizeParUrl(requestUri, configuration) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n      return null;\n    }\n\n    const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId\n    } = configuration;\n\n    if (!clientId) {\n      this.loggerService.logError(configuration, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('request_uri', requestUri);\n    params = params.append('client_id', clientId);\n    return `${authorizationUrl}?${params}`;\n  }\n\n  getAuthorizeUrl(config, authOptions) {\n    if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n      return this.createUrlCodeFlowAuthorize(config, authOptions);\n    }\n\n    return of(this.createUrlImplicitFlowAuthorize(config, authOptions) || '');\n  }\n\n  createEndSessionUrl(idTokenHint, configuration, customParamsEndSession) {\n    // Auth0 needs a special logout url\n    // See https://auth0.com/docs/api/authentication#logout\n    if (this.isAuth0Endpoint(configuration)) {\n      return this.composeAuth0Endpoint(configuration);\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const endSessionEndpoint = authWellKnownEndPoints?.endSessionEndpoint;\n\n    if (!endSessionEndpoint) {\n      return null;\n    }\n\n    const urlParts = endSessionEndpoint.split('?');\n    const authorizationEndSessionUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n\n    if (!!idTokenHint) {\n      params = params.set('id_token_hint', idTokenHint);\n    }\n\n    const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configuration);\n\n    if (postLogoutRedirectUri) {\n      params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\n    }\n\n    if (customParamsEndSession) {\n      params = this.appendCustomParams({ ...customParamsEndSession\n      }, params);\n    }\n\n    return `${authorizationEndSessionUrl}?${params}`;\n  }\n\n  createRevocationEndpointBodyAccessToken(token, configuration) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'access_token');\n    return params.toString();\n  }\n\n  createRevocationEndpointBodyRefreshToken(token, configuration) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('client_id', clientId);\n    params = params.set('token', token);\n    params = params.set('token_type_hint', 'refresh_token');\n    return params.toString();\n  }\n\n  getRevocationEndpointUrl(configuration) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const revocationEndpoint = authWellKnownEndPoints?.revocationEndpoint;\n\n    if (!revocationEndpoint) {\n      return null;\n    }\n\n    const urlParts = revocationEndpoint.split('?');\n    const revocationEndpointUrl = urlParts[0];\n    return revocationEndpointUrl;\n  }\n\n  createBodyForCodeFlowCodeRequest(code, configuration, customTokenParams) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'authorization_code');\n    params = params.set('client_id', clientId);\n\n    if (!configuration.disablePkce) {\n      const codeVerifier = this.flowsDataService.getCodeVerifier(configuration);\n\n      if (!codeVerifier) {\n        this.loggerService.logError(configuration, `CodeVerifier is not set `, codeVerifier);\n        return null;\n      }\n\n      params = params.set('code_verifier', codeVerifier);\n    }\n\n    params = params.set('code', code);\n\n    if (customTokenParams) {\n      params = this.appendCustomParams({ ...customTokenParams\n      }, params);\n    }\n\n    const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n    if (this.flowsDataService.isSilentRenewRunning(configuration) && silentRenewUrl) {\n      params = params.set('redirect_uri', silentRenewUrl);\n      return params.toString();\n    }\n\n    const redirectUrl = this.getRedirectUrl(configuration);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    params = params.set('redirect_uri', redirectUrl);\n    return params.toString();\n  }\n\n  createBodyForCodeFlowRefreshTokensRequest(refreshToken, configuration, customParamsRefresh) {\n    const clientId = this.getClientId(configuration);\n\n    if (!clientId) {\n      return null;\n    }\n\n    let params = this.createHttpParams();\n    params = params.set('grant_type', 'refresh_token');\n    params = params.set('client_id', clientId);\n    params = params.set('refresh_token', refreshToken);\n\n    if (customParamsRefresh) {\n      params = this.appendCustomParams({ ...customParamsRefresh\n      }, params);\n    }\n\n    return params.toString();\n  }\n\n  createBodyForParCodeFlowRequest(configuration, customParamsRequest) {\n    const redirectUrl = this.getRedirectUrl(configuration);\n\n    if (!redirectUrl) {\n      return of(null);\n    }\n\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const {\n        clientId,\n        responseType,\n        scope,\n        hdParam,\n        customParamsAuthRequest\n      } = configuration;\n      let params = this.createHttpParams('');\n      params = params.set('client_id', clientId);\n      params = params.append('redirect_uri', redirectUrl);\n      params = params.append('response_type', responseType);\n      params = params.append('scope', scope);\n      params = params.append('nonce', nonce);\n      params = params.append('state', state);\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n\n      if (hdParam) {\n        params = params.append('hd', hdParam);\n      }\n\n      if (customParamsAuthRequest) {\n        params = this.appendCustomParams({ ...customParamsAuthRequest\n        }, params);\n      }\n\n      if (customParamsRequest) {\n        params = this.appendCustomParams({ ...customParamsRequest\n        }, params);\n      }\n\n      return params.toString();\n    }));\n  }\n\n  createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configuration, prompt, customRequestParams) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n    const authorizationEndpoint = authWellKnownEndPoints?.authorizationEndpoint;\n\n    if (!authorizationEndpoint) {\n      this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\n      return null;\n    }\n\n    const {\n      clientId,\n      responseType,\n      scope,\n      hdParam,\n      customParamsAuthRequest\n    } = configuration;\n\n    if (!clientId) {\n      this.loggerService.logError(configuration, `createAuthorizeUrl could not add clientId because it was: `, clientId);\n      return null;\n    }\n\n    if (!responseType) {\n      this.loggerService.logError(configuration, `createAuthorizeUrl could not add responseType because it was: `, responseType);\n      return null;\n    }\n\n    if (!scope) {\n      this.loggerService.logError(configuration, `createAuthorizeUrl could not add scope because it was: `, scope);\n      return null;\n    }\n\n    const urlParts = authorizationEndpoint.split('?');\n    const authorizationUrl = urlParts[0];\n    const existingParams = urlParts[1];\n    let params = this.createHttpParams(existingParams);\n    params = params.set('client_id', clientId);\n    params = params.append('redirect_uri', redirectUrl);\n    params = params.append('response_type', responseType);\n    params = params.append('scope', scope);\n    params = params.append('nonce', nonce);\n    params = params.append('state', state);\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configuration) && codeChallenge !== null) {\n      params = params.append('code_challenge', codeChallenge);\n      params = params.append('code_challenge_method', 'S256');\n    }\n\n    const mergedParams = { ...customParamsAuthRequest,\n      ...customRequestParams\n    };\n\n    if (Object.keys(mergedParams).length > 0) {\n      params = this.appendCustomParams({ ...mergedParams\n      }, params);\n    }\n\n    if (prompt) {\n      params = this.overWriteParam(params, 'prompt', prompt);\n    }\n\n    if (hdParam) {\n      params = params.append('hd', hdParam);\n    }\n\n    return `${authorizationUrl}?${params}`;\n  }\n\n  createUrlImplicitFlowWithSilentRenew(configuration, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n    if (!silentRenewUrl) {\n      return null;\n    }\n\n    this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ', state);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (authWellKnownEndPoints) {\n      return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configuration, 'none', customParams);\n    }\n\n    this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowWithSilentRenew(configuration, customParams) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ' + state); // code_challenge with \"S256\"\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map(codeChallenge => {\n      const silentRenewUrl = this.getSilentRenewUrl(configuration);\n\n      if (!silentRenewUrl) {\n        return '';\n      }\n\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n      if (authWellKnownEndPoints) {\n        return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configuration, 'none', customParams);\n      }\n\n      this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\n      return null;\n    }));\n  }\n\n  createUrlImplicitFlowAuthorize(configuration, authOptions) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\n    const nonce = this.flowsDataService.createNonce(configuration);\n    this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(configuration, authOptions);\n\n    if (!redirectUrl) {\n      return null;\n    }\n\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (authWellKnownEndPoints) {\n      const {\n        customParams\n      } = authOptions || {};\n      return this.createAuthorizeUrl('', redirectUrl, nonce, state, configuration, null, customParams);\n    }\n\n    this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\n    return null;\n  }\n\n  createUrlCodeFlowAuthorize(config, authOptions) {\n    const state = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\n    const nonce = this.flowsDataService.createNonce(config);\n    this.loggerService.logDebug(config, 'Authorize created. adding myautostate: ' + state);\n    const redirectUrl = this.getRedirectUrl(config, authOptions);\n\n    if (!redirectUrl) {\n      return of(null);\n    }\n\n    return this.getCodeChallenge(config).pipe(map(codeChallenge => {\n      const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n\n      if (authWellKnownEndPoints) {\n        const {\n          customParams\n        } = authOptions || {};\n        return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, config, null, customParams);\n      }\n\n      this.loggerService.logError(config, 'authWellKnownEndpoints is undefined');\n      return '';\n    }));\n  }\n\n  getCodeChallenge(config) {\n    if (config.disablePkce) {\n      return of(null);\n    } // code_challenge with \"S256\"\n\n\n    const codeVerifier = this.flowsDataService.createCodeVerifier(config);\n    return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier);\n  }\n\n  getRedirectUrl(configuration, authOptions) {\n    let {\n      redirectUrl\n    } = configuration;\n\n    if (authOptions?.redirectUrl) {\n      // override by redirectUrl from authOptions\n      redirectUrl = authOptions.redirectUrl;\n    }\n\n    if (!redirectUrl) {\n      this.loggerService.logError(configuration, `could not get redirectUrl, was: `, redirectUrl);\n      return null;\n    }\n\n    return redirectUrl;\n  }\n\n  getSilentRenewUrl(configuration) {\n    const {\n      silentRenewUrl\n    } = configuration;\n\n    if (!silentRenewUrl) {\n      this.loggerService.logError(configuration, `could not get silentRenewUrl, was: `, silentRenewUrl);\n      return null;\n    }\n\n    return silentRenewUrl;\n  }\n\n  getPostLogoutRedirectUrl(configuration) {\n    const {\n      postLogoutRedirectUri\n    } = configuration;\n\n    if (!postLogoutRedirectUri) {\n      this.loggerService.logError(configuration, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\n      return null;\n    }\n\n    return postLogoutRedirectUri;\n  }\n\n  getClientId(configuration) {\n    const {\n      clientId\n    } = configuration;\n\n    if (!clientId) {\n      this.loggerService.logError(configuration, `could not get clientId, was: `, clientId);\n      return null;\n    }\n\n    return clientId;\n  }\n\n  appendCustomParams(customParams, params) {\n    for (const [key, value] of Object.entries({ ...customParams\n    })) {\n      params = params.append(key, value.toString());\n    }\n\n    return params;\n  }\n\n  overWriteParam(params, key, value) {\n    return params.set(key, value);\n  }\n\n  createHttpParams(existingParams) {\n    existingParams = existingParams ?? '';\n    const params = new HttpParams({\n      fromString: existingParams,\n      encoder: new UriEncoder()\n    });\n    return params;\n  }\n\n  isAuth0Endpoint(configuration) {\n    const {\n      authority\n    } = configuration;\n\n    if (!authority) {\n      return false;\n    }\n\n    return authority.endsWith(AUTH0_ENDPOINT);\n  }\n\n  composeAuth0Endpoint(configuration) {\n    // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\n    const {\n      authority,\n      clientId\n    } = configuration;\n    const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configuration);\n    return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\n  }\n\n}\n\nUrlService.ɵfac = function UrlService_Factory(t) {\n  return new (t || UrlService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(JwtWindowCryptoService));\n};\n\nUrlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UrlService,\n  factory: UrlService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: JwtWindowCryptoService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackHandlerService {\n  constructor(urlService, loggerService, tokenValidationService, flowsDataService, storagePersistenceService, dataService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.tokenValidationService = tokenValidationService;\n    this.flowsDataService = flowsDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.dataService = dataService;\n  } // STEP 1 Code Flow\n\n\n  codeFlowCallback(urlToCheck, config) {\n    const code = this.urlService.getUrlParameter(urlToCheck, 'code');\n    const state = this.urlService.getUrlParameter(urlToCheck, 'state');\n    const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\n\n    if (!state) {\n      this.loggerService.logDebug(config, 'no state in url');\n      return throwError(() => new Error('no state in url'));\n    }\n\n    if (!code) {\n      this.loggerService.logDebug(config, 'no code in url');\n      return throwError(() => new Error('no code in url'));\n    }\n\n    this.loggerService.logDebug(config, 'running validation for callback', urlToCheck);\n    const initialCallbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: false,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(initialCallbackContext);\n  } // STEP 2 Code Flow //  Code Flow Silent Renew starts here\n\n\n  codeFlowCodeRequest(callbackContext, config) {\n    const authStateControl = this.flowsDataService.getAuthStateControl(config);\n    const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, config);\n\n    if (!isStateCorrect) {\n      return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\n    }\n\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n    const tokenEndpoint = authWellknownEndpoints?.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError(() => new Error('Token Endpoint not defined'));\n    }\n\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, config, config?.customParamsCodeRequest);\n    return this.dataService.post(tokenEndpoint, bodyForCodeFlow, config, headers).pipe(switchMap(response => {\n      let authResult = { ...response,\n        state: callbackContext.state,\n        session_state: callbackContext.sessionState\n      };\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, config)), catchError(error => {\n      const {\n        authority\n      } = config;\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(config, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleRefreshRetry(errors, config) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = config;\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(config, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nCodeFlowCallbackHandlerService.ɵfac = function CodeFlowCallbackHandlerService_Factory(t) {\n  return new (t || CodeFlowCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(DataService));\n};\n\nCodeFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackHandlerService,\n  factory: CodeFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_USERRESULT = {\n  userData: null,\n  allUserData: []\n};\n\nclass UserService {\n  constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper) {\n    this.oidcDataService = oidcDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.eventService = eventService;\n    this.loggerService = loggerService;\n    this.tokenHelperService = tokenHelperService;\n    this.flowHelper = flowHelper;\n    this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\n  }\n\n  get userData$() {\n    return this.userDataInternal$.asObservable();\n  }\n\n  getAndPersistUserDataInStore(currentConfiguration, allConfigs, isRenewProcess = false, idToken, decodedIdToken) {\n    idToken = idToken || this.storagePersistenceService.getIdToken(currentConfiguration);\n    decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, currentConfiguration);\n    const existingUserDataFromStorage = this.getUserDataFromStore(currentConfiguration);\n    const haveUserData = !!existingUserDataFromStorage;\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(currentConfiguration);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(currentConfiguration);\n    const accessToken = this.storagePersistenceService.getAccessToken(currentConfiguration);\n\n    if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\n      this.loggerService.logDebug(currentConfiguration, `authCallback idToken flow with accessToken ${accessToken}`);\n      this.setUserDataToStore(decodedIdToken, currentConfiguration, allConfigs);\n      return of(decodedIdToken);\n    }\n\n    const {\n      renewUserInfoAfterTokenRenew\n    } = currentConfiguration;\n\n    if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\n      return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, currentConfiguration, allConfigs).pipe(switchMap(userData => {\n        this.loggerService.logDebug(currentConfiguration, 'Received user data: ', userData);\n\n        if (!!userData) {\n          this.loggerService.logDebug(currentConfiguration, 'accessToken: ', accessToken);\n          return of(userData);\n        } else {\n          return throwError(() => new Error('Received no user data, request failed'));\n        }\n      }));\n    }\n\n    return of(existingUserDataFromStorage);\n  }\n\n  getUserDataFromStore(currentConfiguration) {\n    return this.storagePersistenceService.read('userData', currentConfiguration) || null;\n  }\n\n  publishUserDataIfExists(currentConfiguration, allConfigs) {\n    const userData = this.getUserDataFromStore(currentConfiguration);\n\n    if (userData) {\n      this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\n    }\n  }\n\n  setUserDataToStore(userData, currentConfiguration, allConfigs) {\n    this.storagePersistenceService.write('userData', userData, currentConfiguration);\n    this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\n  }\n\n  resetUserDataInStore(currentConfiguration, allConfigs) {\n    this.storagePersistenceService.remove('userData', currentConfiguration);\n    this.fireUserDataEvent(currentConfiguration, allConfigs, null);\n  }\n\n  getUserDataOidcFlowAndSave(idTokenSub, currentConfiguration, allConfigs) {\n    return this.getIdentityUserData(currentConfiguration).pipe(map(data => {\n      if (this.validateUserDataSubIdToken(currentConfiguration, idTokenSub, data?.sub)) {\n        this.setUserDataToStore(data, currentConfiguration, allConfigs);\n        return data;\n      } else {\n        // something went wrong, user data sub does not match that from id_token\n        this.loggerService.logWarning(currentConfiguration, `User data sub does not match sub in id_token, resetting`);\n        this.resetUserDataInStore(currentConfiguration, allConfigs);\n        return null;\n      }\n    }));\n  }\n\n  getIdentityUserData(currentConfiguration) {\n    const token = this.storagePersistenceService.getAccessToken(currentConfiguration);\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\n\n    if (!authWellKnownEndPoints) {\n      this.loggerService.logWarning(currentConfiguration, 'init check session: authWellKnownEndpoints is undefined');\n      return throwError(() => new Error('authWellKnownEndpoints is undefined'));\n    }\n\n    const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\n\n    if (!userInfoEndpoint) {\n      this.loggerService.logError(currentConfiguration, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\n      return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\n    }\n\n    return this.oidcDataService.get(userInfoEndpoint, currentConfiguration, token).pipe(retry(2));\n  }\n\n  validateUserDataSubIdToken(currentConfiguration, idTokenSub, userDataSub) {\n    if (!idTokenSub) {\n      return false;\n    }\n\n    if (!userDataSub) {\n      return false;\n    }\n\n    if (idTokenSub !== userDataSub) {\n      this.loggerService.logDebug(currentConfiguration, 'validateUserDataSubIdToken failed', idTokenSub, userDataSub);\n      return false;\n    }\n\n    return true;\n  }\n\n  fireUserDataEvent(currentConfiguration, allConfigs, passedUserData) {\n    const userData = this.composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData);\n    this.userDataInternal$.next(userData);\n    const {\n      configId\n    } = currentConfiguration;\n    this.eventService.fireEvent(EventTypes.UserDataChanged, {\n      configId,\n      userData: passedUserData\n    });\n  }\n\n  composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData) {\n    const hasManyConfigs = allConfigs.length > 1;\n\n    if (!hasManyConfigs) {\n      const {\n        configId\n      } = currentConfiguration;\n      return this.composeSingleUserDataResult(configId, passedUserData);\n    }\n\n    const allUserData = allConfigs.map(config => {\n      const {\n        configId\n      } = currentConfiguration;\n\n      if (this.currentConfigIsToUpdate(configId, config)) {\n        return {\n          configId: config.configId,\n          userData: passedUserData\n        };\n      }\n\n      const alreadySavedUserData = this.storagePersistenceService.read('userData', config) || null;\n      return {\n        configId: config.configId,\n        userData: alreadySavedUserData\n      };\n    });\n    return {\n      userData: null,\n      allUserData\n    };\n  }\n\n  composeSingleUserDataResult(configId, userData) {\n    return {\n      userData,\n      allUserData: [{\n        configId,\n        userData\n      }]\n    };\n  }\n\n  currentConfigIsToUpdate(configId, config) {\n    return config.configId === configId;\n  }\n\n}\n\nUserService.ɵfac = function UserService_Factory(t) {\n  return new (t || UserService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(FlowHelper));\n};\n\nUserService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserService,\n  factory: UserService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: LoggerService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass ResetAuthDataService {\n  constructor(authStateService, flowsDataService, userService) {\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n  }\n\n  resetAuthorizationData(currentConfiguration, allConfigs) {\n    this.userService.resetUserDataInStore(currentConfiguration, allConfigs);\n    this.flowsDataService.resetStorageFlowData(currentConfiguration);\n    this.authStateService.setUnauthenticatedAndFireEvent(currentConfiguration, allConfigs);\n  }\n\n}\n\nResetAuthDataService.ɵfac = function ResetAuthDataService_Factory(t) {\n  return new (t || ResetAuthDataService)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService));\n};\n\nResetAuthDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResetAuthDataService,\n  factory: ResetAuthDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResetAuthDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackHandlerService {\n  constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.loggerService = loggerService;\n    this.flowsDataService = flowsDataService;\n    this.doc = doc;\n  } // STEP 1 Code Flow\n  // STEP 1 Implicit Flow\n\n\n  implicitFlowCallback(config, allConfigs, hash) {\n    const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(config);\n    this.loggerService.logDebug(config, 'BEGIN callback, no auth data');\n\n    if (!isRenewProcessData) {\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n    }\n\n    hash = hash || this.doc.location.hash.substr(1);\n    const authResult = hash.split('&').reduce((resultData, item) => {\n      const parts = item.split('=');\n      resultData[parts.shift()] = parts.join('=');\n      return resultData;\n    }, {});\n    const callbackContext = {\n      code: null,\n      refreshToken: null,\n      state: null,\n      sessionState: null,\n      authResult,\n      isRenewProcess: isRenewProcessData,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return of(callbackContext);\n  }\n\n}\n\nImplicitFlowCallbackHandlerService.ɵfac = function ImplicitFlowCallbackHandlerService_Factory(t) {\n  return new (t || ImplicitFlowCallbackHandlerService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nImplicitFlowCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackHandlerService,\n  factory: ImplicitFlowCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass SigninKeyDataService {\n  constructor(storagePersistenceService, loggerService, dataService) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n  }\n\n  getSigningKeys(currentConfiguration) {\n    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\n    const jwksUri = authWellKnownEndPoints?.jwksUri;\n\n    if (!jwksUri) {\n      const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\n      this.loggerService.logWarning(currentConfiguration, error);\n      return throwError(() => new Error(error));\n    }\n\n    this.loggerService.logDebug(currentConfiguration, 'Getting signinkeys from ', jwksUri);\n    return this.dataService.get(jwksUri, currentConfiguration).pipe(retry(2), catchError(e => this.handleErrorGetSigningKeys(e, currentConfiguration)));\n  }\n\n  handleErrorGetSigningKeys(errorResponse, currentConfiguration) {\n    let errMsg = '';\n\n    if (errorResponse instanceof HttpResponse) {\n      const body = errorResponse.body || {};\n      const err = JSON.stringify(body);\n      const {\n        status,\n        statusText\n      } = errorResponse;\n      errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\n    } else {\n      const {\n        message\n      } = errorResponse;\n      errMsg = !!message ? message : `${errorResponse}`;\n    }\n\n    this.loggerService.logError(currentConfiguration, errMsg);\n    return throwError(() => new Error(errMsg));\n  }\n\n}\n\nSigninKeyDataService.ɵfac = function SigninKeyDataService_Factory(t) {\n  return new (t || SigninKeyDataService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService));\n};\n\nSigninKeyDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SigninKeyDataService,\n  factory: SigninKeyDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SigninKeyDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }];\n  }, null);\n})();\n\nconst JWT_KEYS = 'jwtKeys';\n\nclass HistoryJwtKeysCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService, document) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.signInKeyDataService = signInKeyDataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.document = document;\n  } // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\n\n\n  callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs) {\n    this.storagePersistenceService.write('authnResult', callbackContext.authResult, config);\n\n    if (config.allowUnsafeReuseRefreshToken && callbackContext.authResult.refresh_token) {\n      this.storagePersistenceService.write('reusable_refresh_token', callbackContext.authResult.refresh_token, config);\n    }\n\n    if (this.historyCleanUpTurnedOn(config) && !callbackContext.isRenewProcess) {\n      this.resetBrowserHistory();\n    } else {\n      this.loggerService.logDebug(config, 'history clean up inactive');\n    }\n\n    if (callbackContext.authResult.error) {\n      const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\n      this.loggerService.logDebug(config, errorMessage);\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      this.flowsDataService.setNonce('', config);\n      this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(config, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\n      AuthCallback created, begin token validation`);\n    return this.signInKeyDataService.getSigningKeys(config).pipe(tap(jwtKeys => this.storeSigningKeys(jwtKeys, config)), catchError(err => {\n      // fallback: try to load jwtKeys from storage\n      const storedJwtKeys = this.readSigningKeys(config);\n\n      if (!!storedJwtKeys) {\n        this.loggerService.logWarning(config, `Failed to retrieve signing keys, fallback to stored keys`);\n        return of(storedJwtKeys);\n      }\n\n      return throwError(() => new Error(err));\n    }), switchMap(jwtKeys => {\n      if (jwtKeys) {\n        callbackContext.jwtKeys = jwtKeys;\n        return of(callbackContext);\n      }\n\n      const errorMessage = `Failed to retrieve signing key`;\n      this.loggerService.logWarning(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve signing key with error: ${err}`;\n      this.loggerService.logWarning(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleResultErrorFromCallback(result, isRenewProcess) {\n    let validationResult = ValidationResult.SecureTokenServerError;\n\n    if (result.error === 'login_required') {\n      validationResult = ValidationResult.LoginRequired;\n    }\n\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult,\n      isRenewProcess\n    });\n  }\n\n  historyCleanUpTurnedOn(config) {\n    const {\n      historyCleanupOff\n    } = config;\n    return !historyCleanupOff;\n  }\n\n  resetBrowserHistory() {\n    this.document.defaultView.history.replaceState({}, this.document.defaultView.title, this.document.defaultView.location.origin + this.document.defaultView.location.pathname);\n  }\n\n  storeSigningKeys(jwtKeys, config) {\n    this.storagePersistenceService.write(JWT_KEYS, jwtKeys, config);\n  }\n\n  readSigningKeys(config) {\n    return this.storagePersistenceService.read(JWT_KEYS, config);\n  }\n\n}\n\nHistoryJwtKeysCallbackHandlerService.ɵfac = function HistoryJwtKeysCallbackHandlerService_Factory(t) {\n  return new (t || HistoryJwtKeysCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(SigninKeyDataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nHistoryJwtKeysCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: HistoryJwtKeysCallbackHandlerService,\n  factory: HistoryJwtKeysCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(HistoryJwtKeysCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: SigninKeyDataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass UserCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService, userService, resetAuthDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.userService = userService;\n    this.resetAuthDataService = resetAuthDataService;\n  } // STEP 5 userData\n\n\n  callbackUser(callbackContext, configuration, allConfigs) {\n    const {\n      isRenewProcess,\n      validationResult,\n      authResult,\n      refreshToken\n    } = callbackContext;\n    const {\n      autoUserInfo,\n      renewUserInfoAfterTokenRenew\n    } = configuration;\n\n    if (!autoUserInfo) {\n      if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\n        // userData is set to the id_token decoded, auto get user data set to false\n        if (validationResult.decodedIdToken) {\n          this.userService.setUserDataToStore(validationResult.decodedIdToken, configuration, allConfigs);\n        }\n      }\n\n      if (!isRenewProcess && !refreshToken) {\n        this.flowsDataService.setSessionState(authResult.session_state, configuration);\n      }\n\n      this.publishAuthState(validationResult, isRenewProcess);\n      return of(callbackContext);\n    }\n\n    return this.userService.getAndPersistUserDataInStore(configuration, allConfigs, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken).pipe(switchMap(userData => {\n      if (!!userData) {\n        if (!refreshToken) {\n          this.flowsDataService.setSessionState(authResult.session_state, configuration);\n        }\n\n        this.publishAuthState(validationResult, isRenewProcess);\n        return of(callbackContext);\n      } else {\n        this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\n        this.publishUnauthenticatedState(validationResult, isRenewProcess);\n        const errorMessage = `Called for userData but they were ${userData}`;\n        this.loggerService.logWarning(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n    }), catchError(err => {\n      const errorMessage = `Failed to retrieve user info with error:  ${err}`;\n      this.loggerService.logWarning(configuration, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  publishAuthState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: true,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n  publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nUserCallbackHandlerService.ɵfac = function UserCallbackHandlerService_Factory(t) {\n  return new (t || UserCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(UserService), i0.ɵɵinject(ResetAuthDataService));\n};\n\nUserCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UserCallbackHandlerService,\n  factory: UserCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UserCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: UserService\n    }, {\n      type: ResetAuthDataService\n    }];\n  }, null);\n})();\n\nclass StateValidationResult {\n  constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\n    at_hash: ''\n  }, state = ValidationResult.NotSet) {\n    this.accessToken = accessToken;\n    this.idToken = idToken;\n    this.authResponseIsValid = authResponseIsValid;\n    this.decodedIdToken = decodedIdToken;\n    this.state = state;\n  }\n\n}\n\nclass EqualityService {\n  isStringEqualOrNonOrderedArrayEqual(value1, value2) {\n    if (this.isNullOrUndefined(value1)) {\n      return false;\n    }\n\n    if (this.isNullOrUndefined(value2)) {\n      return false;\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      return false;\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    return this.arraysHaveEqualContent(value1, value2);\n  }\n\n  areEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n\n    if (this.bothValuesAreArrays(value1, value2)) {\n      return this.arraysStrictEqual(value1, value2);\n    }\n\n    if (this.bothValuesAreStrings(value1, value2)) {\n      return value1 === value2;\n    }\n\n    if (this.bothValuesAreObjects(value1, value2)) {\n      return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n    }\n\n    if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n      if (Array.isArray(value1) && this.valueIsString(value2)) {\n        return value1[0] === value2;\n      }\n\n      if (Array.isArray(value2) && this.valueIsString(value1)) {\n        return value2[0] === value1;\n      }\n    }\n\n    return value1 === value2;\n  }\n\n  oneValueIsStringAndTheOtherIsArray(value1, value2) {\n    return Array.isArray(value1) && this.valueIsString(value2) || Array.isArray(value2) && this.valueIsString(value1);\n  }\n\n  bothValuesAreObjects(value1, value2) {\n    return this.valueIsObject(value1) && this.valueIsObject(value2);\n  }\n\n  bothValuesAreStrings(value1, value2) {\n    return this.valueIsString(value1) && this.valueIsString(value2);\n  }\n\n  bothValuesAreArrays(value1, value2) {\n    return Array.isArray(value1) && Array.isArray(value2);\n  }\n\n  valueIsString(value) {\n    return typeof value === 'string' || value instanceof String;\n  }\n\n  valueIsObject(value) {\n    return typeof value === 'object';\n  }\n\n  arraysStrictEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    for (let i = arr1.length; i--;) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  arraysHaveEqualContent(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    return arr1.some(v => arr2.includes(v));\n  }\n\n  isNullOrUndefined(val) {\n    return val === null || val === undefined;\n  }\n\n}\n\nEqualityService.ɵfac = function EqualityService_Factory(t) {\n  return new (t || EqualityService)();\n};\n\nEqualityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: EqualityService,\n  factory: EqualityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(EqualityService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass StateValidationService {\n  constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, equalityService, flowHelper) {\n    this.storagePersistenceService = storagePersistenceService;\n    this.tokenValidationService = tokenValidationService;\n    this.tokenHelperService = tokenHelperService;\n    this.loggerService = loggerService;\n    this.equalityService = equalityService;\n    this.flowHelper = flowHelper;\n  }\n\n  getValidatedStateResult(callbackContext, configuration) {\n    if (!callbackContext || callbackContext.authResult.error) {\n      return of(new StateValidationResult('', '', false, {}));\n    }\n\n    return this.validateState(callbackContext, configuration);\n  }\n\n  validateState(callbackContext, configuration) {\n    const toReturn = new StateValidationResult();\n    const authStateControl = this.storagePersistenceService.read('authStateControl', configuration);\n\n    if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configuration)) {\n      this.loggerService.logWarning(configuration, 'authCallback incorrect state');\n      toReturn.state = ValidationResult.StatesDoNotMatch;\n      this.handleUnsuccessfulValidation(configuration);\n      return of(toReturn);\n    }\n\n    const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configuration);\n    const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configuration);\n\n    if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\n      toReturn.accessToken = callbackContext.authResult.access_token;\n    }\n\n    if (callbackContext.authResult.id_token) {\n      const {\n        clientId,\n        issValidationOff,\n        maxIdTokenIatOffsetAllowedInSeconds,\n        disableIatOffsetValidation,\n        ignoreNonceAfterRefresh,\n        disableIdTokenValidation\n      } = configuration;\n      toReturn.idToken = callbackContext.authResult.id_token;\n      toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configuration);\n      return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configuration).pipe(mergeMap(isSignatureIdTokenValid => {\n        if (!isSignatureIdTokenValid) {\n          this.loggerService.logDebug(configuration, 'authCallback Signature validation failed id_token');\n          toReturn.state = ValidationResult.SignatureFailed;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        const authNonce = this.storagePersistenceService.read('authNonce', configuration);\n\n        if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\n          toReturn.state = ValidationResult.IncorrectNonce;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configuration)) {\n          this.loggerService.logDebug(configuration, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\n          toReturn.state = ValidationResult.RequiredPropertyMissing;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\n          toReturn.state = ValidationResult.MaxOffsetExpired;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n        if (authWellKnownEndPoints) {\n          if (issValidationOff) {\n            this.loggerService.logDebug(configuration, 'iss validation is turned off, this is not recommended!');\n          } else if (!issValidationOff && !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configuration)) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\n            toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n            this.handleUnsuccessfulValidation(configuration);\n            return of(toReturn);\n          }\n        } else {\n          this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\n          toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback incorrect aud');\n          toReturn.state = ValidationResult.IncorrectAud;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\n          this.loggerService.logWarning(configuration, 'authCallback missing azp');\n          toReturn.state = ValidationResult.IncorrectAzp;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\n          this.loggerService.logWarning(configuration, 'authCallback incorrect azp');\n          toReturn.state = ValidationResult.IncorrectAzp;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configuration)) {\n          this.loggerService.logWarning(configuration, 'authCallback pre, post id_token claims do not match in refresh');\n          toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configuration, maxIdTokenIatOffsetAllowedInSeconds, disableIdTokenValidation)) {\n          this.loggerService.logWarning(configuration, 'authCallback id token expired');\n          toReturn.state = ValidationResult.TokenExpired;\n          this.handleUnsuccessfulValidation(configuration);\n          return of(toReturn);\n        }\n\n        return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\n      }));\n    } else {\n      this.loggerService.logDebug(configuration, 'No id_token found, skipping id_token validation');\n    }\n\n    return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\n  }\n\n  validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext) {\n    // flow id_token\n    if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\n      toReturn.authResponseIsValid = true;\n      toReturn.state = ValidationResult.Ok;\n      this.handleSuccessfulValidation(configuration);\n      this.handleUnsuccessfulValidation(configuration);\n      return of(toReturn);\n    } // only do check if id_token returned, no always the case when using refresh tokens\n\n\n    if (callbackContext.authResult.id_token) {\n      const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configuration);\n\n      if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\n        this.loggerService.logDebug(configuration, 'Code Flow active, and no at_hash in the id_token, skipping check!');\n      } else {\n        return this.tokenValidationService.validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\n        configuration).pipe(map(valid => {\n          if (!valid || !toReturn.accessToken) {\n            this.loggerService.logWarning(configuration, 'authCallback incorrect at_hash');\n            toReturn.state = ValidationResult.IncorrectAtHash;\n            this.handleUnsuccessfulValidation(configuration);\n            return toReturn;\n          } else {\n            toReturn.authResponseIsValid = true;\n            toReturn.state = ValidationResult.Ok;\n            this.handleSuccessfulValidation(configuration);\n            return toReturn;\n          }\n        }));\n      }\n    }\n\n    toReturn.authResponseIsValid = true;\n    toReturn.state = ValidationResult.Ok;\n    this.handleSuccessfulValidation(configuration);\n    return of(toReturn);\n  }\n\n  isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configuration) {\n    const {\n      useRefreshToken,\n      disableRefreshIdTokenAuthTimeValidation\n    } = configuration;\n\n    if (!useRefreshToken) {\n      return true;\n    }\n\n    if (!callbackContext.existingIdToken) {\n      return true;\n    }\n\n    const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configuration); // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\n    // except that it might not contain an id_token.\n    // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\n    // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n    if (decodedIdToken.iss !== newIdToken.iss) {\n      this.loggerService.logDebug(configuration, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\n      return false;\n    } // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\n    //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\n    // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\n\n\n    if (decodedIdToken.azp !== newIdToken.azp) {\n      this.loggerService.logDebug(configuration, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\n      return false;\n    } // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (decodedIdToken.sub !== newIdToken.sub) {\n      this.loggerService.logDebug(configuration, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\n      return false;\n    } // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\n\n\n    if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken?.aud, newIdToken?.aud)) {\n      this.loggerService.logDebug(configuration, `aud in new id_token is not valid: '${decodedIdToken?.aud}' '${newIdToken.aud}'`);\n      return false;\n    }\n\n    if (disableRefreshIdTokenAuthTimeValidation) {\n      return true;\n    } // its iat Claim MUST represent the time that the new ID Token is issued,\n    // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\n    // - not the time that the new ID token is issued,\n\n\n    if (decodedIdToken.auth_time !== newIdToken.auth_time) {\n      this.loggerService.logDebug(configuration, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  handleSuccessfulValidation(configuration) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = configuration;\n    this.storagePersistenceService.write('authNonce', null, configuration);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configuration);\n    }\n\n    this.loggerService.logDebug(configuration, 'authCallback token(s) validated, continue');\n  }\n\n  handleUnsuccessfulValidation(configuration) {\n    const {\n      autoCleanStateAfterAuthentication\n    } = configuration;\n    this.storagePersistenceService.write('authNonce', null, configuration);\n\n    if (autoCleanStateAfterAuthentication) {\n      this.storagePersistenceService.write('authStateControl', '', configuration);\n    }\n\n    this.loggerService.logDebug(configuration, 'authCallback token(s) invalid');\n  }\n\n}\n\nStateValidationService.ɵfac = function StateValidationService_Factory(t) {\n  return new (t || StateValidationService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(TokenValidationService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(EqualityService), i0.ɵɵinject(FlowHelper));\n};\n\nStateValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationService,\n  factory: StateValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: TokenValidationService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: LoggerService\n    }, {\n      type: EqualityService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass StateValidationCallbackHandlerService {\n  constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\n    this.loggerService = loggerService;\n    this.stateValidationService = stateValidationService;\n    this.authStateService = authStateService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.doc = doc;\n  } // STEP 4 All flows\n\n\n  callbackStateValidation(callbackContext, configuration, allConfigs) {\n    return this.stateValidationService.getValidatedStateResult(callbackContext, configuration).pipe(map(validationResult => {\n      callbackContext.validationResult = validationResult;\n\n      if (validationResult.authResponseIsValid) {\n        this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configuration, allConfigs);\n        return callbackContext;\n      } else {\n        const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\n        this.loggerService.logWarning(configuration, errorMessage);\n        this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\n        this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\n        throw new Error(errorMessage);\n      }\n    }));\n  }\n\n  publishUnauthorizedState(stateValidationResult, isRenewProcess) {\n    this.authStateService.updateAndPublishAuthState({\n      isAuthenticated: false,\n      validationResult: stateValidationResult.state,\n      isRenewProcess\n    });\n  }\n\n}\n\nStateValidationCallbackHandlerService.ɵfac = function StateValidationCallbackHandlerService_Factory(t) {\n  return new (t || StateValidationCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(StateValidationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(DOCUMENT));\n};\n\nStateValidationCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateValidationCallbackHandlerService,\n  factory: StateValidationCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateValidationCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: StateValidationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass RefreshSessionCallbackHandlerService {\n  constructor(loggerService, authStateService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n  } // STEP 1 Refresh session\n\n\n  refreshSessionWithRefreshTokens(config) {\n    const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\n    this.loggerService.logDebug(config, 'RefreshSession created. Adding myautostate: ' + stateData);\n    const refreshToken = this.authStateService.getRefreshToken(config);\n    const idToken = this.authStateService.getIdToken(config);\n\n    if (refreshToken) {\n      const callbackContext = {\n        code: null,\n        refreshToken,\n        state: stateData,\n        sessionState: null,\n        authResult: null,\n        isRenewProcess: true,\n        jwtKeys: null,\n        validationResult: null,\n        existingIdToken: idToken\n      };\n      this.loggerService.logDebug(config, 'found refresh code, obtaining new credentials with refresh code'); // Nonce is not used with refresh tokens; but Key cloak may send it anyway\n\n      this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, config);\n      return of(callbackContext);\n    } else {\n      const errorMessage = 'no refresh token found, please login';\n      this.loggerService.logError(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n  }\n\n}\n\nRefreshSessionCallbackHandlerService.ɵfac = function RefreshSessionCallbackHandlerService_Factory(t) {\n  return new (t || RefreshSessionCallbackHandlerService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService));\n};\n\nRefreshSessionCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionCallbackHandlerService,\n  factory: RefreshSessionCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass RefreshTokenCallbackHandlerService {\n  constructor(urlService, loggerService, dataService, storagePersistenceService) {\n    this.urlService = urlService;\n    this.loggerService = loggerService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  } // STEP 2 Refresh Token\n\n\n  refreshTokensRequestTokens(callbackContext, config, customParamsRefresh) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n    const tokenEndpoint = authWellknownEndpoints?.tokenEndpoint;\n\n    if (!tokenEndpoint) {\n      return throwError(() => new Error('Token Endpoint not defined'));\n    }\n\n    const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, config, customParamsRefresh);\n    return this.dataService.post(tokenEndpoint, data, config, headers).pipe(switchMap(response => {\n      this.loggerService.logDebug(config, 'token refresh response: ', response); // TODO FGO LOOK AT THIS\n\n      let authResult = new Object();\n      authResult = response;\n      authResult.state = callbackContext.state;\n      callbackContext.authResult = authResult;\n      return of(callbackContext);\n    }), retryWhen(error => this.handleRefreshRetry(error, config)), catchError(error => {\n      const {\n        authority\n      } = config;\n      const errorMessage = `OidcService code request ${authority}`;\n      this.loggerService.logError(config, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n  handleRefreshRetry(errors, config) {\n    return errors.pipe(mergeMap(error => {\n      // retry token refresh if there is no internet connection\n      if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\n        const {\n          authority,\n          refreshTokenRetryInSeconds\n        } = config;\n        const errorMessage = `OidcService code request ${authority} - no internet connection`;\n        this.loggerService.logWarning(config, errorMessage, error);\n        return timer(refreshTokenRetryInSeconds * 1000);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nRefreshTokenCallbackHandlerService.ɵfac = function RefreshTokenCallbackHandlerService_Factory(t) {\n  return new (t || RefreshTokenCallbackHandlerService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nRefreshTokenCallbackHandlerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshTokenCallbackHandlerService,\n  factory: RefreshTokenCallbackHandlerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshTokenCallbackHandlerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: LoggerService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass FlowsService {\n  constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\n    this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\n    this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\n    this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\n    this.userHandlerService = userHandlerService;\n    this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\n    this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\n    this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\n  }\n\n  processCodeFlowCallback(urlToCheck, config, allConfigs) {\n    return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, config).pipe(concatMap(callbackContext => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, config)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n  processSilentRenewCodeFlowCallback(firstContext, config, allConfigs) {\n    return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, config).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n  processImplicitFlowCallback(config, allConfigs, hash) {\n    return this.implicitFlowCallbackHandlerService.implicitFlowCallback(config, allConfigs, hash).pipe(concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n  processRefreshToken(config, allConfigs, customParamsRefresh) {\n    return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(config).pipe(concatMap(callbackContext => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, config, customParamsRefresh)), concatMap(callbackContext => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap(callbackContext => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap(callbackContext => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\n  }\n\n}\n\nFlowsService.ɵfac = function FlowsService_Factory(t) {\n  return new (t || FlowsService)(i0.ɵɵinject(CodeFlowCallbackHandlerService), i0.ɵɵinject(ImplicitFlowCallbackHandlerService), i0.ɵɵinject(HistoryJwtKeysCallbackHandlerService), i0.ɵɵinject(UserCallbackHandlerService), i0.ɵɵinject(StateValidationCallbackHandlerService), i0.ɵɵinject(RefreshSessionCallbackHandlerService), i0.ɵɵinject(RefreshTokenCallbackHandlerService));\n};\n\nFlowsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: FlowsService,\n  factory: FlowsService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(FlowsService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CodeFlowCallbackHandlerService\n    }, {\n      type: ImplicitFlowCallbackHandlerService\n    }, {\n      type: HistoryJwtKeysCallbackHandlerService\n    }, {\n      type: UserCallbackHandlerService\n    }, {\n      type: StateValidationCallbackHandlerService\n    }, {\n      type: RefreshSessionCallbackHandlerService\n    }, {\n      type: RefreshTokenCallbackHandlerService\n    }];\n  }, null);\n})();\n\nclass IntervalService {\n  constructor(zone) {\n    this.zone = zone;\n    this.runTokenValidationRunning = null;\n  }\n\n  isTokenValidationRunning() {\n    return !!this.runTokenValidationRunning;\n  }\n\n  stopPeriodicTokenCheck() {\n    if (this.runTokenValidationRunning) {\n      this.runTokenValidationRunning.unsubscribe();\n      this.runTokenValidationRunning = null;\n    }\n  }\n\n  startPeriodicTokenCheck(repeatAfterSeconds) {\n    const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\n    return new Observable(subscriber => {\n      let intervalId;\n      this.zone.runOutsideAngular(() => {\n        intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\n      });\n      return () => {\n        clearInterval(intervalId);\n      };\n    });\n  }\n\n}\n\nIntervalService.ɵfac = function IntervalService_Factory(t) {\n  return new (t || IntervalService)(i0.ɵɵinject(i0.NgZone));\n};\n\nIntervalService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: IntervalService,\n  factory: IntervalService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IntervalService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass ImplicitFlowCallbackService {\n  constructor(flowsService, router, flowsDataService, intervalService) {\n    this.flowsService = flowsService;\n    this.router = router;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n  }\n\n  authenticatedImplicitFlowCallback(config, allConfigs, hash) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = config;\n    return this.flowsService.processImplicitFlowCallback(config, allConfigs, hash).pipe(tap(callbackContext => {\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(config);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nImplicitFlowCallbackService.ɵfac = function ImplicitFlowCallbackService_Factory(t) {\n  return new (t || ImplicitFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(i2.Router), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService));\n};\n\nImplicitFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ImplicitFlowCallbackService,\n  factory: ImplicitFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ImplicitFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: i2.Router\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\n\nclass SilentRenewService {\n  constructor(iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\n    this.iFrameService = iFrameService;\n    this.flowsService = flowsService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsDataService = flowsDataService;\n    this.authStateService = authStateService;\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.intervalService = intervalService;\n    this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\n  }\n\n  get refreshSessionWithIFrameCompleted$() {\n    return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\n  }\n\n  getOrCreateIframe(config) {\n    const existingIframe = this.getExistingIframe();\n\n    if (!existingIframe) {\n      return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, config);\n    }\n\n    return existingIframe;\n  }\n\n  isSilentRenewConfigured(configuration) {\n    const {\n      useRefreshToken,\n      silentRenew\n    } = configuration;\n    return !useRefreshToken && silentRenew;\n  }\n\n  codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs) {\n    const params = new HttpParams({\n      fromString: urlParts[1]\n    });\n    const error = params.get('error');\n\n    if (error) {\n      this.authStateService.updateAndPublishAuthState({\n        isAuthenticated: false,\n        validationResult: ValidationResult.LoginRequired,\n        isRenewProcess: true\n      });\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      this.flowsDataService.setNonce('', config);\n      this.intervalService.stopPeriodicTokenCheck();\n      return throwError(() => new Error(error));\n    }\n\n    const code = params.get('code');\n    const state = params.get('state');\n    const sessionState = params.get('session_state');\n    const callbackContext = {\n      code,\n      refreshToken: null,\n      state,\n      sessionState,\n      authResult: null,\n      isRenewProcess: true,\n      jwtKeys: null,\n      validationResult: null,\n      existingIdToken: null\n    };\n    return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, config, allConfigs).pipe(catchError(() => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n  silentRenewEventHandler(e, config, allConfigs) {\n    this.loggerService.logDebug(config, 'silentRenewEventHandler');\n\n    if (!e.detail) {\n      return;\n    }\n\n    let callback$ = of(null);\n    const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(config);\n\n    if (isCodeFlow) {\n      const urlParts = e.detail.toString().split('?');\n      callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs);\n    } else {\n      callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, e.detail);\n    }\n\n    callback$.subscribe({\n      next: callbackContext => {\n        this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\n        this.flowsDataService.resetSilentRenewRunning(config);\n      },\n      error: err => {\n        this.loggerService.logError(config, 'Error: ' + err);\n        this.refreshSessionWithIFrameCompletedInternal$.next(null);\n        this.flowsDataService.resetSilentRenewRunning(config);\n      }\n    });\n  }\n\n  getExistingIframe() {\n    return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n  }\n\n}\n\nSilentRenewService.ɵfac = function SilentRenewService_Factory(t) {\n  return new (t || SilentRenewService)(i0.ɵɵinject(IFrameService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(IntervalService));\n};\n\nSilentRenewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SilentRenewService,\n  factory: SilentRenewService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SilentRenewService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: IFrameService\n    }, {\n      type: FlowsService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nclass CodeFlowCallbackService {\n  constructor(flowsService, flowsDataService, intervalService, router) {\n    this.flowsService = flowsService;\n    this.flowsDataService = flowsDataService;\n    this.intervalService = intervalService;\n    this.router = router;\n  }\n\n  authenticatedCallbackWithCode(urlToCheck, config, allConfigs) {\n    const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\n    const {\n      triggerAuthorizationResultEvent,\n      postLoginRoute,\n      unauthorizedRoute\n    } = config;\n    return this.flowsService.processCodeFlowCallback(urlToCheck, config, allConfigs).pipe(tap(callbackContext => {\n      this.flowsDataService.resetCodeFlowInProgress(config);\n\n      if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\n        this.router.navigateByUrl(postLoginRoute);\n      }\n    }), catchError(error => {\n      this.flowsDataService.resetSilentRenewRunning(config);\n      this.flowsDataService.resetCodeFlowInProgress(config);\n      this.intervalService.stopPeriodicTokenCheck();\n\n      if (!triggerAuthorizationResultEvent && !isRenewProcess) {\n        this.router.navigateByUrl(unauthorizedRoute);\n      }\n\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nCodeFlowCallbackService.ɵfac = function CodeFlowCallbackService_Factory(t) {\n  return new (t || CodeFlowCallbackService)(i0.ɵɵinject(FlowsService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(i2.Router));\n};\n\nCodeFlowCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CodeFlowCallbackService,\n  factory: CodeFlowCallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CodeFlowCallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowsService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: IntervalService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CallbackService {\n  constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\n    this.urlService = urlService;\n    this.flowHelper = flowHelper;\n    this.implicitFlowCallbackService = implicitFlowCallbackService;\n    this.codeFlowCallbackService = codeFlowCallbackService;\n    this.stsCallbackInternal$ = new Subject();\n  }\n\n  get stsCallback$() {\n    return this.stsCallbackInternal$.asObservable();\n  }\n\n  isCallback(currentUrl) {\n    return this.urlService.isCallbackFromSts(currentUrl);\n  }\n\n  handleCallbackAndFireEvents(currentCallbackUrl, config, allConfigs) {\n    let callback$;\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\n      callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, config, allConfigs);\n    } else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(config)) {\n      if (currentCallbackUrl?.includes('#')) {\n        let hash = currentCallbackUrl.substring(currentCallbackUrl.indexOf('#') + 1);\n        callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, hash);\n      } else {\n        callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs);\n      }\n    }\n\n    return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\n  }\n\n}\n\nCallbackService.ɵfac = function CallbackService_Factory(t) {\n  return new (t || CallbackService)(i0.ɵɵinject(UrlService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(ImplicitFlowCallbackService), i0.ɵɵinject(CodeFlowCallbackService));\n};\n\nCallbackService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CallbackService,\n  factory: CallbackService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CallbackService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: UrlService\n    }, {\n      type: FlowHelper\n    }, {\n      type: ImplicitFlowCallbackService\n    }, {\n      type: CodeFlowCallbackService\n    }];\n  }, null);\n})();\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\n\nclass AuthWellKnownDataService {\n  constructor(http, loggerService) {\n    this.http = http;\n    this.loggerService = loggerService;\n  }\n\n  getWellKnownEndPointsForConfig(config) {\n    const {\n      authWellknownEndpointUrl\n    } = config;\n\n    if (!authWellknownEndpointUrl) {\n      const errorMessage = 'no authWellknownEndpoint given!';\n      this.loggerService.logError(config, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    return this.getWellKnownDocument(authWellknownEndpointUrl, config).pipe(map(wellKnownEndpoints => ({\n      issuer: wellKnownEndpoints.issuer,\n      jwksUri: wellKnownEndpoints.jwks_uri,\n      authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\n      tokenEndpoint: wellKnownEndpoints.token_endpoint,\n      userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\n      endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\n      checkSessionIframe: wellKnownEndpoints.check_session_iframe,\n      revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\n      introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\n      parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint\n    })));\n  }\n\n  getWellKnownDocument(wellKnownEndpoint, config) {\n    let url = wellKnownEndpoint;\n\n    if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\n      url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\n    }\n\n    return this.http.get(url, config).pipe(retry(2));\n  }\n\n}\n\nAuthWellKnownDataService.ɵfac = function AuthWellKnownDataService_Factory(t) {\n  return new (t || AuthWellKnownDataService)(i0.ɵɵinject(DataService), i0.ɵɵinject(LoggerService));\n};\n\nAuthWellKnownDataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownDataService,\n  factory: AuthWellKnownDataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownDataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass AuthWellKnownService {\n  constructor(dataService, publicEventsService, storagePersistenceService) {\n    this.dataService = dataService;\n    this.publicEventsService = publicEventsService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  storeWellKnownEndpoints(config, mappedWellKnownEndpoints) {\n    this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, config);\n  }\n\n  queryAndStoreAuthWellKnownEndPoints(config) {\n    const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\n\n    if (!!alreadySavedWellKnownEndpoints) {\n      return of(alreadySavedWellKnownEndpoints);\n    }\n\n    return this.dataService.getWellKnownEndPointsForConfig(config).pipe(tap(mappedWellKnownEndpoints => this.storeWellKnownEndpoints(config, mappedWellKnownEndpoints)), catchError(error => {\n      this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nAuthWellKnownService.ɵfac = function AuthWellKnownService_Factory(t) {\n  return new (t || AuthWellKnownService)(i0.ɵɵinject(AuthWellKnownDataService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nAuthWellKnownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthWellKnownService,\n  factory: AuthWellKnownService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthWellKnownService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthWellKnownDataService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass RefreshSessionIframeService {\n  constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\n    this.doc = doc;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.silentRenewService = silentRenewService;\n    this.renderer = rendererFactory.createRenderer(null, null);\n  }\n\n  refreshSessionWithIframe(config, allConfigs, customParams) {\n    this.loggerService.logDebug(config, 'BEGIN refresh session Authorize Iframe renew');\n    return this.urlService.getRefreshSessionSilentRenewUrl(config, customParams).pipe(switchMap(url => {\n      return this.sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs);\n    }));\n  }\n\n  sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs) {\n    const sessionIframe = this.silentRenewService.getOrCreateIframe(config);\n    this.initSilentRenewRequest(config, allConfigs);\n    this.loggerService.logDebug(config, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\n    return new Observable(observer => {\n      const onLoadHandler = () => {\n        sessionIframe.removeEventListener('load', onLoadHandler);\n        this.loggerService.logDebug(config, 'removed event listener from IFrame');\n        observer.next(true);\n        observer.complete();\n      };\n\n      sessionIframe.addEventListener('load', onLoadHandler);\n      sessionIframe.contentWindow.location.replace(url);\n    });\n  }\n\n  initSilentRenewRequest(config, allConfigs) {\n    const instanceId = Math.random();\n    const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', e => {\n      if (e.detail !== instanceId) {\n        initDestroyHandler();\n        renewDestroyHandler();\n      }\n    });\n    const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', e => this.silentRenewService.silentRenewEventHandler(e, config, allConfigs));\n    this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\n      detail: instanceId\n    }));\n  }\n\n}\n\nRefreshSessionIframeService.ɵfac = function RefreshSessionIframeService_Factory(t) {\n  return new (t || RefreshSessionIframeService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(i0.RendererFactory2));\n};\n\nRefreshSessionIframeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionIframeService,\n  factory: RefreshSessionIframeService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionIframeService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: i0.RendererFactory2\n    }];\n  }, null);\n})();\n\nclass RefreshSessionRefreshTokenService {\n  constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\n    this.loggerService = loggerService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowsService = flowsService;\n    this.intervalService = intervalService;\n  }\n\n  refreshSessionWithRefreshTokens(config, allConfigs, customParamsRefresh) {\n    this.loggerService.logDebug(config, 'BEGIN refresh session Authorize');\n    return this.flowsService.processRefreshToken(config, allConfigs, customParamsRefresh).pipe(catchError(error => {\n      this.intervalService.stopPeriodicTokenCheck();\n      this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n      return throwError(() => new Error(error));\n    }));\n  }\n\n}\n\nRefreshSessionRefreshTokenService.ɵfac = function RefreshSessionRefreshTokenService_Factory(t) {\n  return new (t || RefreshSessionRefreshTokenService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowsService), i0.ɵɵinject(IntervalService));\n};\n\nRefreshSessionRefreshTokenService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionRefreshTokenService,\n  factory: RefreshSessionRefreshTokenService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionRefreshTokenService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: FlowsService\n    }, {\n      type: IntervalService\n    }];\n  }, null);\n})();\n\nconst MAX_RETRY_ATTEMPTS = 3;\n\nclass RefreshSessionService {\n  constructor(flowHelper, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\n    this.flowHelper = flowHelper;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.silentRenewService = silentRenewService;\n    this.authStateService = authStateService;\n    this.authWellKnownService = authWellKnownService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.userService = userService;\n  }\n\n  userForceRefreshSession(config, allConfigs, extraCustomParams) {\n    this.persistCustomParams(extraCustomParams, config);\n    return this.forceRefreshSession(config, allConfigs, extraCustomParams);\n  }\n\n  forceRefreshSession(config, allConfigs, extraCustomParams) {\n    const {\n      customParamsRefreshTokenRequest,\n      configId\n    } = config;\n    const mergedParams = { ...customParamsRefreshTokenRequest,\n      ...extraCustomParams\n    };\n\n    if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n      return this.startRefreshSession(config, allConfigs, mergedParams).pipe(map(() => {\n        const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n        if (isAuthenticated) {\n          return {\n            idToken: this.authStateService.getIdToken(config),\n            accessToken: this.authStateService.getAccessToken(config),\n            userData: this.userService.getUserDataFromStore(config),\n            isAuthenticated,\n            configId\n          };\n        }\n\n        return null;\n      }));\n    }\n\n    const {\n      silentRenewTimeoutInSeconds\n    } = config;\n    const timeOutTime = silentRenewTimeoutInSeconds * 1000;\n    return forkJoin([this.startRefreshSession(config, allConfigs, extraCustomParams), this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1))]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n      if (isAuthenticated) {\n        return {\n          idToken: callbackContext?.authResult?.id_token,\n          accessToken: callbackContext?.authResult?.access_token,\n          userData: this.userService.getUserDataFromStore(config),\n          isAuthenticated,\n          configId\n        };\n      }\n\n      return null;\n    }));\n  }\n\n  persistCustomParams(extraCustomParams, config) {\n    const {\n      useRefreshToken\n    } = config;\n\n    if (extraCustomParams) {\n      if (useRefreshToken) {\n        this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, config);\n      } else {\n        this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, config);\n      }\n    }\n  }\n\n  startRefreshSession(config, allConfigs, extraCustomParams) {\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\n    this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\n    const shouldBeExecuted = !isSilentRenewRunning;\n\n    if (!shouldBeExecuted) {\n      return of(null);\n    }\n\n    return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config).pipe(switchMap(() => {\n      this.flowsDataService.setSilentRenewRunning(config);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n        // Refresh Session using Refresh tokens\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, extraCustomParams);\n      }\n\n      return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, extraCustomParams);\n    }));\n  }\n\n  timeoutRetryStrategy(errorAttempts, config) {\n    return errorAttempts.pipe(mergeMap((error, index) => {\n      const scalingDuration = 1000;\n      const currentAttempt = index + 1;\n\n      if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\n        return throwError(() => new Error(error));\n      }\n\n      this.loggerService.logDebug(config, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\n      this.flowsDataService.resetSilentRenewRunning(config);\n      return timer(currentAttempt * scalingDuration);\n    }));\n  }\n\n}\n\nRefreshSessionService.ɵfac = function RefreshSessionService_Factory(t) {\n  return new (t || RefreshSessionService)(i0.ɵɵinject(FlowHelper), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(UserService));\n};\n\nRefreshSessionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RefreshSessionService,\n  factory: RefreshSessionService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RefreshSessionService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: FlowHelper\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: AuthStateService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: UserService\n    }];\n  }, null);\n})();\n\nconst DEFAULT_CONFIG = {\n  authority: 'https://please_set',\n  authWellknownEndpointUrl: '',\n  authWellknownEndpoints: null,\n  redirectUrl: 'https://please_set',\n  clientId: 'please_set',\n  responseType: 'code',\n  scope: 'openid email profile',\n  hdParam: '',\n  postLogoutRedirectUri: 'https://please_set',\n  startCheckSession: false,\n  silentRenew: false,\n  silentRenewUrl: 'https://please_set',\n  silentRenewTimeoutInSeconds: 20,\n  renewTimeBeforeTokenExpiresInSeconds: 0,\n  useRefreshToken: false,\n  usePushedAuthorisationRequests: false,\n  ignoreNonceAfterRefresh: false,\n  postLoginRoute: '/',\n  forbiddenRoute: '/forbidden',\n  unauthorizedRoute: '/unauthorized',\n  autoUserInfo: true,\n  autoCleanStateAfterAuthentication: true,\n  triggerAuthorizationResultEvent: false,\n  logLevel: LogLevel.Warn,\n  issValidationOff: false,\n  historyCleanupOff: false,\n  maxIdTokenIatOffsetAllowedInSeconds: 120,\n  disableIatOffsetValidation: false,\n  customParamsAuthRequest: {},\n  customParamsRefreshTokenRequest: {},\n  customParamsEndSessionRequest: {},\n  customParamsCodeRequest: {},\n  disableRefreshIdTokenAuthTimeValidation: false,\n  enableIdTokenExpiredValidationInRenew: true,\n  tokenRefreshInSeconds: 4,\n  refreshTokenRetryInSeconds: 3,\n  ngswBypass: false\n};\nconst POSITIVE_VALIDATION_RESULT = {\n  result: true,\n  messages: [],\n  level: null\n};\n\nconst ensureAuthority = passedConfig => {\n  if (!passedConfig.authority) {\n    return {\n      result: false,\n      messages: ['The authority URL MUST be provided in the configuration! '],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureClientId = passedConfig => {\n  if (!passedConfig.clientId) {\n    return {\n      result: false,\n      messages: ['The clientId is required and missing from your config!'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst createIdentifierToCheck = passedConfig => {\n  if (!passedConfig) {\n    return null;\n  }\n\n  const {\n    authority,\n    clientId,\n    scope\n  } = passedConfig;\n  return `${authority}${clientId}${scope}`;\n};\n\nconst arrayHasDuplicates = array => new Set(array).size !== array.length;\n\nconst ensureNoDuplicatedConfigsRule = passedConfigs => {\n  const allIdentifiers = passedConfigs.map(x => createIdentifierToCheck(x));\n  const someAreNull = allIdentifiers.some(x => x === null);\n\n  if (someAreNull) {\n    return {\n      result: false,\n      messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\n      level: 'error'\n    };\n  }\n\n  const hasDuplicates = arrayHasDuplicates(allIdentifiers);\n\n  if (hasDuplicates) {\n    return {\n      result: false,\n      messages: ['You added multiple configs with the same authority, clientId and scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureRedirectRule = passedConfig => {\n  if (!passedConfig.redirectUrl) {\n    return {\n      result: false,\n      messages: ['The redirectUrl is required and missing from your config'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = passedConfig => {\n  const usesSilentRenew = passedConfig.silentRenew;\n  const usesRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenewUrl = passedConfig.silentRenewUrl;\n\n  if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\n    return {\n      result: false,\n      messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\n      level: 'error'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst useOfflineScopeWithSilentRenew = passedConfig => {\n  const hasRefreshToken = passedConfig.useRefreshToken;\n  const hasSilentRenew = passedConfig.silentRenew;\n  const scope = passedConfig.scope || '';\n  const hasOfflineScope = scope.split(' ').includes('offline_access');\n\n  if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\n    return {\n      result: false,\n      messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\n      level: 'warning'\n    };\n  }\n\n  return POSITIVE_VALIDATION_RESULT;\n};\n\nconst allRules = [ensureAuthority, useOfflineScopeWithSilentRenew, ensureRedirectRule, ensureClientId, ensureSilentRenewUrlWhenNoRefreshTokenUsed];\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\n  constructor(loggerService) {\n    this.loggerService = loggerService;\n  }\n\n  validateConfigs(passedConfigs) {\n    return this.validateConfigsInternal(passedConfigs ?? [], allMultipleConfigRules);\n  }\n\n  validateConfig(passedConfig) {\n    return this.validateConfigInternal(passedConfig, allRules);\n  }\n\n  validateConfigsInternal(passedConfigs, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfigs));\n    let overallErrorCount = 0;\n    passedConfigs.forEach(passedConfig => {\n      const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\n      overallErrorCount += errorCount;\n    });\n    return overallErrorCount === 0;\n  }\n\n  validateConfigInternal(passedConfig, allRulesToUse) {\n    const allValidationResults = allRulesToUse.map(rule => rule(passedConfig));\n    const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\n    return errorCount === 0;\n  }\n\n  processValidationResultsAndGetErrorCount(allValidationResults, config) {\n    const allMessages = allValidationResults.filter(x => x.messages.length > 0);\n    const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\n    const allWarnings = this.getAllMessagesOfType('warning', allMessages);\n    allErrorMessages.forEach(message => this.loggerService.logError(config, message));\n    allWarnings.forEach(message => this.loggerService.logWarning(config, message));\n    return allErrorMessages.length;\n  }\n\n  getAllMessagesOfType(type, results) {\n    const allMessages = results.filter(x => x.level === type).map(result => result.messages);\n    return allMessages.reduce((acc, val) => acc.concat(val), []);\n  }\n\n}\n\nConfigValidationService.ɵfac = function ConfigValidationService_Factory(t) {\n  return new (t || ConfigValidationService)(i0.ɵɵinject(LoggerService));\n};\n\nConfigValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigValidationService,\n  factory: ConfigValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }];\n  }, null);\n})();\n\nclass PlatformProvider {\n  constructor(platformId) {\n    this.platformId = platformId;\n  }\n\n  isBrowser() {\n    return isPlatformBrowser(this.platformId);\n  }\n\n}\n\nPlatformProvider.ɵfac = function PlatformProvider_Factory(t) {\n  return new (t || PlatformProvider)(i0.ɵɵinject(PLATFORM_ID));\n};\n\nPlatformProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PlatformProvider,\n  factory: PlatformProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PlatformProvider, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass OpenIdConfigLoader {}\n\nclass StsConfigLoader {}\n\nclass StsConfigStaticLoader {\n  constructor(passedConfigs) {\n    this.passedConfigs = passedConfigs;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.passedConfigs)) {\n      return of(this.passedConfigs);\n    }\n\n    return of([this.passedConfigs]);\n  }\n\n}\n\nclass StsConfigHttpLoader {\n  constructor(configs$) {\n    this.configs$ = configs$;\n  }\n\n  loadConfigs() {\n    if (Array.isArray(this.configs$)) {\n      return forkJoin(this.configs$);\n    }\n\n    const singleConfigOrArray = this.configs$;\n    return singleConfigOrArray.pipe(map(value => {\n      if (Array.isArray(value)) {\n        return value;\n      }\n\n      return [value];\n    }));\n  }\n\n}\n\nclass ConfigurationService {\n  constructor(loggerService, publicEventsService, storagePersistenceService, configValidationService, platformProvider, authWellKnownService, loader) {\n    this.loggerService = loggerService;\n    this.publicEventsService = publicEventsService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.configValidationService = configValidationService;\n    this.platformProvider = platformProvider;\n    this.authWellKnownService = authWellKnownService;\n    this.loader = loader;\n    this.configsInternal = {};\n  }\n\n  hasManyConfigs() {\n    return Object.keys(this.configsInternal).length > 1;\n  }\n\n  getAllConfigurations() {\n    return Object.values(this.configsInternal);\n  }\n\n  getOpenIDConfiguration(configId) {\n    if (this.configsAlreadySaved()) {\n      return of(this.getConfig(configId));\n    }\n\n    return this.getOpenIDConfigurations(configId).pipe(map(result => result.currentConfig));\n  }\n\n  getOpenIDConfigurations(configId) {\n    return this.loadConfigs().pipe(concatMap(allConfigs => this.prepareAndSaveConfigs(allConfigs)), map(allPreparedConfigs => ({\n      allConfigs: allPreparedConfigs,\n      currentConfig: this.getConfig(configId)\n    })));\n  }\n\n  hasAtLeastOneConfig() {\n    return Object.keys(this.configsInternal).length > 0;\n  }\n\n  saveConfig(readyConfig) {\n    const {\n      configId\n    } = readyConfig;\n    this.configsInternal[configId] = readyConfig;\n  }\n\n  loadConfigs() {\n    return this.loader.loadConfigs();\n  }\n\n  configsAlreadySaved() {\n    return this.hasAtLeastOneConfig();\n  }\n\n  getConfig(configId) {\n    if (!!configId) {\n      return this.configsInternal[configId] || null;\n    }\n\n    const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\n    return value || null;\n  }\n\n  prepareAndSaveConfigs(passedConfigs) {\n    if (!this.configValidationService.validateConfigs(passedConfigs)) {\n      return of(null);\n    }\n\n    this.createUniqueIds(passedConfigs);\n    const allHandleConfigs$ = passedConfigs.map(x => this.handleConfig(x));\n    return forkJoin(allHandleConfigs$);\n  }\n\n  createUniqueIds(passedConfigs) {\n    passedConfigs.forEach((config, index) => {\n      if (!config.configId) {\n        config.configId = `${index}-${config.clientId}`;\n      }\n    });\n  }\n\n  handleConfig(passedConfig) {\n    if (!this.configValidationService.validateConfig(passedConfig)) {\n      this.loggerService.logError(passedConfig, 'Validation of config rejected with errors. Config is NOT set.');\n      return of(null);\n    }\n\n    if (!passedConfig.authWellknownEndpointUrl) {\n      passedConfig.authWellknownEndpointUrl = passedConfig.authority;\n    }\n\n    const usedConfig = this.prepareConfig(passedConfig);\n    this.saveConfig(usedConfig);\n    const configWithAuthWellKnown = this.enhanceConfigWithWellKnownEndpoint(usedConfig);\n    this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, configWithAuthWellKnown);\n    return of(usedConfig);\n  }\n\n  enhanceConfigWithWellKnownEndpoint(configuration) {\n    const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!!alreadyExistingAuthWellKnownEndpoints) {\n      configuration.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\n      return configuration;\n    }\n\n    const passedAuthWellKnownEndpoints = configuration.authWellknownEndpoints;\n\n    if (!!passedAuthWellKnownEndpoints) {\n      this.authWellKnownService.storeWellKnownEndpoints(configuration, passedAuthWellKnownEndpoints);\n      configuration.authWellknownEndpoints = passedAuthWellKnownEndpoints;\n      return configuration;\n    }\n\n    return configuration;\n  }\n\n  prepareConfig(configuration) {\n    const openIdConfigurationInternal = { ...DEFAULT_CONFIG,\n      ...configuration\n    };\n    this.setSpecialCases(openIdConfigurationInternal);\n    return openIdConfigurationInternal;\n  }\n\n  setSpecialCases(currentConfig) {\n    if (!this.platformProvider.isBrowser()) {\n      currentConfig.startCheckSession = false;\n      currentConfig.silentRenew = false;\n      currentConfig.useRefreshToken = false;\n      currentConfig.usePushedAuthorisationRequests = false;\n    }\n  }\n\n}\n\nConfigurationService.ɵfac = function ConfigurationService_Factory(t) {\n  return new (t || ConfigurationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(ConfigValidationService), i0.ɵɵinject(PlatformProvider), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(StsConfigLoader));\n};\n\nConfigurationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConfigurationService,\n  factory: ConfigurationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConfigurationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: ConfigValidationService\n    }, {\n      type: PlatformProvider\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: StsConfigLoader\n    }];\n  }, null);\n})();\n\nclass PeriodicallyTokenCheckService {\n  constructor(resetAuthDataService, flowHelper, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService, configurationService) {\n    this.resetAuthDataService = resetAuthDataService;\n    this.flowHelper = flowHelper;\n    this.flowsDataService = flowsDataService;\n    this.loggerService = loggerService;\n    this.userService = userService;\n    this.authStateService = authStateService;\n    this.refreshSessionIframeService = refreshSessionIframeService;\n    this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\n    this.intervalService = intervalService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n    this.configurationService = configurationService;\n  }\n\n  startTokenValidationPeriodically(allConfigs, currentConfig) {\n    const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled(allConfigs);\n\n    if (configsWithSilentRenewEnabled.length <= 0) {\n      return;\n    }\n\n    if (this.intervalService.isTokenValidationRunning()) {\n      return;\n    }\n\n    const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\n    const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\n      const objectWithConfigIdsAndRefreshEvent = {};\n      configsWithSilentRenewEnabled.forEach(config => {\n        objectWithConfigIdsAndRefreshEvent[config.configId] = this.getRefreshEvent(config, allConfigs);\n      });\n      return forkJoin(objectWithConfigIdsAndRefreshEvent);\n    }));\n    this.intervalService.runTokenValidationRunning = periodicallyCheck$.pipe(catchError(error => throwError(() => new Error(error)))).subscribe({\n      next: objectWithConfigIds => {\n        for (const [configId, _] of Object.entries(objectWithConfigIds)) {\n          this.configurationService.getOpenIDConfiguration(configId).subscribe(config => {\n            this.loggerService.logDebug(config, 'silent renew, periodic check finished!');\n\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n              this.flowsDataService.resetSilentRenewRunning(config);\n            }\n          });\n        }\n      },\n      error: error => {\n        this.loggerService.logError(currentConfig, 'silent renew failed!', error);\n      }\n    });\n  }\n\n  getRefreshEvent(config, allConfigs) {\n    const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(config);\n\n    if (!shouldStartRefreshEvent) {\n      return of(null);\n    }\n\n    const refreshEvent$ = this.createRefreshEventForConfig(config, allConfigs);\n    this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\n    const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError(error => {\n      this.loggerService.logError(config, 'silent renew failed!', error);\n      this.flowsDataService.resetSilentRenewRunning(config);\n      return throwError(() => new Error(error));\n    }));\n    return refreshEventWithErrorHandler$;\n  }\n\n  getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\n    const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\n    return result.tokenRefreshInSeconds;\n  }\n\n  getConfigsWithSilentRenewEnabled(allConfigs) {\n    return allConfigs.filter(x => x.silentRenew);\n  }\n\n  createRefreshEventForConfig(configuration, allConfigs) {\n    this.loggerService.logDebug(configuration, 'starting silent renew...');\n    return this.configurationService.getOpenIDConfiguration(configuration.configId).pipe(switchMap(config => {\n      if (!config?.silentRenew) {\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n        return of(null);\n      }\n\n      this.flowsDataService.setSilentRenewRunning(config);\n\n      if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\n        // Retrieve Dynamically Set Custom Params for refresh body\n        const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', config) || {};\n        const {\n          customParamsRefreshTokenRequest\n        } = config;\n        const mergedParams = { ...customParamsRefreshTokenRequest,\n          ...customParamsRefresh\n        }; // Refresh Session using Refresh tokens\n\n        return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, mergedParams);\n      } // Retrieve Dynamically Set Custom Params\n\n\n      const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', config);\n      return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, customParams);\n    }));\n  }\n\n  shouldStartPeriodicallyCheckForConfig(config) {\n    const idToken = this.authStateService.getIdToken(config);\n    const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\n    const isCodeFlowinProgress = this.flowsDataService.isCodeFlowInProgress(config);\n    const userDataFromStore = this.userService.getUserDataFromStore(config);\n    this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}, isCodeFlowInProgress: ${isCodeFlowinProgress} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\n    const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken && !isCodeFlowinProgress;\n\n    if (!shouldBeExecuted) {\n      return false;\n    }\n\n    const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(config);\n    const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(config);\n\n    if (!idTokenStillValid && !accessTokenHasExpired) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nPeriodicallyTokenCheckService.ɵfac = function PeriodicallyTokenCheckService_Factory(t) {\n  return new (t || PeriodicallyTokenCheckService)(i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(FlowHelper), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UserService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(RefreshSessionIframeService), i0.ɵɵinject(RefreshSessionRefreshTokenService), i0.ɵɵinject(IntervalService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService), i0.ɵɵinject(ConfigurationService));\n};\n\nPeriodicallyTokenCheckService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PeriodicallyTokenCheckService,\n  factory: PeriodicallyTokenCheckService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PeriodicallyTokenCheckService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ResetAuthDataService\n    }, {\n      type: FlowHelper\n    }, {\n      type: FlowsDataService\n    }, {\n      type: LoggerService\n    }, {\n      type: UserService\n    }, {\n      type: AuthStateService\n    }, {\n      type: RefreshSessionIframeService\n    }, {\n      type: RefreshSessionRefreshTokenService\n    }, {\n      type: IntervalService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }, {\n      type: ConfigurationService\n    }];\n  }, null);\n})();\n\nclass PopUpService {\n  constructor(document) {\n    this.document = document;\n    this.STORAGE_IDENTIFIER = 'popupauth';\n    this.resultInternal$ = new Subject();\n  }\n\n  get result$() {\n    return this.resultInternal$.asObservable();\n  }\n\n  get windowInternal() {\n    return this.document.defaultView;\n  }\n\n  isCurrentlyInPopup() {\n    if (this.canAccessSessionStorage()) {\n      const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\n      return !!this.windowInternal.opener && this.windowInternal.opener !== this.windowInternal && !!popup;\n    }\n\n    return false;\n  }\n\n  openPopUp(url, popupOptions) {\n    const optionsToPass = this.getOptions(popupOptions);\n    this.popUp = this.windowInternal.open(url, '_blank', optionsToPass);\n    this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\n\n    const listener = event => {\n      if (!event?.data || typeof event.data !== 'string') {\n        this.cleanUp(listener);\n        return;\n      }\n\n      this.resultInternal$.next({\n        userClosed: false,\n        receivedUrl: event.data\n      });\n      this.cleanUp(listener);\n    };\n\n    this.windowInternal.addEventListener('message', listener, false);\n    this.handle = this.windowInternal.setInterval(() => {\n      if (this.popUp.closed) {\n        this.resultInternal$.next({\n          userClosed: true\n        });\n        this.cleanUp(listener);\n      }\n    }, 200);\n  }\n\n  sendMessageToMainWindow(url) {\n    if (this.windowInternal.opener) {\n      const href = this.windowInternal.location.href;\n      this.sendMessage(url, href);\n    }\n  }\n\n  cleanUp(listener) {\n    this.windowInternal.removeEventListener('message', listener, false);\n    this.windowInternal.clearInterval(this.handle);\n\n    if (this.popUp) {\n      this.popUp.sessionStorage?.removeItem(this.STORAGE_IDENTIFIER);\n      this.popUp.close();\n      this.popUp = null;\n    }\n  }\n\n  sendMessage(url, href) {\n    this.windowInternal.opener.postMessage(url, href);\n  }\n\n  getOptions(popupOptions) {\n    const popupDefaultOptions = {\n      width: 500,\n      height: 500,\n      left: 50,\n      top: 50\n    };\n    const options = { ...popupDefaultOptions,\n      ...(popupOptions || {})\n    };\n    const left = this.windowInternal.screenLeft + (this.windowInternal.outerWidth - options.width) / 2;\n    const top = this.windowInternal.screenTop + (this.windowInternal.outerHeight - options.height) / 2;\n    options.left = left;\n    options.top = top;\n    return Object.entries(options).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join(',');\n  }\n\n  canAccessSessionStorage() {\n    return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\n  }\n\n}\n\nPopUpService.ɵfac = function PopUpService_Factory(t) {\n  return new (t || PopUpService)(i0.ɵɵinject(DOCUMENT));\n};\n\nPopUpService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpService,\n  factory: PopUpService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nconst STORAGE_KEY = 'redirect';\n\nclass AutoLoginService {\n  constructor(storageService, router) {\n    this.storageService = storageService;\n    this.router = router;\n  }\n\n  checkSavedRedirectRouteAndNavigate(config) {\n    const savedRouteForRedirect = this.getStoredRedirectRoute(config);\n\n    if (savedRouteForRedirect) {\n      this.deleteStoredRedirectRoute(config);\n      this.router.navigateByUrl(savedRouteForRedirect);\n    }\n  }\n  /**\r\n   * Saves the redirect URL to storage.\r\n   *\r\n   * @param url The redirect URL to save.\r\n   */\n\n\n  saveRedirectRoute(config, url) {\n    this.storageService.write(STORAGE_KEY, url, config);\n  }\n  /**\r\n   * Gets the stored redirect URL from storage.\r\n   */\n\n\n  getStoredRedirectRoute(config) {\n    return this.storageService.read(STORAGE_KEY, config);\n  }\n  /**\r\n   * Removes the redirect URL from storage.\r\n   */\n\n\n  deleteStoredRedirectRoute(config) {\n    this.storageService.remove(STORAGE_KEY, config);\n  }\n\n}\n\nAutoLoginService.ɵfac = function AutoLoginService_Factory(t) {\n  return new (t || AutoLoginService)(i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginService,\n  factory: AutoLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StoragePersistenceService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass CheckAuthService {\n  constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService, publicEventsService) {\n    this.checkSessionService = checkSessionService;\n    this.currentUrlService = currentUrlService;\n    this.silentRenewService = silentRenewService;\n    this.userService = userService;\n    this.loggerService = loggerService;\n    this.authStateService = authStateService;\n    this.callbackService = callbackService;\n    this.refreshSessionService = refreshSessionService;\n    this.periodicallyTokenCheckService = periodicallyTokenCheckService;\n    this.popupService = popupService;\n    this.autoLoginService = autoLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.publicEventsService = publicEventsService;\n  }\n\n  checkAuth(configuration, allConfigs, url) {\n    this.publicEventsService.fireEvent(EventTypes.CheckingAuth);\n\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      configuration = this.getConfigurationWithUrlState([configuration], stateParamFromUrl);\n\n      if (!configuration) {\n        return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n      }\n    }\n\n    return this.checkAuthWithConfig(configuration, allConfigs, url);\n  }\n\n  checkAuthMultiple(allConfigs, url) {\n    if (this.currentUrlService.currentUrlHasStateParam()) {\n      const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\n      const config = this.getConfigurationWithUrlState(allConfigs, stateParamFromUrl);\n\n      if (!config) {\n        return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\n      }\n\n      return this.composeMultipleLoginResults(allConfigs, config, url);\n    }\n\n    const configs = allConfigs;\n    const allChecks$ = configs.map(x => this.checkAuthWithConfig(x, configs, url));\n    return forkJoin(allChecks$);\n  }\n\n  checkAuthIncludingServer(configuration, allConfigs) {\n    return this.checkAuthWithConfig(configuration, allConfigs).pipe(switchMap(loginResponse => {\n      const {\n        isAuthenticated\n      } = loginResponse;\n\n      if (isAuthenticated) {\n        return of(loginResponse);\n      }\n\n      return this.refreshSessionService.forceRefreshSession(configuration, allConfigs).pipe(tap(loginResponseAfterRefreshSession => {\n        if (loginResponseAfterRefreshSession?.isAuthenticated) {\n          this.startCheckSessionAndValidation(configuration, allConfigs);\n        }\n      }));\n    }));\n  }\n\n  checkAuthWithConfig(config, allConfigs, url) {\n    if (!config) {\n      const errorMessage = 'Please provide at least one configuration before setting up the module';\n      this.loggerService.logError(config, errorMessage);\n      return of({\n        isAuthenticated: false,\n        errorMessage,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId: null\n      });\n    }\n\n    const currentUrl = url || this.currentUrlService.getCurrentUrl();\n    const {\n      configId,\n      authority\n    } = config;\n    this.loggerService.logDebug(config, `Working with config '${configId}' using ${authority}`);\n\n    if (this.popupService.isCurrentlyInPopup()) {\n      this.popupService.sendMessageToMainWindow(currentUrl);\n      return of(null);\n    }\n\n    const isCallback = this.callbackService.isCallback(currentUrl);\n    this.loggerService.logDebug(config, 'currentUrl to check auth with: ', currentUrl);\n    const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, config, allConfigs) : of(null);\n    return callback$.pipe(map(() => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\n\n      if (isAuthenticated) {\n        this.startCheckSessionAndValidation(config, allConfigs);\n\n        if (!isCallback) {\n          this.authStateService.setAuthenticatedAndFireEvent(allConfigs);\n          this.userService.publishUserDataIfExists(config, allConfigs);\n        }\n      }\n\n      this.loggerService.logDebug(config, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\n      return {\n        isAuthenticated,\n        userData: this.userService.getUserDataFromStore(config),\n        accessToken: this.authStateService.getAccessToken(config),\n        idToken: this.authStateService.getIdToken(config),\n        configId\n      };\n    }), tap(({\n      isAuthenticated\n    }) => {\n      this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinished);\n\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\n      }\n    }), catchError(({\n      message\n    }) => {\n      this.loggerService.logError(config, message);\n      this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinishedWithError, message);\n      return of({\n        isAuthenticated: false,\n        errorMessage: message,\n        userData: null,\n        idToken: null,\n        accessToken: null,\n        configId\n      });\n    }));\n  }\n\n  startCheckSessionAndValidation(config, allConfigs) {\n    if (this.checkSessionService.isCheckSessionConfigured(config)) {\n      this.checkSessionService.start(config);\n    }\n\n    this.periodicallyTokenCheckService.startTokenValidationPeriodically(allConfigs, config);\n\n    if (this.silentRenewService.isSilentRenewConfigured(config)) {\n      this.silentRenewService.getOrCreateIframe(config);\n    }\n  }\n\n  getConfigurationWithUrlState(configurations, stateFromUrl) {\n    for (const config of configurations) {\n      const storedState = this.storagePersistenceService.read('authStateControl', config);\n\n      if (storedState === stateFromUrl) {\n        return config;\n      }\n    }\n\n    return null;\n  }\n\n  composeMultipleLoginResults(configurations, activeConfig, url) {\n    const allOtherConfigs = configurations.filter(x => x.configId !== activeConfig.configId);\n    const currentConfigResult = this.checkAuthWithConfig(activeConfig, configurations, url);\n    const allOtherConfigResults = allOtherConfigs.map(config => {\n      const {\n        redirectUrl\n      } = config;\n      return this.checkAuthWithConfig(config, configurations, redirectUrl);\n    });\n    return forkJoin([currentConfigResult, ...allOtherConfigResults]);\n  }\n\n}\n\nCheckAuthService.ɵfac = function CheckAuthService_Factory(t) {\n  return new (t || CheckAuthService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CurrentUrlService), i0.ɵɵinject(SilentRenewService), i0.ɵɵinject(UserService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(PeriodicallyTokenCheckService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(PublicEventsService));\n};\n\nCheckAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CheckAuthService,\n  factory: CheckAuthService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CheckAuthService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CurrentUrlService\n    }, {\n      type: SilentRenewService\n    }, {\n      type: UserService\n    }, {\n      type: LoggerService\n    }, {\n      type: AuthStateService\n    }, {\n      type: CallbackService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: PeriodicallyTokenCheckService\n    }, {\n      type: PopUpService\n    }, {\n      type: AutoLoginService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: PublicEventsService\n    }];\n  }, null);\n})();\n\nclass ClosestMatchingRouteService {\n  getConfigIdForClosestMatchingRoute(route, configurations) {\n    for (const config of configurations) {\n      const {\n        secureRoutes\n      } = config;\n\n      for (const configuredRoute of secureRoutes) {\n        if (route.startsWith(configuredRoute)) {\n          return {\n            matchingRoute: configuredRoute,\n            matchingConfig: config\n          };\n        }\n      }\n    }\n\n    return {\n      matchingRoute: null,\n      matchingConfig: null\n    };\n  }\n\n}\n\nClosestMatchingRouteService.ɵfac = function ClosestMatchingRouteService_Factory(t) {\n  return new (t || ClosestMatchingRouteService)();\n};\n\nClosestMatchingRouteService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ClosestMatchingRouteService,\n  factory: ClosestMatchingRouteService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ClosestMatchingRouteService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ConsoleLoggerService {\n  logError(message, ...args) {\n    console.error(message, ...args);\n  }\n\n  logWarning(message, ...args) {\n    console.warn(message, ...args);\n  }\n\n  logDebug(message, ...args) {\n    console.debug(message, ...args);\n  }\n\n}\n\nConsoleLoggerService.ɵfac = function ConsoleLoggerService_Factory(t) {\n  return new (t || ConsoleLoggerService)();\n};\n\nConsoleLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ConsoleLoggerService,\n  factory: ConsoleLoggerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ConsoleLoggerService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ResponseTypeValidationService {\n  constructor(loggerService, flowHelper) {\n    this.loggerService = loggerService;\n    this.flowHelper = flowHelper;\n  }\n\n  hasConfigValidResponseType(configuration) {\n    if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configuration)) {\n      return true;\n    }\n\n    if (this.flowHelper.isCurrentFlowCodeFlow(configuration)) {\n      return true;\n    }\n\n    this.loggerService.logWarning(configuration, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\n    return false;\n  }\n\n}\n\nResponseTypeValidationService.ɵfac = function ResponseTypeValidationService_Factory(t) {\n  return new (t || ResponseTypeValidationService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(FlowHelper));\n};\n\nResponseTypeValidationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ResponseTypeValidationService,\n  factory: ResponseTypeValidationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ResponseTypeValidationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: FlowHelper\n    }];\n  }, null);\n})();\n\nclass RedirectService {\n  constructor(doc) {\n    this.doc = doc;\n  }\n\n  redirectTo(url) {\n    this.doc.location.href = url;\n  }\n\n}\n\nRedirectService.ɵfac = function RedirectService_Factory(t) {\n  return new (t || RedirectService)(i0.ɵɵinject(DOCUMENT));\n};\n\nRedirectService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: RedirectService,\n  factory: RedirectService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(RedirectService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass ParService {\n  constructor(loggerService, urlService, dataService, storagePersistenceService) {\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  postParRequest(configuration, customParams) {\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\n\n    if (!authWellKnownEndpoints) {\n      return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\n    }\n\n    const parEndpoint = authWellKnownEndpoints.parEndpoint;\n\n    if (!parEndpoint) {\n      return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\n    }\n\n    return this.urlService.createBodyForParCodeFlowRequest(configuration, customParams).pipe(switchMap(data => {\n      return this.dataService.post(parEndpoint, data, configuration, headers).pipe(retry(2), map(response => {\n        this.loggerService.logDebug(configuration, 'par response: ', response);\n        return {\n          expiresIn: response.expires_in,\n          requestUri: response.request_uri\n        };\n      }), catchError(error => {\n        const errorMessage = `There was an error on ParService postParRequest`;\n        this.loggerService.logError(configuration, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }));\n    }));\n  }\n\n}\n\nParService.ɵfac = function ParService_Factory(t) {\n  return new (t || ParService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nParService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParService,\n  factory: ParService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass ParLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, popupService, checkAuthService, parService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n    this.parService = parService;\n  }\n\n  loginPar(configuration, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      this.loggerService.logError(configuration, 'Invalid response type!');\n      return;\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams))).subscribe(response => {\n      this.loggerService.logDebug(configuration, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\n      this.loggerService.logDebug(configuration, 'par request url: ', url);\n\n      if (!url) {\n        this.loggerService.logError(configuration, `Could not create URL with param ${response.requestUri}: '${url}'`);\n        return;\n      }\n\n      if (urlHandler) {\n        urlHandler(url);\n      } else {\n        this.redirectService.redirectTo(url);\n      }\n    });\n  }\n\n  loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configuration, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    const {\n      customParams\n    } = authOptions || {};\n    return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)), switchMap(response => {\n      this.loggerService.logDebug(configuration, 'par response: ', response);\n      const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\n      this.loggerService.logDebug(configuration, 'par request url: ', url);\n\n      if (!url) {\n        const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\n        this.loggerService.logError(configuration, errorMessage);\n        return throwError(() => new Error(errorMessage));\n      }\n\n      this.popupService.openPopUp(url, popupOptions);\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nParLoginService.ɵfac = function ParLoginService_Factory(t) {\n  return new (t || ParLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(ParService));\n};\n\nParLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParLoginService,\n  factory: ParLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: ParService\n    }];\n  }, null);\n})();\n\nclass PopUpLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, authWellKnownService, popupService, checkAuthService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.authWellKnownService = authWellKnownService;\n    this.popupService = popupService;\n    this.checkAuthService = checkAuthService;\n  }\n\n  loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions) {\n    const {\n      configId\n    } = configuration;\n\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      const errorMessage = 'Invalid response type!';\n      this.loggerService.logError(configuration, errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\n    return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => {\n      return this.urlService.getAuthorizeUrl(configuration, authOptions);\n    }), tap(authUrl => this.popupService.openPopUp(authUrl, popupOptions)), switchMap(() => {\n      return this.popupService.result$.pipe(take(1), switchMap(result => {\n        const {\n          userClosed,\n          receivedUrl\n        } = result;\n\n        if (userClosed) {\n          return of({\n            isAuthenticated: false,\n            errorMessage: 'User closed popup',\n            userData: null,\n            idToken: null,\n            accessToken: null,\n            configId\n          });\n        }\n\n        return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\n      }));\n    }));\n  }\n\n}\n\nPopUpLoginService.ɵfac = function PopUpLoginService_Factory(t) {\n  return new (t || PopUpLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(PopUpService), i0.ɵɵinject(CheckAuthService));\n};\n\nPopUpLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PopUpLoginService,\n  factory: PopUpLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PopUpLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: PopUpService\n    }, {\n      type: CheckAuthService\n    }];\n  }, null);\n})();\n\nclass StandardLoginService {\n  constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, flowsDataService) {\n    this.loggerService = loggerService;\n    this.responseTypeValidationService = responseTypeValidationService;\n    this.urlService = urlService;\n    this.redirectService = redirectService;\n    this.authWellKnownService = authWellKnownService;\n    this.flowsDataService = flowsDataService;\n  }\n\n  loginStandard(configuration, authOptions) {\n    if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\n      this.loggerService.logError(configuration, 'Invalid response type!');\n      return;\n    }\n\n    this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\n    this.flowsDataService.setCodeFlowInProgress(configuration);\n    this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).subscribe(() => {\n      const {\n        urlHandler\n      } = authOptions || {};\n      this.flowsDataService.resetSilentRenewRunning(configuration);\n      this.urlService.getAuthorizeUrl(configuration, authOptions).subscribe(url => {\n        if (!url) {\n          this.loggerService.logError(configuration, 'Could not create URL', url);\n          return;\n        }\n\n        if (urlHandler) {\n          urlHandler(url);\n        } else {\n          this.redirectService.redirectTo(url);\n        }\n      });\n    });\n  }\n\n}\n\nStandardLoginService.ɵfac = function StandardLoginService_Factory(t) {\n  return new (t || StandardLoginService)(i0.ɵɵinject(LoggerService), i0.ɵɵinject(ResponseTypeValidationService), i0.ɵɵinject(UrlService), i0.ɵɵinject(RedirectService), i0.ɵɵinject(AuthWellKnownService), i0.ɵɵinject(FlowsDataService));\n};\n\nStandardLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StandardLoginService,\n  factory: StandardLoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StandardLoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LoggerService\n    }, {\n      type: ResponseTypeValidationService\n    }, {\n      type: UrlService\n    }, {\n      type: RedirectService\n    }, {\n      type: AuthWellKnownService\n    }, {\n      type: FlowsDataService\n    }];\n  }, null);\n})();\n\nclass LoginService {\n  constructor(parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\n    this.parLoginService = parLoginService;\n    this.popUpLoginService = popUpLoginService;\n    this.standardLoginService = standardLoginService;\n    this.storagePersistenceService = storagePersistenceService;\n  }\n\n  login(configuration, authOptions) {\n    const {\n      usePushedAuthorisationRequests\n    } = configuration;\n\n    if (authOptions?.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\n    }\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginPar(configuration, authOptions);\n    } else {\n      return this.standardLoginService.loginStandard(configuration, authOptions);\n    }\n  }\n\n  loginWithPopUp(configuration, allConfigs, authOptions, popupOptions) {\n    const {\n      usePushedAuthorisationRequests\n    } = configuration;\n\n    if (authOptions?.customParams) {\n      this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\n    }\n\n    if (usePushedAuthorisationRequests) {\n      return this.parLoginService.loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions);\n    } else {\n      return this.popUpLoginService.loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions);\n    }\n  }\n\n}\n\nLoginService.ɵfac = function LoginService_Factory(t) {\n  return new (t || LoginService)(i0.ɵɵinject(ParLoginService), i0.ɵɵinject(PopUpLoginService), i0.ɵɵinject(StandardLoginService), i0.ɵɵinject(StoragePersistenceService));\n};\n\nLoginService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoginService,\n  factory: LoginService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoginService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ParLoginService\n    }, {\n      type: PopUpLoginService\n    }, {\n      type: StandardLoginService\n    }, {\n      type: StoragePersistenceService\n    }];\n  }, null);\n})();\n\nclass LogoffRevocationService {\n  constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService) {\n    this.dataService = dataService;\n    this.storagePersistenceService = storagePersistenceService;\n    this.loggerService = loggerService;\n    this.urlService = urlService;\n    this.checkSessionService = checkSessionService;\n    this.resetAuthDataService = resetAuthDataService;\n    this.redirectService = redirectService;\n  } // Logs out on the server and the local client.\n  // If the server state has changed, check session, then only a local logout.\n\n\n  logoff(config, allConfigs, authOptions) {\n    const {\n      urlHandler,\n      customParams\n    } = authOptions || {};\n    this.loggerService.logDebug(config, 'logoff, remove auth ');\n    const endSessionUrl = this.getEndSessionUrl(config, customParams);\n    this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n\n    if (!endSessionUrl) {\n      this.loggerService.logDebug(config, 'only local login cleaned up, no end_session_endpoint');\n      return;\n    }\n\n    if (this.checkSessionService.serverStateChanged(config)) {\n      this.loggerService.logDebug(config, 'only local login cleaned up, server session has changed');\n    } else if (urlHandler) {\n      urlHandler(endSessionUrl);\n    } else {\n      this.redirectService.redirectTo(endSessionUrl);\n    }\n  }\n\n  logoffLocal(config, allConfigs) {\n    this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\n    this.checkSessionService.stop();\n  }\n\n  logoffLocalMultiple(allConfigs) {\n    allConfigs.forEach(configuration => this.logoffLocal(configuration, allConfigs));\n  } // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\n  // only the access token is revoked. Then the logout run.\n\n\n  logoffAndRevokeTokens(config, allConfigs, authOptions) {\n    const {\n      revocationEndpoint\n    } = this.storagePersistenceService.read('authWellKnownEndPoints', config) || {};\n\n    if (!revocationEndpoint) {\n      this.loggerService.logDebug(config, 'revocation endpoint not supported');\n      this.logoff(config, allConfigs, authOptions);\n      return of(null);\n    }\n\n    if (this.storagePersistenceService.getRefreshToken(config)) {\n      return this.revokeRefreshToken(config).pipe(switchMap(result => this.revokeAccessToken(config, result)), catchError(error => {\n        const errorMessage = `revoke token failed`;\n        this.loggerService.logError(config, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }), tap(() => this.logoff(config, allConfigs, authOptions)));\n    } else {\n      return this.revokeAccessToken(config).pipe(catchError(error => {\n        const errorMessage = `revoke accessToken failed`;\n        this.loggerService.logError(config, errorMessage, error);\n        return throwError(() => new Error(errorMessage));\n      }), tap(() => this.logoff(config, allConfigs, authOptions)));\n    }\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an access token on the STS. If no token is provided, then the token from\n  // the storage is revoked. You can pass any token to revoke. This makes it possible to\n  // manage your own tokens. The is a public API.\n\n\n  revokeAccessToken(configuration, accessToken) {\n    const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configuration);\n    const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configuration);\n    return this.sendRevokeRequest(configuration, body);\n  } // https://tools.ietf.org/html/rfc7009\n  // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\n  // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\n  // This makes it possible to manage your own tokens.\n\n\n  revokeRefreshToken(configuration, refreshToken) {\n    const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configuration);\n    const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configuration);\n    return this.sendRevokeRequest(configuration, body);\n  }\n\n  getEndSessionUrl(configuration, customParams) {\n    const idToken = this.storagePersistenceService.getIdToken(configuration);\n    const {\n      customParamsEndSessionRequest\n    } = configuration;\n    const mergedParams = { ...customParamsEndSessionRequest,\n      ...customParams\n    };\n    return this.urlService.createEndSessionUrl(idToken, configuration, mergedParams);\n  }\n\n  sendRevokeRequest(configuration, body) {\n    const url = this.urlService.getRevocationEndpointUrl(configuration);\n    let headers = new HttpHeaders();\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    return this.dataService.post(url, body, configuration, headers).pipe(retry(2), switchMap(response => {\n      this.loggerService.logDebug(configuration, 'revocation endpoint post response: ', response);\n      return of(response);\n    }), catchError(error => {\n      const errorMessage = `Revocation request failed`;\n      this.loggerService.logError(configuration, errorMessage, error);\n      return throwError(() => new Error(errorMessage));\n    }));\n  }\n\n}\n\nLogoffRevocationService.ɵfac = function LogoffRevocationService_Factory(t) {\n  return new (t || LogoffRevocationService)(i0.ɵɵinject(DataService), i0.ɵɵinject(StoragePersistenceService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(UrlService), i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(ResetAuthDataService), i0.ɵɵinject(RedirectService));\n};\n\nLogoffRevocationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LogoffRevocationService,\n  factory: LogoffRevocationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LogoffRevocationService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DataService\n    }, {\n      type: StoragePersistenceService\n    }, {\n      type: LoggerService\n    }, {\n      type: UrlService\n    }, {\n      type: CheckSessionService\n    }, {\n      type: ResetAuthDataService\n    }, {\n      type: RedirectService\n    }];\n  }, null);\n})();\n\nclass OidcSecurityService {\n  constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationService, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService, authWellKnownService) {\n    this.checkSessionService = checkSessionService;\n    this.checkAuthService = checkAuthService;\n    this.userService = userService;\n    this.tokenHelperService = tokenHelperService;\n    this.configurationService = configurationService;\n    this.authStateService = authStateService;\n    this.flowsDataService = flowsDataService;\n    this.callbackService = callbackService;\n    this.logoffRevocationService = logoffRevocationService;\n    this.loginService = loginService;\n    this.refreshSessionService = refreshSessionService;\n    this.urlService = urlService;\n    this.authWellKnownService = authWellKnownService;\n    this.isLoading = new BehaviorSubject(true);\n\n    this.finishLoading = () => {\n      this.isLoading.next(false);\n    };\n\n    this.finishLoadingOnError = err => {\n      this.isLoading.next(false);\n      return throwError(() => err);\n    };\n  }\n  /**\r\n   * Provides information about the user after they have logged in.\r\n   *\r\n   * @returns Returns an object containing either the user data directly (single config) or\r\n   * the user data per config in case you are running with multiple configs\r\n   */\n\n\n  get userData$() {\n    return this.userService.userData$;\n  }\n  /**\r\n   * Emits each time an authorization event occurs.\r\n   *\r\n   * @returns Returns an object containing if you are authenticated or not.\r\n   * Single Config: true if config is authenticated, false if not.\r\n   * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n   *\r\n   * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n   */\n\n\n  get isAuthenticated$() {\n    return this.authStateService.authenticated$;\n  }\n  /**\r\n   * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n   * true.\r\n   */\n\n\n  get checkSessionChanged$() {\n    return this.checkSessionService.checkSessionChanged$;\n  }\n  /**\r\n   * Emits on a Security Token Service callback. The observable will never contain a value.\r\n   */\n\n\n  get stsCallback$() {\n    return this.callbackService.stsCallback$;\n  }\n  /**\r\n   * @deprecated This property should not be used. Please use the `PublicEventsService` instead. This property is removed in future versions\r\n   * Emits false when the observable, returned by one of the checkAuth() methods, emits a value, or errors. Initial value: true.\r\n   */\n\n\n  get isLoading$() {\n    return this.isLoading.asObservable();\n  }\n\n  preloadAuthWellKnownDocument(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap(config => this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config)));\n  }\n  /**\r\n   * Returns the currently active OpenID configurations.\r\n   *\r\n   * @returns an array of OpenIdConfigurations.\r\n   */\n\n\n  getConfigurations() {\n    return this.configurationService.getAllConfigurations();\n  }\n  /**\r\n   * Returns a single active OpenIdConfiguration.\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n   */\n\n\n  getConfiguration(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId);\n  }\n  /**\r\n   * Returns the userData for a configuration\r\n   *\r\n   * @param configId The configId to identify the config. If not passed, the first one is being used\r\n   */\n\n\n  getUserData(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.userService.getUserDataFromStore(config)));\n  }\n  /**\r\n   * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An object `LoginResponse` containing all information about the login\r\n   */\n\n\n  checkAuth(url, configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({\n      allConfigs,\n      currentConfig\n    }) => this.checkAuthService.checkAuth(currentConfig, allConfigs, url)), tap(this.finishLoading), catchError(this.finishLoadingOnError));\n  }\n  /**\r\n   * Starts the complete setup flow for multiple configurations.\r\n   * Calling will start the entire authentication flow, and the returned observable\r\n   * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n   * an error message in case an error happened in an array for each config which was provided\r\n   *\r\n   * @param url The URL to perform the authorization on the behalf of.\r\n   * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n   * configured ones will be used to check.\r\n   *\r\n   * @returns An array of `LoginResponse` objects containing all information about the logins\r\n   */\n\n\n  checkAuthMultiple(url) {\n    return this.configurationService.getOpenIDConfigurations().pipe(switchMap(({\n      allConfigs\n    }) => this.checkAuthService.checkAuthMultiple(allConfigs, url)), tap(this.finishLoading), catchError(this.finishLoadingOnError));\n  }\n  /**\r\n   * Provides information about the current authenticated state\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A boolean whether the config is authenticated or not.\r\n   */\n\n\n  isAuthenticated(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.isAuthenticated(config)));\n  }\n  /**\r\n   * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n   */\n\n\n  checkAuthIncludingServer(configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({\n      allConfigs,\n      currentConfig\n    }) => this.checkAuthService.checkAuthIncludingServer(currentConfig, allConfigs)), tap(this.finishLoading), catchError(this.finishLoadingOnError));\n  }\n  /**\r\n   * Returns the access token for the login scenario.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the access token.\r\n   */\n\n\n  getAccessToken(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getAccessToken(config)));\n  }\n  /**\r\n   * Returns the ID token for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the id token.\r\n   */\n\n\n  getIdToken(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getIdToken(config)));\n  }\n  /**\r\n   * Returns the refresh token, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the refresh token.\r\n   */\n\n\n  getRefreshToken(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getRefreshToken(config)));\n  }\n  /**\r\n   * Returns the authentication result, if present, for the sign-in.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A object with the authentication result\r\n   */\n\n\n  getAuthenticationResult(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.authStateService.getAuthenticationResult(config)));\n  }\n  /**\r\n   * Returns the payload from the ID token.\r\n   *\r\n   * @param encode Set to true if the payload is base64 encoded\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The payload from the id token.\r\n   */\n\n\n  getPayloadFromIdToken(encode = false, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => {\n      const token = this.authStateService.getIdToken(config);\n      return this.tokenHelperService.getPayloadFromToken(token, encode, config);\n    }));\n  }\n  /**\r\n   * Sets a custom state for the authorize request.\r\n   *\r\n   * @param state The state to set.\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   */\n\n\n  setState(state, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.flowsDataService.setAuthStateControl(state, config)));\n  }\n  /**\r\n   * Gets the state value used for the authorize request.\r\n   *\r\n   * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n   *\r\n   * @returns The state value used for the authorize request.\r\n   */\n\n\n  getState(configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.flowsDataService.getAuthStateControl(config)));\n  }\n  /**\r\n   * Redirects the user to the Security Token Service to begin the authentication process.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the the authentication request.\r\n   */\n\n\n  authorize(configId, authOptions) {\n    this.configurationService.getOpenIDConfiguration(configId).subscribe(config => this.loginService.login(config, authOptions));\n  }\n  /**\r\n   * Opens the Security Token Service in a new window to begin the authentication process.\r\n   *\r\n   * @param authOptions The custom options for the authentication request.\r\n   * @param popupOptions The configuration for the popup window.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  authorizeWithPopUp(authOptions, popupOptions, configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({\n      allConfigs,\n      currentConfig\n    }) => this.loginService.loginWithPopUp(currentConfig, allConfigs, authOptions, popupOptions)));\n  }\n  /**\r\n   * Manually refreshes the session.\r\n   *\r\n   * @param customParams Custom parameters to pass to the refresh request.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An `Observable<LoginResponse>` containing all information about the login\r\n   */\n\n\n  forceRefreshSession(customParams, configId) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({\n      allConfigs,\n      currentConfig\n    }) => this.refreshSessionService.userForceRefreshSession(currentConfig, allConfigs, customParams)));\n  }\n  /**\r\n   * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n   * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n   * only the access token is revoked. Then the logout run.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions The custom options for the request.\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  logoffAndRevokeTokens(configId, authOptions) {\n    return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({\n      allConfigs,\n      currentConfig\n    }) => this.logoffRevocationService.logoffAndRevokeTokens(currentConfig, allConfigs, authOptions)));\n  }\n  /**\r\n   * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n   * then only a local logout is performed.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   * @param authOptions with custom parameters and/or an custom url handler\r\n   */\n\n\n  logoff(configId, authOptions) {\n    this.configurationService.getOpenIDConfigurations(configId).subscribe(({\n      allConfigs,\n      currentConfig\n    }) => this.logoffRevocationService.logoff(currentConfig, allConfigs, authOptions));\n  }\n  /**\r\n   * Logs the user out of the application without logging them out of the server.\r\n   * Use this method if you have _one_ config enabled.\r\n   *\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   */\n\n\n  logoffLocal(configId) {\n    this.configurationService.getOpenIDConfigurations(configId).subscribe(({\n      allConfigs,\n      currentConfig\n    }) => this.logoffRevocationService.logoffLocal(currentConfig, allConfigs));\n  }\n  /**\r\n   * Logs the user out of the application for all configs without logging them out of the server.\r\n   * Use this method if you have _multiple_ configs enabled.\r\n   */\n\n\n  logoffLocalMultiple() {\n    this.configurationService.getOpenIDConfigurations().subscribe(({\n      allConfigs\n    }) => this.logoffRevocationService.logoffLocalMultiple(allConfigs));\n  }\n  /**\r\n   * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param accessToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeAccessToken(accessToken, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap(config => this.logoffRevocationService.revokeAccessToken(config, accessToken)));\n  }\n  /**\r\n   * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n   * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n   * https://tools.ietf.org/html/rfc7009\r\n   *\r\n   * @param refreshToken The access token to revoke.\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns An observable when the action is finished\r\n   */\n\n\n  revokeRefreshToken(refreshToken, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap(config => this.logoffRevocationService.revokeRefreshToken(config, refreshToken)));\n  }\n  /**\r\n   * Creates the end session URL which can be used to implement an alternate server logout.\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the end session url or null\r\n   */\n\n\n  getEndSessionUrl(customParams, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(map(config => this.logoffRevocationService.getEndSessionUrl(config, customParams)));\n  }\n  /**\r\n   * Creates the authorize URL based on your flow\r\n   *\r\n   * @param customParams\r\n   * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n   *\r\n   * @returns A string with the authorize URL or null\r\n   */\n\n\n  getAuthorizeUrl(customParams, configId) {\n    return this.configurationService.getOpenIDConfiguration(configId).pipe(switchMap(config => this.urlService.getAuthorizeUrl(config, customParams ? {\n      customParams\n    } : undefined)));\n  }\n\n}\n\nOidcSecurityService.ɵfac = function OidcSecurityService_Factory(t) {\n  return new (t || OidcSecurityService)(i0.ɵɵinject(CheckSessionService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(UserService), i0.ɵɵinject(TokenHelperService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(FlowsDataService), i0.ɵɵinject(CallbackService), i0.ɵɵinject(LogoffRevocationService), i0.ɵɵinject(LoginService), i0.ɵɵinject(RefreshSessionService), i0.ɵɵinject(UrlService), i0.ɵɵinject(AuthWellKnownService));\n};\n\nOidcSecurityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OidcSecurityService,\n  factory: OidcSecurityService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OidcSecurityService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: CheckSessionService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: UserService\n    }, {\n      type: TokenHelperService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: AuthStateService\n    }, {\n      type: FlowsDataService\n    }, {\n      type: CallbackService\n    }, {\n      type: LogoffRevocationService\n    }, {\n      type: LoginService\n    }, {\n      type: RefreshSessionService\n    }, {\n      type: UrlService\n    }, {\n      type: AuthWellKnownService\n    }];\n  }, null);\n})();\n\nclass DefaultSessionStorageService {\n  read(key) {\n    return sessionStorage.getItem(key);\n  }\n\n  write(key, value) {\n    sessionStorage.setItem(key, value);\n  }\n\n  remove(key) {\n    sessionStorage.removeItem(key);\n  }\n\n  clear() {\n    sessionStorage.clear();\n  }\n\n}\n\nDefaultSessionStorageService.ɵfac = function DefaultSessionStorageService_Factory(t) {\n  return new (t || DefaultSessionStorageService)();\n};\n\nDefaultSessionStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultSessionStorageService,\n  factory: DefaultSessionStorageService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultSessionStorageService, [{\n    type: Injectable\n  }], null, null);\n})(); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n\n\nfunction createStaticLoader(passedConfig) {\n  return new StsConfigStaticLoader(passedConfig.config);\n}\n\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\n\nclass AuthModule {\n  static forRoot(passedConfig) {\n    return {\n      ngModule: AuthModule,\n      providers: [// Make the PASSED_CONFIG available through injection\n      {\n        provide: PASSED_CONFIG,\n        useValue: passedConfig\n      }, // Create the loader: Either the one getting passed or a static one\n      passedConfig?.loader || {\n        provide: StsConfigLoader,\n        useFactory: createStaticLoader,\n        deps: [PASSED_CONFIG]\n      }, ConfigurationService, PublicEventsService, FlowHelper, OidcSecurityService, TokenValidationService, PlatformProvider, CheckSessionService, FlowsDataService, FlowsService, SilentRenewService, LogoffRevocationService, UserService, RandomService, HttpBaseService, UrlService, AuthStateService, SigninKeyDataService, StoragePersistenceService, TokenHelperService, IFrameService, EqualityService, LoginService, ParService, AuthWellKnownDataService, AuthWellKnownService, DataService, StateValidationService, ConfigValidationService, CheckAuthService, ResetAuthDataService, ImplicitFlowCallbackService, HistoryJwtKeysCallbackHandlerService, ResponseTypeValidationService, UserCallbackHandlerService, StateValidationCallbackHandlerService, RefreshSessionCallbackHandlerService, RefreshTokenCallbackHandlerService, CodeFlowCallbackHandlerService, ImplicitFlowCallbackHandlerService, ParLoginService, PopUpLoginService, StandardLoginService, AutoLoginService, JwkExtractor, JwkWindowCryptoService, JwtWindowCryptoService, CurrentUrlService, ClosestMatchingRouteService, DefaultSessionStorageService, BrowserStorageService, CryptoService, LoggerService, {\n        provide: AbstractSecurityStorage,\n        useClass: DefaultSessionStorageService\n      }, {\n        provide: AbstractLoggerService,\n        useClass: ConsoleLoggerService\n      }]\n    };\n  }\n\n}\n\nAuthModule.ɵfac = function AuthModule_Factory(t) {\n  return new (t || AuthModule)();\n};\n\nAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AuthModule\n});\nAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule, HttpClientModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, HttpClientModule],\n      declarations: [],\n      exports: []\n    }]\n  }], null, null);\n})();\n\nclass AutoLoginAllRoutesGuard {\n  constructor(autoLoginService, checkAuthService, loginService, configurationService, router) {\n    this.autoLoginService = autoLoginService;\n    this.checkAuthService = checkAuthService;\n    this.loginService = loginService;\n    this.configurationService = configurationService;\n    this.router = router;\n  }\n\n  canLoad() {\n    return this.checkAuth(this.router.getCurrentNavigation()?.extractedUrl.toString().substring(1) ?? '');\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    return this.configurationService.getOpenIDConfiguration().pipe(switchMap(config => {\n      const allconfigs = this.configurationService.getAllConfigurations();\n      return this.checkAuthService.checkAuth(config, allconfigs).pipe(take(1), map(({\n        isAuthenticated\n      }) => {\n        if (isAuthenticated) {\n          this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\n        }\n\n        if (!isAuthenticated) {\n          this.autoLoginService.saveRedirectRoute(config, url);\n          this.loginService.login(config);\n        }\n\n        return isAuthenticated;\n      }));\n    }));\n  }\n\n}\n\nAutoLoginAllRoutesGuard.ɵfac = function AutoLoginAllRoutesGuard_Factory(t) {\n  return new (t || AutoLoginAllRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(CheckAuthService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginAllRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginAllRoutesGuard,\n  factory: AutoLoginAllRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginAllRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: CheckAuthService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass AutoLoginPartialRoutesGuard {\n  constructor(autoLoginService, authStateService, loginService, configurationService, router) {\n    this.autoLoginService = autoLoginService;\n    this.authStateService = authStateService;\n    this.loginService = loginService;\n    this.configurationService = configurationService;\n    this.router = router;\n  }\n\n  canLoad() {\n    return this.checkAuth(this.router.getCurrentNavigation()?.extractedUrl.toString().substring(1) ?? '');\n  }\n\n  canActivate(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  canActivateChild(route, state) {\n    return this.checkAuth(state.url);\n  }\n\n  checkAuth(url) {\n    return this.configurationService.getOpenIDConfiguration().pipe(map(configuration => {\n      const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configuration);\n\n      if (isAuthenticated) {\n        this.autoLoginService.checkSavedRedirectRouteAndNavigate(configuration);\n      }\n\n      if (!isAuthenticated) {\n        this.autoLoginService.saveRedirectRoute(configuration, url);\n        this.loginService.login(configuration);\n      }\n\n      return isAuthenticated;\n    }));\n  }\n\n}\n\nAutoLoginPartialRoutesGuard.ɵfac = function AutoLoginPartialRoutesGuard_Factory(t) {\n  return new (t || AutoLoginPartialRoutesGuard)(i0.ɵɵinject(AutoLoginService), i0.ɵɵinject(AuthStateService), i0.ɵɵinject(LoginService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(i2.Router));\n};\n\nAutoLoginPartialRoutesGuard.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AutoLoginPartialRoutesGuard,\n  factory: AutoLoginPartialRoutesGuard.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AutoLoginPartialRoutesGuard, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: AutoLoginService\n    }, {\n      type: AuthStateService\n    }, {\n      type: LoginService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: i2.Router\n    }];\n  }, null);\n})();\n\nclass AuthInterceptor {\n  constructor(authStateService, configurationService, loggerService, closestMatchingRouteService) {\n    this.authStateService = authStateService;\n    this.configurationService = configurationService;\n    this.loggerService = loggerService;\n    this.closestMatchingRouteService = closestMatchingRouteService;\n  }\n\n  intercept(req, next) {\n    if (!this.configurationService.hasAtLeastOneConfig()) {\n      return next.handle(req);\n    }\n\n    const allConfigurations = this.configurationService.getAllConfigurations();\n    const allRoutesConfigured = allConfigurations.map(x => x.secureRoutes || []);\n    const allRoutesConfiguredFlat = [].concat(...allRoutesConfigured);\n\n    if (allRoutesConfiguredFlat.length === 0) {\n      this.loggerService.logDebug(allConfigurations[0], `No routes to check configured`);\n      return next.handle(req);\n    }\n\n    const {\n      matchingConfig,\n      matchingRoute\n    } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url, allConfigurations);\n\n    if (!matchingConfig) {\n      this.loggerService.logDebug(allConfigurations[0], `Did not find any configured route for route ${req.url}`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}'`);\n    const token = this.authStateService.getAccessToken(matchingConfig);\n\n    if (!token) {\n      this.loggerService.logDebug(matchingConfig, `Wanted to add token to ${req.url} but found no token: '${token}'`);\n      return next.handle(req);\n    }\n\n    this.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\n    req = req.clone({\n      headers: req.headers.set('Authorization', 'Bearer ' + token)\n    });\n    return next.handle(req);\n  }\n\n}\n\nAuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) {\n  return new (t || AuthInterceptor)(i0.ɵɵinject(AuthStateService), i0.ɵɵinject(ConfigurationService), i0.ɵɵinject(LoggerService), i0.ɵɵinject(ClosestMatchingRouteService));\n};\n\nAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AuthInterceptor,\n  factory: AuthInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: AuthStateService\n    }, {\n      type: ConfigurationService\n    }, {\n      type: LoggerService\n    }, {\n      type: ClosestMatchingRouteService\n    }];\n  }, null);\n})(); // Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { AbstractLoggerService, AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, ConfigurationService, EventTypes, LogLevel, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, ValidationResult, createStaticLoader };","map":{"version":3,"names":["DOCUMENT","isPlatformBrowser","CommonModule","i1","HttpHeaders","HttpParams","HttpErrorResponse","HttpResponse","HttpClientModule","i0","Injectable","Inject","PLATFORM_ID","InjectionToken","NgModule","ReplaySubject","from","of","BehaviorSubject","Observable","throwError","timer","Subject","forkJoin","TimeoutError","map","mergeMap","tap","distinctUntilChanged","take","switchMap","retryWhen","catchError","retry","concatMap","timeout","base64url","i2","HttpBaseService","constructor","http","get","url","params","post","body","ɵfac","HttpClient","ɵprov","type","NGSW_CUSTOM_PARAM","DataService","httpClient","config","token","headers","prepareHeaders","prepareParams","headersParams","set","decodeURIComponent","ngswBypass","EventTypes","LogLevel","AbstractLoggerService","LoggerService","abstractLoggerService","logError","configuration","message","args","loggingIsTurnedOff","configId","messageToLog","isObject","JSON","stringify","length","logWarning","logLevelIsSet","currentLogLevelIsEqualOrSmallerThan","Warn","logDebug","Debug","logLevelToCompare","logLevel","undefined","None","possibleObject","Object","prototype","toString","call","AbstractSecurityStorage","BrowserStorageService","loggerService","abstractSecurityStorage","read","key","hasStorage","storedConfig","parse","write","value","remove","clear","Storage","StoragePersistenceService","browserStorageService","resetStorageFlowData","resetAuthStateInStorage","getAccessToken","getIdToken","id_token","getRefreshToken","refreshToken","refresh_token","allowUnsafeReuseRefreshToken","getAuthenticationResult","PublicEventsService","notify","fireEvent","next","registerForEvents","asObservable","PARTS_OF_TOKEN","TokenHelperService","document","getTokenExpirationDate","dataIdToken","hasOwnProperty","Date","toUTCString","date","setUTCSeconds","exp","getSigningInputFromToken","encoded","tokenIsValid","header","getHeaderFromToken","payload","getPayloadFromToken","join","getPartOfToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","str","output","replace","Error","decoded","defaultView","atob","Buffer","split","c","charCodeAt","slice","err","includes","parts","Document","decorators","JwkExtractor","buildErrorName","name","extractJwk","keys","spec","throwOnEmpty","InvalidArgumentError","foundKeys","filter","k","kid","use","kty","NoMatchingKeysError","SeveralMatchingKeysError","CryptoService","doc","getCrypto","crypto","msCrypto","JwkWindowCryptoService","cryptoService","importVerificationKey","algorithm","subtle","importKey","verifyKey","verifyAlgorithm","cryptoKey","signature","signingInput","verify","TextEncoder","encode","JwtWindowCryptoService","generateCodeChallenge","codeVerifier","calcHash","pipe","challengeRaw","base64UrlEncode","generateAtHash","accessToken","tokenHash","substr","tokenHashBase64","btoa","valueToHash","msgBuffer","digest","hashBuffer","hashArray","Array","Uint8Array","toHashString","byteArray","e","String","fromCharCode","base64","TokenValidationService","tokenHelperService","jwkExtractor","jwkWindowCryptoService","jwtWindowCryptoService","keyAlgorithms","hasIdTokenExpired","offsetSeconds","disableIdTokenValidation","validateIdTokenExpNotExpired","decodedIdToken","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","calculateNowWithOffset","tokenNotExpired","millisToMinutesAndSeconds","toLocaleTimeString","validateAccessTokenNotExpired","accessTokenExpiresAt","accessTokenExpirationValue","validateRequiredIdToken","validated","validateIdTokenIatMaxOffset","maxOffsetAllowedInSeconds","disableIatOffsetValidation","dateTimeIatIdToken","iat","nowInUtc","diff","maxOffsetAllowedInMilliseconds","validateIdTokenNonce","localNonce","ignoreNonceAfterRefresh","isFromRefreshToken","nonce","refreshTokenNoncePlaceholder","validateIdTokenIss","authWellKnownEndpointsIssuer","iss","validateIdTokenAud","aud","isArray","validateIdTokenAzpExistsIfMoreThanOneAud","azp","validateIdTokenAzpValid","clientId","validateStateFromHashCallback","state","localState","validateSignatureIdToken","idToken","jwtkeys","headerData","alg","alg2kty","getImportAlg","rawSignature","agent","navigator","userAgent","toLowerCase","indexOf","loose","getVerifyAlg","isValid","charAt","hash","namedCurve","validateIdTokenAtHash","atHash","idTokenAlg","sha","newHash","millis","minutes","Math","floor","seconds","toFixed","DEFAULT_AUTHRESULT","isAuthenticated","allConfigsAuthenticated","AuthStateService","storagePersistenceService","publicEventsService","tokenValidationService","authenticatedInternal$","authenticated$","setAuthenticatedAndFireEvent","allConfigs","composeAuthenticatedResult","setUnauthenticatedAndFireEvent","currentConfig","composeUnAuthenticatedResult","updateAndPublishAuthState","authenticationResult","NewAuthenticationResult","setAuthorizationData","authResult","persistAccessTokenExpirationTime","decodeURIComponentSafely","areAuthStorageTokensValid","hasIdTokenExpiredAndRenewCheckIsEnabled","hasAccessTokenExpiredIfExpiryExists","renewTimeBeforeTokenExpiresInSeconds","enableIdTokenExpiredValidationInRenew","tokenToCheck","idTokenExpired","IdTokenExpired","accessTokenExpiresIn","accessTokenHasNotExpired","hasExpired","TokenExpired","hasAccessToken","hasIdToken","expires_in","accessTokenExpiryTime","checkAllConfigsIfTheyAreAuthenticated","every","x","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","isIFrameElement","iFrameOnSelf","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","createElement","id","title","style","display","appendChild","iFrameElement","parent","getElementById","element","HTMLIFrameElement","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","CheckSessionService","iFrameService","eventService","zone","checkSessionReceived","lastIFrameRefresh","outstandingMessages","heartBeatInterval","iframeRefreshInterval","checkSessionChangedInternal$","checkSessionChanged$","isCheckSessionConfigured","startCheckSession","start","scheduledHeartBeatRunning","pollServerSession","stop","clearScheduledHeartBeat","serverStateChanged","getExistingIframe","init","now","authWellKnownEndPoints","existingIframe","getOrCreateIframe","checkSessionIframe","contentWindow","location","observer","onload","complete","pollServerSessionRecur","subscribe","sessionState","iframeOrigin","URL","origin","postMessage","runOutsideAngular","setTimeout","run","clearTimeout","messageHandler","existingIFrame","startsWith","source","data","CheckSessionReceived","bindMessageEventToIframe","iframeMessageEvent","bind","addEventListener","frame","NgZone","CurrentUrlService","getStateParamFromCurrentUrl","currentUrl","getCurrentUrl","parsedUrl","urlParams","URLSearchParams","search","stateFromUrl","currentUrlHasStateParam","ValidationResult","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","RandomService","createRandom","requiredLength","arr","getRandomValues","toHex","randomString","dec","characters","values","Uint32Array","i","FlowsDataService","randomService","createNonce","setNonce","getAuthStateControl","setAuthStateControl","authStateControl","getExistingOrCreateAuthStateControl","setSessionState","getCodeVerifier","createCodeVerifier","isCodeFlowInProgress","storageObject","getCodeFlowInProgressStorageEntry","setCodeFlowInProgress","resetCodeFlowInProgress","storageEntry","isSilentRenewRunning","silentRenewTimeoutInSeconds","getSilentRenewRunningStorageEntry","timeOutInMilliseconds","dateOfLaunchedProcessUtc","currentDateUtc","toISOString","elapsedTimeInMilliseconds","abs","isProbablyStuck","resetSilentRenewRunning","setSilentRenewRunning","FlowHelper","isCurrentFlowCodeFlow","currentFlowIs","isCurrentFlowAnyImplicitFlow","isCurrentFlowImplicitFlowWithAccessToken","isCurrentFlowImplicitFlowWithoutAccessToken","isCurrentFlowCodeFlowWithRefreshTokens","useRefreshToken","flowTypes","responseType","some","CALLBACK_PARAMS_TO_CHECK","AUTH0_ENDPOINT","UrlService","flowsDataService","flowHelper","getUrlParameter","urlToCheck","regex","RegExp","results","exec","isCallbackFromSts","getRefreshSessionSilentRenewUrl","customParams","createUrlCodeFlowWithSilentRenew","createUrlImplicitFlowWithSilentRenew","getAuthorizeParUrl","requestUri","authorizationEndpoint","urlParts","authorizationUrl","existingParams","createHttpParams","append","getAuthorizeUrl","authOptions","createUrlCodeFlowAuthorize","createUrlImplicitFlowAuthorize","createEndSessionUrl","idTokenHint","customParamsEndSession","isAuth0Endpoint","composeAuth0Endpoint","endSessionEndpoint","authorizationEndSessionUrl","postLogoutRedirectUri","getPostLogoutRedirectUrl","appendCustomParams","createRevocationEndpointBodyAccessToken","getClientId","createRevocationEndpointBodyRefreshToken","getRevocationEndpointUrl","revocationEndpoint","revocationEndpointUrl","createBodyForCodeFlowCodeRequest","code","customTokenParams","disablePkce","silentRenewUrl","getSilentRenewUrl","redirectUrl","getRedirectUrl","createBodyForCodeFlowRefreshTokensRequest","customParamsRefresh","createBodyForParCodeFlowRequest","customParamsRequest","codeChallenge","scope","hdParam","customParamsAuthRequest","createAuthorizeUrl","prompt","customRequestParams","mergedParams","overWriteParam","getCodeChallenge","entries","fromString","encoder","authority","endsWith","postLogoutRedirectUrl","CodeFlowCallbackHandlerService","urlService","dataService","codeFlowCallback","initialCallbackContext","isRenewProcess","jwtKeys","validationResult","existingIdToken","codeFlowCodeRequest","callbackContext","isStateCorrect","authWellknownEndpoints","tokenEndpoint","bodyForCodeFlow","customParamsCodeRequest","response","session_state","error","handleRefreshRetry","errorMessage","errors","ProgressEvent","refreshTokenRetryInSeconds","DEFAULT_USERRESULT","userData","allUserData","UserService","oidcDataService","userDataInternal$","userData$","getAndPersistUserDataInStore","currentConfiguration","existingUserDataFromStorage","getUserDataFromStore","haveUserData","setUserDataToStore","renewUserInfoAfterTokenRenew","getUserDataOidcFlowAndSave","sub","publishUserDataIfExists","fireUserDataEvent","resetUserDataInStore","idTokenSub","getIdentityUserData","validateUserDataSubIdToken","userInfoEndpoint","userDataSub","passedUserData","composeSingleOrMultipleUserDataObject","UserDataChanged","hasManyConfigs","composeSingleUserDataResult","currentConfigIsToUpdate","alreadySavedUserData","ResetAuthDataService","authStateService","userService","resetAuthorizationData","ImplicitFlowCallbackHandlerService","resetAuthDataService","implicitFlowCallback","isRenewProcessData","reduce","resultData","item","shift","SigninKeyDataService","getSigningKeys","jwksUri","handleErrorGetSigningKeys","errorResponse","errMsg","status","statusText","JWT_KEYS","HistoryJwtKeysCallbackHandlerService","signInKeyDataService","callbackHistoryAndResetJwtKeys","historyCleanUpTurnedOn","resetBrowserHistory","handleResultErrorFromCallback","storeSigningKeys","storedJwtKeys","readSigningKeys","SecureTokenServerError","LoginRequired","historyCleanupOff","history","replaceState","pathname","UserCallbackHandlerService","callbackUser","autoUserInfo","publishAuthState","publishUnauthenticatedState","stateValidationResult","StateValidationResult","authResponseIsValid","at_hash","NotSet","EqualityService","isStringEqualOrNonOrderedArrayEqual","value1","value2","isNullOrUndefined","oneValueIsStringAndTheOtherIsArray","bothValuesAreStrings","arraysHaveEqualContent","areEqual","bothValuesAreArrays","arraysStrictEqual","bothValuesAreObjects","valueIsString","valueIsObject","arr1","arr2","v","val","StateValidationService","equalityService","getValidatedStateResult","validateState","toReturn","StatesDoNotMatch","handleUnsuccessfulValidation","access_token","issValidationOff","maxIdTokenIatOffsetAllowedInSeconds","isSignatureIdTokenValid","SignatureFailed","authNonce","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","issuer","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","IncorrectAzp","isIdTokenAfterRefreshTokenRequestValid","IncorrectIdTokenClaimsAfterRefresh","validateDefault","Ok","handleSuccessfulValidation","idTokenHeader","valid","IncorrectAtHash","newIdToken","disableRefreshIdTokenAuthTimeValidation","auth_time","autoCleanStateAfterAuthentication","StateValidationCallbackHandlerService","stateValidationService","callbackStateValidation","publishUnauthorizedState","RefreshSessionCallbackHandlerService","refreshSessionWithRefreshTokens","stateData","RefreshTokenCallbackHandlerService","refreshTokensRequestTokens","FlowsService","codeFlowCallbackHandlerService","implicitFlowCallbackHandlerService","historyJwtKeysCallbackHandlerService","userHandlerService","stateValidationCallbackHandlerService","refreshSessionCallbackHandlerService","refreshTokenCallbackHandlerService","processCodeFlowCallback","processSilentRenewCodeFlowCallback","firstContext","processImplicitFlowCallback","processRefreshToken","IntervalService","runTokenValidationRunning","isTokenValidationRunning","stopPeriodicTokenCheck","unsubscribe","startPeriodicTokenCheck","repeatAfterSeconds","millisecondsDelayBetweenTokenCheck","subscriber","intervalId","setInterval","clearInterval","providedIn","ImplicitFlowCallbackService","flowsService","router","intervalService","authenticatedImplicitFlowCallback","triggerAuthorizationResultEvent","postLoginRoute","unauthorizedRoute","navigateByUrl","Router","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","SilentRenewService","implicitFlowCallbackService","refreshSessionWithIFrameCompletedInternal$","refreshSessionWithIFrameCompleted$","isSilentRenewConfigured","silentRenew","codeFlowCallbackSilentRenewIframe","silentRenewEventHandler","detail","callback$","isCodeFlow","CodeFlowCallbackService","authenticatedCallbackWithCode","CallbackService","codeFlowCallbackService","stsCallbackInternal$","stsCallback$","isCallback","handleCallbackAndFireEvents","currentCallbackUrl","substring","WELL_KNOWN_SUFFIX","AuthWellKnownDataService","getWellKnownEndPointsForConfig","authWellknownEndpointUrl","getWellKnownDocument","wellKnownEndpoints","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspectionEndpoint","introspection_endpoint","parEndpoint","pushed_authorization_request_endpoint","wellKnownEndpoint","AuthWellKnownService","storeWellKnownEndpoints","mappedWellKnownEndpoints","queryAndStoreAuthWellKnownEndPoints","alreadySavedWellKnownEndpoints","ConfigLoadingFailed","RefreshSessionIframeService","silentRenewService","rendererFactory","renderer","createRenderer","refreshSessionWithIframe","sendAuthorizeRequestUsingSilentRenew","initSilentRenewRequest","onLoadHandler","removeEventListener","instanceId","random","initDestroyHandler","listen","renewDestroyHandler","dispatchEvent","CustomEvent","RendererFactory2","RefreshSessionRefreshTokenService","MAX_RETRY_ATTEMPTS","RefreshSessionService","authWellKnownService","refreshSessionIframeService","refreshSessionRefreshTokenService","userForceRefreshSession","extraCustomParams","persistCustomParams","forceRefreshSession","customParamsRefreshTokenRequest","startRefreshSession","timeOutTime","timeoutRetryStrategy","_","shouldBeExecuted","errorAttempts","scalingDuration","currentAttempt","DEFAULT_CONFIG","usePushedAuthorisationRequests","forbiddenRoute","customParamsEndSessionRequest","tokenRefreshInSeconds","POSITIVE_VALIDATION_RESULT","messages","level","ensureAuthority","passedConfig","ensureClientId","createIdentifierToCheck","arrayHasDuplicates","array","Set","size","ensureNoDuplicatedConfigsRule","passedConfigs","allIdentifiers","someAreNull","hasDuplicates","ensureRedirectRule","ensureSilentRenewUrlWhenNoRefreshTokenUsed","usesSilentRenew","usesRefreshToken","hasSilentRenewUrl","useOfflineScopeWithSilentRenew","hasRefreshToken","hasSilentRenew","hasOfflineScope","allRules","allMultipleConfigRules","ConfigValidationService","validateConfigs","validateConfigsInternal","validateConfig","validateConfigInternal","allRulesToUse","allValidationResults","rule","overallErrorCount","forEach","errorCount","processValidationResultsAndGetErrorCount","allMessages","allErrorMessages","getAllMessagesOfType","allWarnings","acc","concat","PlatformProvider","platformId","isBrowser","OpenIdConfigLoader","StsConfigLoader","StsConfigStaticLoader","loadConfigs","StsConfigHttpLoader","configs$","singleConfigOrArray","ConfigurationService","configValidationService","platformProvider","loader","configsInternal","getAllConfigurations","getOpenIDConfiguration","configsAlreadySaved","getConfig","getOpenIDConfigurations","prepareAndSaveConfigs","allPreparedConfigs","hasAtLeastOneConfig","saveConfig","readyConfig","createUniqueIds","allHandleConfigs$","handleConfig","usedConfig","prepareConfig","configWithAuthWellKnown","enhanceConfigWithWellKnownEndpoint","ConfigLoaded","alreadyExistingAuthWellKnownEndpoints","passedAuthWellKnownEndpoints","openIdConfigurationInternal","setSpecialCases","PeriodicallyTokenCheckService","configurationService","startTokenValidationPeriodically","configsWithSilentRenewEnabled","getConfigsWithSilentRenewEnabled","refreshTimeInSeconds","getSmallestRefreshTimeFromConfigs","periodicallyCheck$","objectWithConfigIdsAndRefreshEvent","getRefreshEvent","objectWithConfigIds","shouldStartRefreshEvent","shouldStartPeriodicallyCheckForConfig","refreshEvent$","createRefreshEventForConfig","SilentRenewStarted","refreshEventWithErrorHandler$","prev","curr","isCodeFlowinProgress","userDataFromStore","idTokenStillValid","accessTokenHasExpired","PopUpService","STORAGE_IDENTIFIER","resultInternal$","result$","windowInternal","isCurrentlyInPopup","canAccessSessionStorage","popup","sessionStorage","getItem","opener","openPopUp","popupOptions","optionsToPass","getOptions","popUp","open","setItem","listener","event","cleanUp","userClosed","receivedUrl","handle","closed","sendMessageToMainWindow","href","sendMessage","removeItem","close","popupDefaultOptions","width","height","left","top","options","screenLeft","outerWidth","screenTop","outerHeight","cookieEnabled","STORAGE_KEY","AutoLoginService","storageService","checkSavedRedirectRouteAndNavigate","savedRouteForRedirect","getStoredRedirectRoute","deleteStoredRedirectRoute","saveRedirectRoute","CheckAuthService","checkSessionService","currentUrlService","callbackService","refreshSessionService","periodicallyTokenCheckService","popupService","autoLoginService","checkAuth","CheckingAuth","stateParamFromUrl","getConfigurationWithUrlState","checkAuthWithConfig","checkAuthMultiple","composeMultipleLoginResults","configs","allChecks$","checkAuthIncludingServer","loginResponse","loginResponseAfterRefreshSession","startCheckSessionAndValidation","CheckingAuthFinished","CheckingAuthFinishedWithError","configurations","storedState","activeConfig","allOtherConfigs","currentConfigResult","allOtherConfigResults","ClosestMatchingRouteService","getConfigIdForClosestMatchingRoute","route","secureRoutes","configuredRoute","matchingRoute","matchingConfig","ConsoleLoggerService","console","warn","debug","ResponseTypeValidationService","hasConfigValidResponseType","RedirectService","redirectTo","ParService","postParRequest","authWellKnownEndpoints","expiresIn","request_uri","ParLoginService","responseTypeValidationService","redirectService","checkAuthService","parService","loginPar","urlHandler","loginWithPopUpPar","PopUpLoginService","loginWithPopUpStandard","authUrl","StandardLoginService","loginStandard","LoginService","parLoginService","popUpLoginService","standardLoginService","login","loginWithPopUp","LogoffRevocationService","logoff","endSessionUrl","getEndSessionUrl","logoffLocal","logoffLocalMultiple","logoffAndRevokeTokens","revokeRefreshToken","revokeAccessToken","accessTok","sendRevokeRequest","refreshTok","OidcSecurityService","logoffRevocationService","loginService","isLoading","finishLoading","finishLoadingOnError","isAuthenticated$","isLoading$","preloadAuthWellKnownDocument","getConfigurations","getConfiguration","getUserData","getPayloadFromIdToken","setState","getState","authorize","authorizeWithPopUp","DefaultSessionStorageService","createStaticLoader","PASSED_CONFIG","AuthModule","forRoot","ngModule","providers","provide","useValue","useFactory","deps","useClass","ɵmod","ɵinj","imports","declarations","exports","AutoLoginAllRoutesGuard","canLoad","getCurrentNavigation","extractedUrl","canActivate","canActivateChild","allconfigs","AutoLoginPartialRoutesGuard","AuthInterceptor","closestMatchingRouteService","intercept","req","allConfigurations","allRoutesConfigured","allRoutesConfiguredFlat","clone"],"sources":["/home/remi/EUROGATE/rMbServiceMessage/message-service/node_modules/angular-auth-oidc-client/fesm2020/angular-auth-oidc-client.mjs"],"sourcesContent":["import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HttpErrorResponse, HttpResponse, HttpClientModule } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, PLATFORM_ID, InjectionToken, NgModule } from '@angular/core';\nimport { ReplaySubject, from, of, BehaviorSubject, Observable, throwError, timer, Subject, forkJoin, TimeoutError } from 'rxjs';\nimport { map, mergeMap, tap, distinctUntilChanged, take, switchMap, retryWhen, catchError, retry, concatMap, timeout } from 'rxjs/operators';\nimport { base64url } from 'rfc4648';\nimport * as i2 from '@angular/router';\n\nclass HttpBaseService {\r\n    constructor(http) {\r\n        this.http = http;\r\n    }\r\n    get(url, params) {\r\n        return this.http.get(url, params);\r\n    }\r\n    post(url, body, params) {\r\n        return this.http.post(url, body, params);\r\n    }\r\n}\r\nHttpBaseService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: HttpBaseService, deps: [{ token: i1.HttpClient }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHttpBaseService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: HttpBaseService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: HttpBaseService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpClient }]; } });\n\nconst NGSW_CUSTOM_PARAM = 'ngsw-bypass';\r\nclass DataService {\r\n    constructor(httpClient) {\r\n        this.httpClient = httpClient;\r\n    }\r\n    get(url, config, token) {\r\n        const headers = this.prepareHeaders(token);\r\n        const params = this.prepareParams(config);\r\n        return this.httpClient.get(url, {\r\n            headers,\r\n            params,\r\n        });\r\n    }\r\n    post(url, body, config, headersParams) {\r\n        const headers = headersParams || this.prepareHeaders();\r\n        const params = this.prepareParams(config);\r\n        return this.httpClient.post(url, body, { headers, params });\r\n    }\r\n    prepareHeaders(token) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Accept', 'application/json');\r\n        if (!!token) {\r\n            headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\r\n        }\r\n        return headers;\r\n    }\r\n    prepareParams(config) {\r\n        let params = new HttpParams();\r\n        const { ngswBypass } = config;\r\n        if (ngswBypass) {\r\n            params = params.set(NGSW_CUSTOM_PARAM, '');\r\n        }\r\n        return params;\r\n    }\r\n}\r\nDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DataService, deps: [{ token: HttpBaseService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: HttpBaseService }]; } });\n\n// eslint-disable-next-line no-shadow\r\nvar EventTypes;\r\n(function (EventTypes) {\r\n    /**\r\n     *  This only works in the AppModule Constructor\r\n     */\r\n    EventTypes[EventTypes[\"ConfigLoaded\"] = 0] = \"ConfigLoaded\";\r\n    EventTypes[EventTypes[\"CheckingAuth\"] = 1] = \"CheckingAuth\";\r\n    EventTypes[EventTypes[\"CheckingAuthFinished\"] = 2] = \"CheckingAuthFinished\";\r\n    EventTypes[EventTypes[\"CheckingAuthFinishedWithError\"] = 3] = \"CheckingAuthFinishedWithError\";\r\n    EventTypes[EventTypes[\"ConfigLoadingFailed\"] = 4] = \"ConfigLoadingFailed\";\r\n    EventTypes[EventTypes[\"CheckSessionReceived\"] = 5] = \"CheckSessionReceived\";\r\n    EventTypes[EventTypes[\"UserDataChanged\"] = 6] = \"UserDataChanged\";\r\n    EventTypes[EventTypes[\"NewAuthenticationResult\"] = 7] = \"NewAuthenticationResult\";\r\n    EventTypes[EventTypes[\"TokenExpired\"] = 8] = \"TokenExpired\";\r\n    EventTypes[EventTypes[\"IdTokenExpired\"] = 9] = \"IdTokenExpired\";\r\n    EventTypes[EventTypes[\"SilentRenewStarted\"] = 10] = \"SilentRenewStarted\";\r\n})(EventTypes || (EventTypes = {}));\n\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"None\"] = 0] = \"None\";\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    LogLevel[LogLevel[\"Warn\"] = 2] = \"Warn\";\r\n    LogLevel[LogLevel[\"Error\"] = 3] = \"Error\";\r\n})(LogLevel || (LogLevel = {}));\n\n/**\r\n * Implement this class-interface to create a custom logger service.\r\n */\r\nclass AbstractLoggerService {\r\n}\r\nAbstractLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AbstractLoggerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AbstractLoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AbstractLoggerService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass LoggerService {\r\n    constructor(abstractLoggerService) {\r\n        this.abstractLoggerService = abstractLoggerService;\r\n    }\r\n    logError(configuration, message, ...args) {\r\n        if (this.loggingIsTurnedOff(configuration)) {\r\n            return;\r\n        }\r\n        const { configId } = configuration;\r\n        const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\r\n        if (!!args && !!args.length) {\r\n            this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`, ...args);\r\n        }\r\n        else {\r\n            this.abstractLoggerService.logError(`[ERROR] ${configId} - ${messageToLog}`);\r\n        }\r\n    }\r\n    logWarning(configuration, message, ...args) {\r\n        if (!this.logLevelIsSet(configuration)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configuration)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Warn)) {\r\n            return;\r\n        }\r\n        const { configId } = configuration;\r\n        const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\r\n        if (!!args && !!args.length) {\r\n            this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`, ...args);\r\n        }\r\n        else {\r\n            this.abstractLoggerService.logWarning(`[WARN] ${configId} - ${messageToLog}`);\r\n        }\r\n    }\r\n    logDebug(configuration, message, ...args) {\r\n        if (!this.logLevelIsSet(configuration)) {\r\n            return;\r\n        }\r\n        if (this.loggingIsTurnedOff(configuration)) {\r\n            return;\r\n        }\r\n        if (!this.currentLogLevelIsEqualOrSmallerThan(configuration, LogLevel.Debug)) {\r\n            return;\r\n        }\r\n        const { configId } = configuration;\r\n        const messageToLog = this.isObject(message) ? JSON.stringify(message) : message;\r\n        if (!!args && !!args.length) {\r\n            this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`, ...args);\r\n        }\r\n        else {\r\n            this.abstractLoggerService.logDebug(`[DEBUG] ${configId} - ${messageToLog}`);\r\n        }\r\n    }\r\n    currentLogLevelIsEqualOrSmallerThan(configuration, logLevelToCompare) {\r\n        const { logLevel } = configuration || {};\r\n        return logLevel <= logLevelToCompare;\r\n    }\r\n    logLevelIsSet(configuration) {\r\n        const { logLevel } = configuration || {};\r\n        if (logLevel === null) {\r\n            return false;\r\n        }\r\n        if (logLevel === undefined) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    loggingIsTurnedOff(configuration) {\r\n        const { logLevel } = configuration || {};\r\n        return logLevel === LogLevel.None;\r\n    }\r\n    isObject(possibleObject) {\r\n        return Object.prototype.toString.call(possibleObject) === '[object Object]';\r\n    }\r\n}\r\nLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LoggerService, deps: [{ token: AbstractLoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LoggerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AbstractLoggerService }]; } });\n\n/**\r\n * Implement this class-interface to create a custom storage.\r\n */\r\nclass AbstractSecurityStorage {\r\n}\r\nAbstractSecurityStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AbstractSecurityStorage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nAbstractSecurityStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AbstractSecurityStorage });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AbstractSecurityStorage, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass BrowserStorageService {\r\n    constructor(loggerService, abstractSecurityStorage) {\r\n        this.loggerService = loggerService;\r\n        this.abstractSecurityStorage = abstractSecurityStorage;\r\n    }\r\n    read(key, configuration) {\r\n        const { configId } = configuration;\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to read '${key}' but Storage was undefined`);\r\n            return null;\r\n        }\r\n        const storedConfig = this.abstractSecurityStorage.read(configId);\r\n        if (!storedConfig) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storedConfig);\r\n    }\r\n    write(value, configuration) {\r\n        const { configId } = configuration;\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to write '${value}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        value = value || null;\r\n        this.abstractSecurityStorage.write(configId, JSON.stringify(value));\r\n        return true;\r\n    }\r\n    remove(key, configuration) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to remove '${key}' but Storage was falsy`);\r\n            return false;\r\n        }\r\n        // const storage = this.getStorage(configuration);\r\n        // if (!storage) {\r\n        //   this.loggerService.logDebug(configuration, `Wanted to write '${key}' but Storage was falsy`);\r\n        //   return false;\r\n        // }\r\n        this.abstractSecurityStorage.remove(key);\r\n        return true;\r\n    }\r\n    // TODO THIS STORAGE WANTS AN ID BUT CLEARS EVERYTHING\r\n    clear(configuration) {\r\n        if (!this.hasStorage()) {\r\n            this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\r\n            return false;\r\n        }\r\n        // const storage = this.getStorage(configuration);\r\n        // if (!storage) {\r\n        //   this.loggerService.logDebug(configuration, `Wanted to clear storage but Storage was falsy`);\r\n        //   return false;\r\n        // }\r\n        this.abstractSecurityStorage.clear();\r\n        return true;\r\n    }\r\n    hasStorage() {\r\n        return typeof Storage !== 'undefined';\r\n    }\r\n}\r\nBrowserStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: BrowserStorageService, deps: [{ token: LoggerService }, { token: AbstractSecurityStorage }], target: i0.ɵɵFactoryTarget.Injectable });\r\nBrowserStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: BrowserStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: BrowserStorageService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AbstractSecurityStorage }]; } });\n\nclass StoragePersistenceService {\r\n    constructor(browserStorageService) {\r\n        this.browserStorageService = browserStorageService;\r\n    }\r\n    read(key, config) {\r\n        const storedConfig = this.browserStorageService.read(key, config) || {};\r\n        return storedConfig[key];\r\n    }\r\n    write(key, value, config) {\r\n        const storedConfig = this.browserStorageService.read(key, config) || {};\r\n        storedConfig[key] = value;\r\n        return this.browserStorageService.write(storedConfig, config);\r\n    }\r\n    remove(key, config) {\r\n        const storedConfig = this.browserStorageService.read(key, config) || {};\r\n        delete storedConfig[key];\r\n        this.browserStorageService.write(storedConfig, config);\r\n    }\r\n    clear(config) {\r\n        this.browserStorageService.clear(config);\r\n    }\r\n    resetStorageFlowData(config) {\r\n        this.remove('session_state', config);\r\n        this.remove('storageSilentRenewRunning', config);\r\n        this.remove('storageCodeFlowInProgress', config);\r\n        this.remove('codeVerifier', config);\r\n        this.remove('userData', config);\r\n        this.remove('storageCustomParamsAuthRequest', config);\r\n        this.remove('access_token_expires_at', config);\r\n        this.remove('storageCustomParamsRefresh', config);\r\n        this.remove('storageCustomParamsEndSession', config);\r\n        this.remove('reusable_refresh_token', config);\r\n    }\r\n    resetAuthStateInStorage(config) {\r\n        this.remove('authzData', config);\r\n        this.remove('reusable_refresh_token', config);\r\n        this.remove('authnResult', config);\r\n    }\r\n    getAccessToken(config) {\r\n        return this.read('authzData', config);\r\n    }\r\n    getIdToken(config) {\r\n        return this.read('authnResult', config)?.id_token;\r\n    }\r\n    getRefreshToken(config) {\r\n        let refreshToken = this.read('authnResult', config)?.refresh_token;\r\n        if (!refreshToken && config.allowUnsafeReuseRefreshToken) {\r\n            return this.read('reusable_refresh_token', config);\r\n        }\r\n        return refreshToken;\r\n    }\r\n    getAuthenticationResult(config) {\r\n        return this.read('authnResult', config);\r\n    }\r\n}\r\nStoragePersistenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StoragePersistenceService, deps: [{ token: BrowserStorageService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStoragePersistenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StoragePersistenceService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StoragePersistenceService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: BrowserStorageService }]; } });\n\nclass PublicEventsService {\r\n    constructor() {\r\n        this.notify = new ReplaySubject(1);\r\n    }\r\n    /**\r\n     * Fires a new event.\r\n     *\r\n     * @param type The event type.\r\n     * @param value The event value.\r\n     */\r\n    fireEvent(type, value) {\r\n        this.notify.next({ type, value });\r\n    }\r\n    /**\r\n     * Wires up the event notification observable.\r\n     */\r\n    registerForEvents() {\r\n        return this.notify.asObservable();\r\n    }\r\n}\r\nPublicEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PublicEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nPublicEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PublicEventsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PublicEventsService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst PARTS_OF_TOKEN = 3;\r\nclass TokenHelperService {\r\n    constructor(loggerService, document) {\r\n        this.loggerService = loggerService;\r\n        this.document = document;\r\n    }\r\n    getTokenExpirationDate(dataIdToken) {\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\r\n            return new Date(new Date().toUTCString());\r\n        }\r\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        date.setUTCSeconds(dataIdToken.exp);\r\n        return date;\r\n    }\r\n    getSigningInputFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return '';\r\n        }\r\n        const header = this.getHeaderFromToken(token, encoded, configuration);\r\n        const payload = this.getPayloadFromToken(token, encoded, configuration);\r\n        return [header, payload].join('.');\r\n    }\r\n    getHeaderFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 0, encoded);\r\n    }\r\n    getPayloadFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 1, encoded);\r\n    }\r\n    getSignatureFromToken(token, encoded, configuration) {\r\n        if (!this.tokenIsValid(token, configuration)) {\r\n            return {};\r\n        }\r\n        return this.getPartOfToken(token, 2, encoded);\r\n    }\r\n    getPartOfToken(token, index, encoded) {\r\n        const partOfToken = this.extractPartOfToken(token, index);\r\n        if (encoded) {\r\n            return partOfToken;\r\n        }\r\n        const result = this.urlBase64Decode(partOfToken);\r\n        return JSON.parse(result);\r\n    }\r\n    urlBase64Decode(str) {\r\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\r\n        switch (output.length % 4) {\r\n            case 0:\r\n                break;\r\n            case 2:\r\n                output += '==';\r\n                break;\r\n            case 3:\r\n                output += '=';\r\n                break;\r\n            default:\r\n                throw Error('Illegal base64url string!');\r\n        }\r\n        const decoded = typeof this.document.defaultView !== 'undefined'\r\n            ? this.document.defaultView.atob(output)\r\n            : Buffer.from(output, 'base64').toString('binary');\r\n        try {\r\n            // Going backwards: from byte stream, to percent-encoding, to original string.\r\n            return decodeURIComponent(decoded\r\n                .split('')\r\n                .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n                .join(''));\r\n        }\r\n        catch (err) {\r\n            return decoded;\r\n        }\r\n    }\r\n    tokenIsValid(token, configuration) {\r\n        if (!token) {\r\n            this.loggerService.logError(configuration, `token '${token}' is not valid --> token falsy`);\r\n            return false;\r\n        }\r\n        if (!token.includes('.')) {\r\n            this.loggerService.logError(configuration, `token '${token}' is not valid --> no dots included`);\r\n            return false;\r\n        }\r\n        const parts = token.split('.');\r\n        if (parts.length !== PARTS_OF_TOKEN) {\r\n            this.loggerService.logError(configuration, `token '${token}' is not valid --> token has to have exactly ${PARTS_OF_TOKEN - 1} dots`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    extractPartOfToken(token, index) {\r\n        return token.split('.')[index];\r\n    }\r\n}\r\nTokenHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: TokenHelperService, deps: [{ token: LoggerService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: TokenHelperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: TokenHelperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: Document, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass JwkExtractor {\r\n    static buildErrorName(name) {\r\n        return JwkExtractor.name + ': ' + name;\r\n    }\r\n    extractJwk(keys, spec, throwOnEmpty = true) {\r\n        if (0 === keys.length) {\r\n            throw JwkExtractor.InvalidArgumentError;\r\n        }\r\n        let foundKeys = keys\r\n            .filter((k) => spec?.kid ? k['kid'] === spec.kid : true)\r\n            .filter((k) => spec?.use ? k['use'] === spec.use : true)\r\n            .filter((k) => spec?.kty ? k['kty'] === spec.kty : true);\r\n        if (foundKeys.length === 0 && throwOnEmpty) {\r\n            throw JwkExtractor.NoMatchingKeysError;\r\n        }\r\n        if (foundKeys.length > 1 && (null === spec || undefined === spec)) {\r\n            throw JwkExtractor.SeveralMatchingKeysError;\r\n        }\r\n        return foundKeys;\r\n    }\r\n}\r\nJwkExtractor.InvalidArgumentError = {\r\n    name: JwkExtractor.buildErrorName('InvalidArgumentError'),\r\n    message: 'Array of keys was empty. Unable to extract'\r\n};\r\nJwkExtractor.NoMatchingKeysError = {\r\n    name: JwkExtractor.buildErrorName('NoMatchingKeysError'),\r\n    message: 'No key found matching the spec'\r\n};\r\nJwkExtractor.SeveralMatchingKeysError = {\r\n    name: JwkExtractor.buildErrorName('SeveralMatchingKeysError'),\r\n    message: 'More than one key found. Please use spec to filter'\r\n};\r\nJwkExtractor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwkExtractor, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwkExtractor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwkExtractor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwkExtractor, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass CryptoService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    getCrypto() {\r\n        // support for IE,  (window.crypto || window.msCrypto)\r\n        return this.doc.defaultView.crypto || this.doc.defaultView.msCrypto;\r\n    }\r\n}\r\nCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CryptoService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CryptoService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass JwkWindowCryptoService {\r\n    constructor(cryptoService) {\r\n        this.cryptoService = cryptoService;\r\n    }\r\n    importVerificationKey(key, algorithm) {\r\n        return this.cryptoService.getCrypto().subtle.importKey('jwk', key, algorithm, false, ['verify']);\r\n    }\r\n    verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput) {\r\n        return this.cryptoService.getCrypto().subtle.verify(verifyAlgorithm, cryptoKey, signature, new TextEncoder().encode(signingInput));\r\n    }\r\n}\r\nJwkWindowCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwkWindowCryptoService, deps: [{ token: CryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwkWindowCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwkWindowCryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwkWindowCryptoService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CryptoService }]; } });\n\nclass JwtWindowCryptoService {\r\n    constructor(cryptoService) {\r\n        this.cryptoService = cryptoService;\r\n    }\r\n    generateCodeChallenge(codeVerifier) {\r\n        return this.calcHash(codeVerifier).pipe(map((challengeRaw) => this.base64UrlEncode(challengeRaw)));\r\n    }\r\n    generateAtHash(accessToken, algorithm) {\r\n        return this.calcHash(accessToken, algorithm).pipe(map((tokenHash) => {\r\n            let substr = tokenHash.substr(0, tokenHash.length / 2);\r\n            const tokenHashBase64 = btoa(substr);\r\n            return tokenHashBase64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n        }));\r\n    }\r\n    calcHash(valueToHash, algorithm = 'SHA-256') {\r\n        const msgBuffer = new TextEncoder().encode(valueToHash);\r\n        return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map((hashBuffer) => {\r\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n            return this.toHashString(hashArray);\r\n        }));\r\n    }\r\n    toHashString(byteArray) {\r\n        let result = '';\r\n        for (let e of byteArray) {\r\n            result += String.fromCharCode(e);\r\n        }\r\n        return result;\r\n    }\r\n    base64UrlEncode(str) {\r\n        const base64 = btoa(str);\r\n        return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n    }\r\n}\r\nJwtWindowCryptoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwtWindowCryptoService, deps: [{ token: CryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nJwtWindowCryptoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwtWindowCryptoService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: JwtWindowCryptoService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CryptoService }]; } });\n\n// http://openid.net/specs/openid-connect-implicit-1_0.html\r\n// id_token\r\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n// MUST exactly match the value of the iss (issuer) Claim.\r\n//\r\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\r\n// or if it contains additional audiences not trusted by the Client.\r\n//\r\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\r\n//\r\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n//\r\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\r\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n//\r\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect\r\n// Core 1.0\r\n// [OpenID.Core] specification.\r\n//\r\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\r\n// for clock skew).\r\n//\r\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n//\r\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\r\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\r\n// is Client specific.\r\n//\r\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\r\n// The meaning and processing of acr Claim Values is out of scope for this document.\r\n//\r\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\r\n// if it determines too much time has elapsed since the last End- User authentication.\r\n// Access Token Validation\r\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present\r\n// in the ID Token.\r\nclass TokenValidationService {\r\n    constructor(tokenHelperService, loggerService, jwkExtractor, jwkWindowCryptoService, jwtWindowCryptoService, document) {\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.jwkExtractor = jwkExtractor;\r\n        this.jwkWindowCryptoService = jwkWindowCryptoService;\r\n        this.jwtWindowCryptoService = jwtWindowCryptoService;\r\n        this.document = document;\r\n        this.keyAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    hasIdTokenExpired(token, configuration, offsetSeconds, disableIdTokenValidation) {\r\n        const decoded = this.tokenHelperService.getPayloadFromToken(token, false, configuration);\r\n        return !this.validateIdTokenExpNotExpired(decoded, configuration, offsetSeconds, disableIdTokenValidation);\r\n    }\r\n    // id_token C7: The current time MUST be before the time represented by the exp Claim\r\n    // (possibly allowing for some small leeway to account for clock skew).\r\n    validateIdTokenExpNotExpired(decodedIdToken, configuration, offsetSeconds, disableIdTokenValidation) {\r\n        if (disableIdTokenValidation) {\r\n            return true;\r\n        }\r\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decodedIdToken);\r\n        offsetSeconds = offsetSeconds || 0;\r\n        if (!tokenExpirationDate) {\r\n            return false;\r\n        }\r\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\r\n        const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\r\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configuration, `Has idToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(tokenExpirationValue - nowWithOffset)} , ${new Date(tokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        return tokenNotExpired;\r\n    }\r\n    validateAccessTokenNotExpired(accessTokenExpiresAt, configuration, offsetSeconds) {\r\n        // value is optional, so if it does not exist, then it has not expired\r\n        if (!accessTokenExpiresAt) {\r\n            return true;\r\n        }\r\n        offsetSeconds = offsetSeconds || 0;\r\n        const accessTokenExpirationValue = accessTokenExpiresAt.valueOf();\r\n        const nowWithOffset = this.calculateNowWithOffset(offsetSeconds);\r\n        const tokenNotExpired = accessTokenExpirationValue > nowWithOffset;\r\n        this.loggerService.logDebug(configuration, `Has accessToken expired: ${!tokenNotExpired} --> expires in ${this.millisToMinutesAndSeconds(accessTokenExpirationValue - nowWithOffset)} , ${new Date(accessTokenExpirationValue).toLocaleTimeString()} > ${new Date(nowWithOffset).toLocaleTimeString()}`);\r\n        return tokenNotExpired;\r\n    }\r\n    // iss\r\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the\r\n    // https scheme that contains scheme, host,\r\n    // and optionally, port number and path components and no query or fragment components.\r\n    //\r\n    // sub\r\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\r\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\r\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\r\n    //\r\n    // aud\r\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an\r\n    // audience value.\r\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\r\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\r\n    //\r\n    // exp\r\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\r\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\r\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\r\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until\r\n    // the date/ time.\r\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\r\n    //\r\n    // iat\r\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from\r\n    // 1970- 01 - 01T00: 00: 00Z as measured\r\n    // in UTC until the date/ time.\r\n    validateRequiredIdToken(dataIdToken, configuration) {\r\n        let validated = true;\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iss')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'iss is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'sub')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'sub is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'aud')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'aud is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'exp')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'exp is missing, this is required in the id_token');\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\r\n            validated = false;\r\n            this.loggerService.logWarning(configuration, 'iat is missing, this is required in the id_token');\r\n        }\r\n        return validated;\r\n    }\r\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\r\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\r\n    validateIdTokenIatMaxOffset(dataIdToken, maxOffsetAllowedInSeconds, disableIatOffsetValidation, configuration) {\r\n        if (disableIatOffsetValidation) {\r\n            return true;\r\n        }\r\n        if (!Object.prototype.hasOwnProperty.call(dataIdToken, 'iat')) {\r\n            return false;\r\n        }\r\n        const dateTimeIatIdToken = new Date(0); // The 0 here is the key, which sets the date to the epoch\r\n        dateTimeIatIdToken.setUTCSeconds(dataIdToken.iat);\r\n        maxOffsetAllowedInSeconds = maxOffsetAllowedInSeconds || 0;\r\n        const nowInUtc = new Date(new Date().toUTCString());\r\n        const diff = nowInUtc.valueOf() - dateTimeIatIdToken.valueOf();\r\n        const maxOffsetAllowedInMilliseconds = maxOffsetAllowedInSeconds * 1000;\r\n        this.loggerService.logDebug(configuration, `validate id token iat max offset ${diff} < ${maxOffsetAllowedInMilliseconds}`);\r\n        if (diff > 0) {\r\n            return diff < maxOffsetAllowedInMilliseconds;\r\n        }\r\n        return -diff < maxOffsetAllowedInMilliseconds;\r\n    }\r\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\r\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\r\n    // The precise method for detecting replay attacks is Client specific.\r\n    // However the nonce claim SHOULD not be present for the refresh_token grant type\r\n    // https://bitbucket.org/openid/connect/issues/1025/ambiguity-with-how-nonce-is-handled-on\r\n    // The current spec is ambiguous and KeyCloak does send it.\r\n    validateIdTokenNonce(dataIdToken, localNonce, ignoreNonceAfterRefresh, configuration) {\r\n        const isFromRefreshToken = (dataIdToken.nonce === undefined || ignoreNonceAfterRefresh) && localNonce === TokenValidationService.refreshTokenNoncePlaceholder;\r\n        if (!isFromRefreshToken && dataIdToken.nonce !== localNonce) {\r\n            this.loggerService.logDebug(configuration, 'Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + localNonce);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\r\n    // MUST exactly match the value of the iss (issuer) Claim.\r\n    validateIdTokenIss(dataIdToken, authWellKnownEndpointsIssuer, configuration) {\r\n        if (dataIdToken.iss !== authWellKnownEndpointsIssuer) {\r\n            this.loggerService.logDebug(configuration, 'Validate_id_token_iss failed, dataIdToken.iss: ' +\r\n                dataIdToken.iss +\r\n                ' authWellKnownEndpoints issuer:' +\r\n                authWellKnownEndpointsIssuer);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\r\n    // by the iss (issuer) Claim as an audience.\r\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\r\n    // not trusted by the Client.\r\n    validateIdTokenAud(dataIdToken, aud, configuration) {\r\n        if (Array.isArray(dataIdToken.aud)) {\r\n            const result = dataIdToken.aud.includes(aud);\r\n            if (!result) {\r\n                this.loggerService.logDebug(configuration, 'Validate_id_token_aud array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        else if (dataIdToken.aud !== aud) {\r\n            this.loggerService.logDebug(configuration, 'Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateIdTokenAzpExistsIfMoreThanOneAud(dataIdToken) {\r\n        if (!dataIdToken) {\r\n            return false;\r\n        }\r\n        if (Array.isArray(dataIdToken.aud) && dataIdToken.aud.length > 1 && !dataIdToken.azp) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\r\n    validateIdTokenAzpValid(dataIdToken, clientId) {\r\n        if (!dataIdToken?.azp) {\r\n            return true;\r\n        }\r\n        if (dataIdToken.azp === clientId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    validateStateFromHashCallback(state, localState, configuration) {\r\n        if (state !== localState) {\r\n            this.loggerService.logDebug(configuration, 'ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + localState);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\r\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\r\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\r\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\r\n    validateSignatureIdToken(idToken, jwtkeys, configuration) {\r\n        if (!jwtkeys || !jwtkeys.keys) {\r\n            return of(false);\r\n        }\r\n        const headerData = this.tokenHelperService.getHeaderFromToken(idToken, false, configuration);\r\n        if (Object.keys(headerData).length === 0 && headerData.constructor === Object) {\r\n            this.loggerService.logWarning(configuration, 'id token has no header data');\r\n            return of(false);\r\n        }\r\n        const kid = headerData.kid;\r\n        let alg = headerData.alg;\r\n        let keys = jwtkeys.keys;\r\n        let foundKeys;\r\n        let key;\r\n        if (!this.keyAlgorithms.includes(alg)) {\r\n            this.loggerService.logWarning(configuration, 'alg not supported', alg);\r\n            return of(false);\r\n        }\r\n        const kty = this.alg2kty(alg);\r\n        const use = 'sig';\r\n        try {\r\n            foundKeys = kid ?\r\n                this.jwkExtractor.extractJwk(keys, { kid, kty, use }, false) :\r\n                this.jwkExtractor.extractJwk(keys, { kty, use }, false);\r\n            if (foundKeys.length === 0) {\r\n                foundKeys = kid ?\r\n                    this.jwkExtractor.extractJwk(keys, { kid, kty }) :\r\n                    this.jwkExtractor.extractJwk(keys, { kty });\r\n            }\r\n            key = foundKeys[0];\r\n        }\r\n        catch (e) {\r\n            this.loggerService.logError(configuration, e);\r\n            return of(false);\r\n        }\r\n        const algorithm = this.getImportAlg(alg);\r\n        const signingInput = this.tokenHelperService.getSigningInputFromToken(idToken, true, configuration);\r\n        const rawSignature = this.tokenHelperService.getSignatureFromToken(idToken, true, configuration);\r\n        const agent = this.document.defaultView.navigator.userAgent.toLowerCase();\r\n        if (agent.indexOf('firefox') > -1 && key.kty === 'EC') {\r\n            key.alg = '';\r\n        }\r\n        return from(this.jwkWindowCryptoService.importVerificationKey(key, algorithm)).pipe(mergeMap((cryptoKey) => {\r\n            const signature = base64url.parse(rawSignature, { loose: true });\r\n            const verifyAlgorithm = this.getVerifyAlg(alg);\r\n            return from(this.jwkWindowCryptoService.verifyKey(verifyAlgorithm, cryptoKey, signature, signingInput));\r\n        }), tap((isValid) => {\r\n            if (!isValid) {\r\n                this.loggerService.logWarning(configuration, 'incorrect Signature, validation failed for id_token');\r\n            }\r\n        }));\r\n    }\r\n    getImportAlg(alg) {\r\n        switch (alg.charAt(0)) {\r\n            case 'R':\r\n                if (alg.includes('256')) {\r\n                    return {\r\n                        name: 'RSASSA-PKCS1-v1_5',\r\n                        hash: 'SHA-256',\r\n                    };\r\n                }\r\n                else if (alg.includes('384')) {\r\n                    return {\r\n                        name: 'RSASSA-PKCS1-v1_5',\r\n                        hash: 'SHA-384',\r\n                    };\r\n                }\r\n                else if (alg.includes('512')) {\r\n                    return {\r\n                        name: 'RSASSA-PKCS1-v1_5',\r\n                        hash: 'SHA-512',\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            case 'E':\r\n                if (alg.includes('256')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        namedCurve: 'P-256',\r\n                    };\r\n                }\r\n                else if (alg.includes('384')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        namedCurve: 'P-384',\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    getVerifyAlg(alg) {\r\n        switch (alg.charAt(0)) {\r\n            case 'R':\r\n                return {\r\n                    name: 'RSASSA-PKCS1-v1_5',\r\n                    hash: 'SHA-256',\r\n                };\r\n            case 'E':\r\n                if (alg.includes('256')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        hash: 'SHA-256',\r\n                    };\r\n                }\r\n                else if (alg.includes('384')) {\r\n                    return {\r\n                        name: 'ECDSA',\r\n                        hash: 'SHA-384',\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    alg2kty(alg) {\r\n        switch (alg.charAt(0)) {\r\n            case 'R':\r\n                return 'RSA';\r\n            case 'E':\r\n                return 'EC';\r\n            default:\r\n                throw new Error('Cannot infer kty from alg: ' + alg);\r\n        }\r\n    }\r\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\r\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\r\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\r\n    ////    if (!header_data.hasOwnProperty('kid')) {\r\n    ////        // no kid defined in Jose header\r\n    ////        if (jwtkeys.keys.length != 1) {\r\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\r\n    ////            return false;\r\n    ////        }\r\n    ////    }\r\n    ////    return true;\r\n    //// }\r\n    // Access Token Validation\r\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\r\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\r\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\r\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\r\n    // is present in the ID Token.\r\n    validateIdTokenAtHash(accessToken, atHash, idTokenAlg, configuration) {\r\n        this.loggerService.logDebug(configuration, 'at_hash from the server:' + atHash);\r\n        // 'sha256' 'sha384' 'sha512'\r\n        let sha = 'SHA-256';\r\n        if (idTokenAlg.includes('384')) {\r\n            sha = 'SHA-384';\r\n        }\r\n        else if (idTokenAlg.includes('512')) {\r\n            sha = 'SHA-512';\r\n        }\r\n        return this.jwtWindowCryptoService.generateAtHash('' + accessToken, sha).pipe(mergeMap((hash) => {\r\n            this.loggerService.logDebug(configuration, 'at_hash client validation not decoded:' + hash);\r\n            if (hash === atHash) {\r\n                return of(true); // isValid;\r\n            }\r\n            else {\r\n                return this.jwtWindowCryptoService.generateAtHash('' + decodeURIComponent(accessToken), sha).pipe(map((newHash) => {\r\n                    this.loggerService.logDebug(configuration, '-gen access--' + hash);\r\n                    return newHash === atHash;\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n    millisToMinutesAndSeconds(millis) {\r\n        const minutes = Math.floor(millis / 60000);\r\n        const seconds = ((millis % 60000) / 1000).toFixed(0);\r\n        return minutes + ':' + (+seconds < 10 ? '0' : '') + seconds;\r\n    }\r\n    calculateNowWithOffset(offsetSeconds) {\r\n        return new Date(new Date().toUTCString()).valueOf() + offsetSeconds * 1000;\r\n    }\r\n}\r\nTokenValidationService.refreshTokenNoncePlaceholder = '--RefreshToken--';\r\nTokenValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: TokenValidationService, deps: [{ token: TokenHelperService }, { token: LoggerService }, { token: JwkExtractor }, { token: JwkWindowCryptoService }, { token: JwtWindowCryptoService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nTokenValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: TokenValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: TokenValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: TokenHelperService }, { type: LoggerService }, { type: JwkExtractor }, { type: JwkWindowCryptoService }, { type: JwtWindowCryptoService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nconst DEFAULT_AUTHRESULT = { isAuthenticated: false, allConfigsAuthenticated: [] };\r\nclass AuthStateService {\r\n    constructor(storagePersistenceService, loggerService, publicEventsService, tokenValidationService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.authenticatedInternal$ = new BehaviorSubject(DEFAULT_AUTHRESULT);\r\n    }\r\n    get authenticated$() {\r\n        return this.authenticatedInternal$.asObservable().pipe(distinctUntilChanged());\r\n    }\r\n    setAuthenticatedAndFireEvent(allConfigs) {\r\n        const result = this.composeAuthenticatedResult(allConfigs);\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    setUnauthenticatedAndFireEvent(currentConfig, allConfigs) {\r\n        this.storagePersistenceService.resetAuthStateInStorage(currentConfig);\r\n        const result = this.composeUnAuthenticatedResult(allConfigs);\r\n        this.authenticatedInternal$.next(result);\r\n    }\r\n    updateAndPublishAuthState(authenticationResult) {\r\n        this.publicEventsService.fireEvent(EventTypes.NewAuthenticationResult, authenticationResult);\r\n    }\r\n    setAuthorizationData(accessToken, authResult, currentConfig, allConfigs) {\r\n        this.loggerService.logDebug(currentConfig, `storing the accessToken '${accessToken}'`);\r\n        this.storagePersistenceService.write('authzData', accessToken, currentConfig);\r\n        this.persistAccessTokenExpirationTime(authResult, currentConfig);\r\n        this.setAuthenticatedAndFireEvent(allConfigs);\r\n    }\r\n    getAccessToken(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getAccessToken(configuration);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getIdToken(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getIdToken(configuration);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getRefreshToken(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        const token = this.storagePersistenceService.getRefreshToken(configuration);\r\n        return this.decodeURIComponentSafely(token);\r\n    }\r\n    getAuthenticationResult(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return null;\r\n        }\r\n        return this.storagePersistenceService.getAuthenticationResult(configuration);\r\n    }\r\n    areAuthStorageTokensValid(configuration) {\r\n        if (!this.isAuthenticated(configuration)) {\r\n            return false;\r\n        }\r\n        if (this.hasIdTokenExpiredAndRenewCheckIsEnabled(configuration)) {\r\n            this.loggerService.logDebug(configuration, 'persisted idToken is expired');\r\n            return false;\r\n        }\r\n        if (this.hasAccessTokenExpiredIfExpiryExists(configuration)) {\r\n            this.loggerService.logDebug(configuration, 'persisted accessToken is expired');\r\n            return false;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'persisted idToken and accessToken are valid');\r\n        return true;\r\n    }\r\n    hasIdTokenExpiredAndRenewCheckIsEnabled(configuration) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds, enableIdTokenExpiredValidationInRenew, disableIdTokenValidation } = configuration;\r\n        if (!enableIdTokenExpiredValidationInRenew) {\r\n            return false;\r\n        }\r\n        const tokenToCheck = this.storagePersistenceService.getIdToken(configuration);\r\n        const idTokenExpired = this.tokenValidationService.hasIdTokenExpired(tokenToCheck, configuration, renewTimeBeforeTokenExpiresInSeconds, disableIdTokenValidation);\r\n        if (idTokenExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.IdTokenExpired, idTokenExpired);\r\n        }\r\n        return idTokenExpired;\r\n    }\r\n    hasAccessTokenExpiredIfExpiryExists(configuration) {\r\n        const { renewTimeBeforeTokenExpiresInSeconds } = configuration;\r\n        const accessTokenExpiresIn = this.storagePersistenceService.read('access_token_expires_at', configuration);\r\n        const accessTokenHasNotExpired = this.tokenValidationService.validateAccessTokenNotExpired(accessTokenExpiresIn, configuration, renewTimeBeforeTokenExpiresInSeconds);\r\n        const hasExpired = !accessTokenHasNotExpired;\r\n        if (hasExpired) {\r\n            this.publicEventsService.fireEvent(EventTypes.TokenExpired, hasExpired);\r\n        }\r\n        return hasExpired;\r\n    }\r\n    isAuthenticated(configuration) {\r\n        const hasAccessToken = !!this.storagePersistenceService.getAccessToken(configuration);\r\n        const hasIdToken = !!this.storagePersistenceService.getIdToken(configuration);\r\n        return hasAccessToken && hasIdToken;\r\n    }\r\n    decodeURIComponentSafely(token) {\r\n        if (token) {\r\n            return decodeURIComponent(token);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    persistAccessTokenExpirationTime(authResult, configuration) {\r\n        if (authResult?.expires_in) {\r\n            const accessTokenExpiryTime = new Date(new Date().toUTCString()).valueOf() + authResult.expires_in * 1000;\r\n            this.storagePersistenceService.write('access_token_expires_at', accessTokenExpiryTime, configuration);\r\n        }\r\n    }\r\n    composeAuthenticatedResult(allConfigs) {\r\n        if (allConfigs.length === 1) {\r\n            const { configId } = allConfigs[0];\r\n            return { isAuthenticated: true, allConfigsAuthenticated: [{ configId, isAuthenticated: true }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\r\n    }\r\n    composeUnAuthenticatedResult(allConfigs) {\r\n        if (allConfigs.length === 1) {\r\n            const { configId } = allConfigs[0];\r\n            return { isAuthenticated: false, allConfigsAuthenticated: [{ configId, isAuthenticated: false }] };\r\n        }\r\n        return this.checkAllConfigsIfTheyAreAuthenticated(allConfigs);\r\n    }\r\n    checkAllConfigsIfTheyAreAuthenticated(allConfigs) {\r\n        const allConfigsAuthenticated = allConfigs.map((config) => ({\r\n            configId: config.configId,\r\n            isAuthenticated: this.isAuthenticated(config),\r\n        }));\r\n        const isAuthenticated = allConfigsAuthenticated.every((x) => !!x.isAuthenticated);\r\n        return { allConfigsAuthenticated, isAuthenticated };\r\n    }\r\n}\r\nAuthStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthStateService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: PublicEventsService }, { token: TokenValidationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthStateService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthStateService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: PublicEventsService }, { type: TokenValidationService }]; } });\n\nclass IFrameService {\r\n    constructor(doc, loggerService) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getExistingIFrame(identifier) {\r\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnParent)) {\r\n            return iFrameOnParent;\r\n        }\r\n        const iFrameOnSelf = this.getIFrameFromWindow(identifier);\r\n        if (this.isIFrameElement(iFrameOnSelf)) {\r\n            return iFrameOnSelf;\r\n        }\r\n        return null;\r\n    }\r\n    addIFrameToWindowBody(identifier, config) {\r\n        const sessionIframe = this.doc.createElement('iframe');\r\n        sessionIframe.id = identifier;\r\n        sessionIframe.title = identifier;\r\n        this.loggerService.logDebug(config, sessionIframe);\r\n        sessionIframe.style.display = 'none';\r\n        this.doc.body.appendChild(sessionIframe);\r\n        return sessionIframe;\r\n    }\r\n    getIFrameFromParentWindow(identifier) {\r\n        try {\r\n            const iFrameElement = this.doc.defaultView.parent.document.getElementById(identifier);\r\n            if (this.isIFrameElement(iFrameElement)) {\r\n                return iFrameElement;\r\n            }\r\n            return null;\r\n        }\r\n        catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    getIFrameFromWindow(identifier) {\r\n        const iFrameElement = this.doc.getElementById(identifier);\r\n        if (this.isIFrameElement(iFrameElement)) {\r\n            return iFrameElement;\r\n        }\r\n        return null;\r\n    }\r\n    isIFrameElement(element) {\r\n        return !!element && element instanceof HTMLIFrameElement;\r\n    }\r\n}\r\nIFrameService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: IFrameService, deps: [{ token: DOCUMENT }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIFrameService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: IFrameService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: IFrameService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }]; } });\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\r\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\r\nclass CheckSessionService {\r\n    constructor(storagePersistenceService, loggerService, iFrameService, eventService, zone, document) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.iFrameService = iFrameService;\r\n        this.eventService = eventService;\r\n        this.zone = zone;\r\n        this.document = document;\r\n        this.checkSessionReceived = false;\r\n        this.lastIFrameRefresh = 0;\r\n        this.outstandingMessages = 0;\r\n        this.heartBeatInterval = 3000;\r\n        this.iframeRefreshInterval = 60000;\r\n        this.checkSessionChangedInternal$ = new BehaviorSubject(false);\r\n    }\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionChangedInternal$.asObservable();\r\n    }\r\n    isCheckSessionConfigured(configuration) {\r\n        const { startCheckSession } = configuration;\r\n        return startCheckSession;\r\n    }\r\n    start(configuration) {\r\n        if (!!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        const { clientId } = configuration;\r\n        this.pollServerSession(clientId, configuration);\r\n    }\r\n    stop() {\r\n        if (!this.scheduledHeartBeatRunning) {\r\n            return;\r\n        }\r\n        this.clearScheduledHeartBeat();\r\n        this.checkSessionReceived = false;\r\n    }\r\n    serverStateChanged(configuration) {\r\n        const { startCheckSession } = configuration;\r\n        return startCheckSession && this.checkSessionReceived;\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\r\n    }\r\n    init(configuration) {\r\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\r\n            return of(undefined);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(configuration, 'CheckSession - init check session: authWellKnownEndpoints is undefined. Returning.');\r\n            return of();\r\n        }\r\n        const existingIframe = this.getOrCreateIframe(configuration);\r\n        const checkSessionIframe = authWellKnownEndPoints.checkSessionIframe;\r\n        if (checkSessionIframe) {\r\n            existingIframe.contentWindow.location.replace(checkSessionIframe);\r\n        }\r\n        else {\r\n            this.loggerService.logWarning(configuration, 'CheckSession - init check session: checkSessionIframe is not configured to run');\r\n        }\r\n        return new Observable((observer) => {\r\n            existingIframe.onload = () => {\r\n                this.lastIFrameRefresh = Date.now();\r\n                observer.next();\r\n                observer.complete();\r\n            };\r\n        });\r\n    }\r\n    pollServerSession(clientId, configuration) {\r\n        this.outstandingMessages = 0;\r\n        const pollServerSessionRecur = () => {\r\n            this.init(configuration)\r\n                .pipe(take(1))\r\n                .subscribe(() => {\r\n                const existingIframe = this.getExistingIframe();\r\n                if (existingIframe && clientId) {\r\n                    this.loggerService.logDebug(configuration, `CheckSession - clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                    const sessionState = this.storagePersistenceService.read('session_state', configuration);\r\n                    const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n                    if (sessionState && authWellKnownEndPoints?.checkSessionIframe) {\r\n                        const iframeOrigin = new URL(authWellKnownEndPoints.checkSessionIframe)?.origin;\r\n                        this.outstandingMessages++;\r\n                        existingIframe.contentWindow.postMessage(clientId + ' ' + sessionState, iframeOrigin);\r\n                    }\r\n                    else {\r\n                        this.loggerService.logDebug(configuration, `CheckSession - session_state is '${sessionState}' - AuthWellKnownEndPoints is '${JSON.stringify(authWellKnownEndPoints, null, 2)}'`);\r\n                        this.checkSessionChangedInternal$.next(true);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configuration, `CheckSession - OidcSecurityCheckSession pollServerSession checkSession IFrame does not exist:\r\n               clientId : '${clientId}' - existingIframe: '${existingIframe}'`);\r\n                }\r\n                // after sending three messages with no response, fail.\r\n                if (this.outstandingMessages > 3) {\r\n                    this.loggerService.logError(configuration, `CheckSession - OidcSecurityCheckSession not receiving check session response messages.\r\n                            Outstanding messages: '${this.outstandingMessages}'. Server unreachable?`);\r\n                }\r\n                this.zone.runOutsideAngular(() => {\r\n                    this.scheduledHeartBeatRunning = setTimeout(() => this.zone.run(pollServerSessionRecur), this.heartBeatInterval);\r\n                });\r\n            });\r\n        };\r\n        pollServerSessionRecur();\r\n    }\r\n    clearScheduledHeartBeat() {\r\n        clearTimeout(this.scheduledHeartBeatRunning);\r\n        this.scheduledHeartBeatRunning = null;\r\n    }\r\n    messageHandler(configuration, e) {\r\n        const existingIFrame = this.getExistingIframe();\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const startsWith = !!authWellKnownEndPoints?.checkSessionIframe?.startsWith(e.origin);\r\n        this.outstandingMessages = 0;\r\n        if (existingIFrame && startsWith && e.source === existingIFrame.contentWindow) {\r\n            if (e.data === 'error') {\r\n                this.loggerService.logWarning(configuration, 'CheckSession - error from check session messageHandler');\r\n            }\r\n            else if (e.data === 'changed') {\r\n                this.loggerService.logDebug(configuration, `CheckSession - ${e} from check session messageHandler`);\r\n                this.checkSessionReceived = true;\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.checkSessionChangedInternal$.next(true);\r\n            }\r\n            else {\r\n                this.eventService.fireEvent(EventTypes.CheckSessionReceived, e.data);\r\n                this.loggerService.logDebug(configuration, `CheckSession - ${e.data} from check session messageHandler`);\r\n            }\r\n        }\r\n    }\r\n    bindMessageEventToIframe(configId) {\r\n        const iframeMessageEvent = this.messageHandler.bind(this, configId);\r\n        this.document.defaultView.addEventListener('message', iframeMessageEvent, false);\r\n    }\r\n    getOrCreateIframe(configuration) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            const frame = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER, configuration);\r\n            const { configId } = configuration;\r\n            this.bindMessageEventToIframe(configId);\r\n            return frame;\r\n        }\r\n        return existingIframe;\r\n    }\r\n}\r\nCheckSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CheckSessionService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: IFrameService }, { token: PublicEventsService }, { token: i0.NgZone }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CheckSessionService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CheckSessionService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: IFrameService }, { type: PublicEventsService }, { type: i0.NgZone }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass CurrentUrlService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    getStateParamFromCurrentUrl() {\r\n        const currentUrl = this.getCurrentUrl();\r\n        const parsedUrl = new URL(currentUrl);\r\n        const urlParams = new URLSearchParams(parsedUrl.search);\r\n        const stateFromUrl = urlParams.get('state');\r\n        return stateFromUrl;\r\n    }\r\n    currentUrlHasStateParam() {\r\n        return !!this.getStateParamFromCurrentUrl();\r\n    }\r\n    getCurrentUrl() {\r\n        return this.doc.defaultView.location.toString();\r\n    }\r\n}\r\nCurrentUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CurrentUrlService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCurrentUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CurrentUrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CurrentUrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nvar ValidationResult;\r\n(function (ValidationResult) {\r\n    ValidationResult[\"NotSet\"] = \"NotSet\";\r\n    ValidationResult[\"StatesDoNotMatch\"] = \"StatesDoNotMatch\";\r\n    ValidationResult[\"SignatureFailed\"] = \"SignatureFailed\";\r\n    ValidationResult[\"IncorrectNonce\"] = \"IncorrectNonce\";\r\n    ValidationResult[\"RequiredPropertyMissing\"] = \"RequiredPropertyMissing\";\r\n    ValidationResult[\"MaxOffsetExpired\"] = \"MaxOffsetExpired\";\r\n    ValidationResult[\"IssDoesNotMatchIssuer\"] = \"IssDoesNotMatchIssuer\";\r\n    ValidationResult[\"NoAuthWellKnownEndPoints\"] = \"NoAuthWellKnownEndPoints\";\r\n    ValidationResult[\"IncorrectAud\"] = \"IncorrectAud\";\r\n    ValidationResult[\"IncorrectIdTokenClaimsAfterRefresh\"] = \"IncorrectIdTokenClaimsAfterRefresh\";\r\n    ValidationResult[\"IncorrectAzp\"] = \"IncorrectAzp\";\r\n    ValidationResult[\"TokenExpired\"] = \"TokenExpired\";\r\n    ValidationResult[\"IncorrectAtHash\"] = \"IncorrectAtHash\";\r\n    ValidationResult[\"Ok\"] = \"Ok\";\r\n    ValidationResult[\"LoginRequired\"] = \"LoginRequired\";\r\n    ValidationResult[\"SecureTokenServerError\"] = \"SecureTokenServerError\";\r\n})(ValidationResult || (ValidationResult = {}));\n\nclass UriEncoder {\r\n    encodeKey(key) {\r\n        return encodeURIComponent(key);\r\n    }\r\n    encodeValue(value) {\r\n        return encodeURIComponent(value);\r\n    }\r\n    decodeKey(key) {\r\n        return decodeURIComponent(key);\r\n    }\r\n    decodeValue(value) {\r\n        return decodeURIComponent(value);\r\n    }\r\n}\n\nclass RandomService {\r\n    constructor(cryptoService, loggerService) {\r\n        this.cryptoService = cryptoService;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createRandom(requiredLength, configuration) {\r\n        if (requiredLength <= 0) {\r\n            return '';\r\n        }\r\n        if (requiredLength > 0 && requiredLength < 7) {\r\n            this.loggerService.logWarning(configuration, `RandomService called with ${requiredLength} but 7 chars is the minimum, returning 10 chars`);\r\n            requiredLength = 10;\r\n        }\r\n        const length = requiredLength - 6;\r\n        const arr = new Uint8Array(Math.floor(length / 2));\r\n        const crypto = this.cryptoService.getCrypto();\r\n        if (crypto) {\r\n            crypto.getRandomValues(arr);\r\n        }\r\n        return Array.from(arr, this.toHex).join('') + this.randomString(7);\r\n    }\r\n    toHex(dec) {\r\n        return ('0' + dec.toString(16)).substr(-2);\r\n    }\r\n    randomString(length) {\r\n        let result = '';\r\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        const values = new Uint32Array(length);\r\n        const crypto = this.cryptoService.getCrypto();\r\n        if (crypto) {\r\n            crypto.getRandomValues(values);\r\n            for (let i = 0; i < length; i++) {\r\n                result += characters[values[i] % characters.length];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nRandomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RandomService, deps: [{ token: CryptoService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRandomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RandomService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RandomService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CryptoService }, { type: LoggerService }]; } });\n\nclass FlowsDataService {\r\n    constructor(storagePersistenceService, randomService, loggerService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.randomService = randomService;\r\n        this.loggerService = loggerService;\r\n    }\r\n    createNonce(configuration) {\r\n        const nonce = this.randomService.createRandom(40, configuration);\r\n        this.loggerService.logDebug(configuration, 'Nonce created. nonce:' + nonce);\r\n        this.setNonce(nonce, configuration);\r\n        return nonce;\r\n    }\r\n    setNonce(nonce, configuration) {\r\n        this.storagePersistenceService.write('authNonce', nonce, configuration);\r\n    }\r\n    getAuthStateControl(configuration) {\r\n        return this.storagePersistenceService.read('authStateControl', configuration);\r\n    }\r\n    setAuthStateControl(authStateControl, configuration) {\r\n        return this.storagePersistenceService.write('authStateControl', authStateControl, configuration);\r\n    }\r\n    getExistingOrCreateAuthStateControl(configuration) {\r\n        let state = this.storagePersistenceService.read('authStateControl', configuration);\r\n        if (!state) {\r\n            state = this.randomService.createRandom(40, configuration);\r\n            this.storagePersistenceService.write('authStateControl', state, configuration);\r\n        }\r\n        return state;\r\n    }\r\n    setSessionState(sessionState, configuration) {\r\n        this.storagePersistenceService.write('session_state', sessionState, configuration);\r\n    }\r\n    resetStorageFlowData(configuration) {\r\n        this.storagePersistenceService.resetStorageFlowData(configuration);\r\n    }\r\n    getCodeVerifier(configuration) {\r\n        return this.storagePersistenceService.read('codeVerifier', configuration);\r\n    }\r\n    createCodeVerifier(configuration) {\r\n        const codeVerifier = this.randomService.createRandom(67, configuration);\r\n        this.storagePersistenceService.write('codeVerifier', codeVerifier, configuration);\r\n        return codeVerifier;\r\n    }\r\n    isCodeFlowInProgress(configuration) {\r\n        const storageObject = this.getCodeFlowInProgressStorageEntry(configuration);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        return storageObject.state === 'in progress';\r\n    }\r\n    setCodeFlowInProgress(configuration) {\r\n        const storageObject = {\r\n            state: 'in progress',\r\n        };\r\n        this.storagePersistenceService.write('storageCodeFlowInProgress', JSON.stringify(storageObject), configuration);\r\n    }\r\n    resetCodeFlowInProgress(configuration) {\r\n        this.storagePersistenceService.write('storageCodeFlowInProgress', '', configuration);\r\n    }\r\n    getCodeFlowInProgressStorageEntry(configuration) {\r\n        const storageEntry = this.storagePersistenceService.read('storageCodeFlowInProgress', configuration);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n    isSilentRenewRunning(configuration) {\r\n        const { configId, silentRenewTimeoutInSeconds } = configuration;\r\n        const storageObject = this.getSilentRenewRunningStorageEntry(configuration);\r\n        if (!storageObject) {\r\n            return false;\r\n        }\r\n        const timeOutInMilliseconds = silentRenewTimeoutInSeconds * 1000;\r\n        const dateOfLaunchedProcessUtc = Date.parse(storageObject.dateOfLaunchedProcessUtc);\r\n        const currentDateUtc = Date.parse(new Date().toISOString());\r\n        const elapsedTimeInMilliseconds = Math.abs(currentDateUtc - dateOfLaunchedProcessUtc);\r\n        const isProbablyStuck = elapsedTimeInMilliseconds > timeOutInMilliseconds;\r\n        if (isProbablyStuck) {\r\n            this.loggerService.logDebug(configuration, 'silent renew process is probably stuck, state will be reset.', configId);\r\n            this.resetSilentRenewRunning(configuration);\r\n            return false;\r\n        }\r\n        return storageObject.state === 'running';\r\n    }\r\n    setSilentRenewRunning(configuration) {\r\n        const storageObject = {\r\n            state: 'running',\r\n            dateOfLaunchedProcessUtc: new Date().toISOString(),\r\n        };\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', JSON.stringify(storageObject), configuration);\r\n    }\r\n    resetSilentRenewRunning(configuration) {\r\n        this.storagePersistenceService.write('storageSilentRenewRunning', '', configuration);\r\n    }\r\n    getSilentRenewRunningStorageEntry(configuration) {\r\n        const storageEntry = this.storagePersistenceService.read('storageSilentRenewRunning', configuration);\r\n        if (!storageEntry) {\r\n            return null;\r\n        }\r\n        return JSON.parse(storageEntry);\r\n    }\r\n}\r\nFlowsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowsDataService, deps: [{ token: StoragePersistenceService }, { token: RandomService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowsDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowsDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: RandomService }, { type: LoggerService }]; } });\n\nclass FlowHelper {\r\n    isCurrentFlowCodeFlow(configuration) {\r\n        return this.currentFlowIs('code', configuration);\r\n    }\r\n    isCurrentFlowAnyImplicitFlow(configuration) {\r\n        return this.isCurrentFlowImplicitFlowWithAccessToken(configuration) || this.isCurrentFlowImplicitFlowWithoutAccessToken(configuration);\r\n    }\r\n    isCurrentFlowCodeFlowWithRefreshTokens(configuration) {\r\n        const { useRefreshToken } = configuration;\r\n        if (this.isCurrentFlowCodeFlow(configuration) && useRefreshToken) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isCurrentFlowImplicitFlowWithAccessToken(configuration) {\r\n        return this.currentFlowIs('id_token token', configuration);\r\n    }\r\n    currentFlowIs(flowTypes, configuration) {\r\n        const { responseType } = configuration;\r\n        if (Array.isArray(flowTypes)) {\r\n            return flowTypes.some((x) => responseType === x);\r\n        }\r\n        return responseType === flowTypes;\r\n    }\r\n    isCurrentFlowImplicitFlowWithoutAccessToken(configuration) {\r\n        return this.currentFlowIs('id_token', configuration);\r\n    }\r\n}\r\nFlowHelper.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowHelper.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowHelper });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowHelper, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nconst CALLBACK_PARAMS_TO_CHECK = ['code', 'state', 'token', 'id_token'];\r\nconst AUTH0_ENDPOINT = 'auth0.com';\r\nclass UrlService {\r\n    constructor(loggerService, flowsDataService, flowHelper, storagePersistenceService, jwtWindowCryptoService) {\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.jwtWindowCryptoService = jwtWindowCryptoService;\r\n    }\r\n    getUrlParameter(urlToCheck, name) {\r\n        if (!urlToCheck) {\r\n            return '';\r\n        }\r\n        if (!name) {\r\n            return '';\r\n        }\r\n        name = name.replace(/[[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\r\n        const regex = new RegExp('[\\\\?&#]' + name + '=([^&#]*)');\r\n        const results = regex.exec(urlToCheck);\r\n        return results === null ? '' : decodeURIComponent(results[1]);\r\n    }\r\n    isCallbackFromSts(currentUrl) {\r\n        return CALLBACK_PARAMS_TO_CHECK.some((x) => !!this.getUrlParameter(currentUrl, x));\r\n    }\r\n    getRefreshSessionSilentRenewUrl(config, customParams) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\r\n            return this.createUrlCodeFlowWithSilentRenew(config, customParams);\r\n        }\r\n        return of(this.createUrlImplicitFlowWithSilentRenew(config, customParams) || '');\r\n    }\r\n    getAuthorizeParUrl(requestUri, configuration) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }\r\n        const authorizationEndpoint = authWellKnownEndPoints.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId } = configuration;\r\n        if (!clientId) {\r\n            this.loggerService.logError(configuration, `getAuthorizeParUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('request_uri', requestUri);\r\n        params = params.append('client_id', clientId);\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    getAuthorizeUrl(config, authOptions) {\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\r\n            return this.createUrlCodeFlowAuthorize(config, authOptions);\r\n        }\r\n        return of(this.createUrlImplicitFlowAuthorize(config, authOptions) || '');\r\n    }\r\n    createEndSessionUrl(idTokenHint, configuration, customParamsEndSession) {\r\n        // Auth0 needs a special logout url\r\n        // See https://auth0.com/docs/api/authentication#logout\r\n        if (this.isAuth0Endpoint(configuration)) {\r\n            return this.composeAuth0Endpoint(configuration);\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const endSessionEndpoint = authWellKnownEndPoints?.endSessionEndpoint;\r\n        if (!endSessionEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = endSessionEndpoint.split('?');\r\n        const authorizationEndSessionUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        if (!!idTokenHint) {\r\n            params = params.set('id_token_hint', idTokenHint);\r\n        }\r\n        const postLogoutRedirectUri = this.getPostLogoutRedirectUrl(configuration);\r\n        if (postLogoutRedirectUri) {\r\n            params = params.append('post_logout_redirect_uri', postLogoutRedirectUri);\r\n        }\r\n        if (customParamsEndSession) {\r\n            params = this.appendCustomParams({ ...customParamsEndSession }, params);\r\n        }\r\n        return `${authorizationEndSessionUrl}?${params}`;\r\n    }\r\n    createRevocationEndpointBodyAccessToken(token, configuration) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'access_token');\r\n        return params.toString();\r\n    }\r\n    createRevocationEndpointBodyRefreshToken(token, configuration) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('token', token);\r\n        params = params.set('token_type_hint', 'refresh_token');\r\n        return params.toString();\r\n    }\r\n    getRevocationEndpointUrl(configuration) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const revocationEndpoint = authWellKnownEndPoints?.revocationEndpoint;\r\n        if (!revocationEndpoint) {\r\n            return null;\r\n        }\r\n        const urlParts = revocationEndpoint.split('?');\r\n        const revocationEndpointUrl = urlParts[0];\r\n        return revocationEndpointUrl;\r\n    }\r\n    createBodyForCodeFlowCodeRequest(code, configuration, customTokenParams) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'authorization_code');\r\n        params = params.set('client_id', clientId);\r\n        if (!configuration.disablePkce) {\r\n            const codeVerifier = this.flowsDataService.getCodeVerifier(configuration);\r\n            if (!codeVerifier) {\r\n                this.loggerService.logError(configuration, `CodeVerifier is not set `, codeVerifier);\r\n                return null;\r\n            }\r\n            params = params.set('code_verifier', codeVerifier);\r\n        }\r\n        params = params.set('code', code);\r\n        if (customTokenParams) {\r\n            params = this.appendCustomParams({ ...customTokenParams }, params);\r\n        }\r\n        const silentRenewUrl = this.getSilentRenewUrl(configuration);\r\n        if (this.flowsDataService.isSilentRenewRunning(configuration) && silentRenewUrl) {\r\n            params = params.set('redirect_uri', silentRenewUrl);\r\n            return params.toString();\r\n        }\r\n        const redirectUrl = this.getRedirectUrl(configuration);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        params = params.set('redirect_uri', redirectUrl);\r\n        return params.toString();\r\n    }\r\n    createBodyForCodeFlowRefreshTokensRequest(refreshToken, configuration, customParamsRefresh) {\r\n        const clientId = this.getClientId(configuration);\r\n        if (!clientId) {\r\n            return null;\r\n        }\r\n        let params = this.createHttpParams();\r\n        params = params.set('grant_type', 'refresh_token');\r\n        params = params.set('client_id', clientId);\r\n        params = params.set('refresh_token', refreshToken);\r\n        if (customParamsRefresh) {\r\n            params = this.appendCustomParams({ ...customParamsRefresh }, params);\r\n        }\r\n        return params.toString();\r\n    }\r\n    createBodyForParCodeFlowRequest(configuration, customParamsRequest) {\r\n        const redirectUrl = this.getRedirectUrl(configuration);\r\n        if (!redirectUrl) {\r\n            return of(null);\r\n        }\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = configuration;\r\n            let params = this.createHttpParams('');\r\n            params = params.set('client_id', clientId);\r\n            params = params.append('redirect_uri', redirectUrl);\r\n            params = params.append('response_type', responseType);\r\n            params = params.append('scope', scope);\r\n            params = params.append('nonce', nonce);\r\n            params = params.append('state', state);\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n            if (hdParam) {\r\n                params = params.append('hd', hdParam);\r\n            }\r\n            if (customParamsAuthRequest) {\r\n                params = this.appendCustomParams({ ...customParamsAuthRequest }, params);\r\n            }\r\n            if (customParamsRequest) {\r\n                params = this.appendCustomParams({ ...customParamsRequest }, params);\r\n            }\r\n            return params.toString();\r\n        }));\r\n    }\r\n    createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, configuration, prompt, customRequestParams) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        const authorizationEndpoint = authWellKnownEndPoints?.authorizationEndpoint;\r\n        if (!authorizationEndpoint) {\r\n            this.loggerService.logError(configuration, `Can not create an authorize URL when authorizationEndpoint is '${authorizationEndpoint}'`);\r\n            return null;\r\n        }\r\n        const { clientId, responseType, scope, hdParam, customParamsAuthRequest } = configuration;\r\n        if (!clientId) {\r\n            this.loggerService.logError(configuration, `createAuthorizeUrl could not add clientId because it was: `, clientId);\r\n            return null;\r\n        }\r\n        if (!responseType) {\r\n            this.loggerService.logError(configuration, `createAuthorizeUrl could not add responseType because it was: `, responseType);\r\n            return null;\r\n        }\r\n        if (!scope) {\r\n            this.loggerService.logError(configuration, `createAuthorizeUrl could not add scope because it was: `, scope);\r\n            return null;\r\n        }\r\n        const urlParts = authorizationEndpoint.split('?');\r\n        const authorizationUrl = urlParts[0];\r\n        const existingParams = urlParts[1];\r\n        let params = this.createHttpParams(existingParams);\r\n        params = params.set('client_id', clientId);\r\n        params = params.append('redirect_uri', redirectUrl);\r\n        params = params.append('response_type', responseType);\r\n        params = params.append('scope', scope);\r\n        params = params.append('nonce', nonce);\r\n        params = params.append('state', state);\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configuration) && codeChallenge !== null) {\r\n            params = params.append('code_challenge', codeChallenge);\r\n            params = params.append('code_challenge_method', 'S256');\r\n        }\r\n        const mergedParams = { ...customParamsAuthRequest, ...customRequestParams };\r\n        if (Object.keys(mergedParams).length > 0) {\r\n            params = this.appendCustomParams({ ...mergedParams }, params);\r\n        }\r\n        if (prompt) {\r\n            params = this.overWriteParam(params, 'prompt', prompt);\r\n        }\r\n        if (hdParam) {\r\n            params = params.append('hd', hdParam);\r\n        }\r\n        return `${authorizationUrl}?${params}`;\r\n    }\r\n    createUrlImplicitFlowWithSilentRenew(configuration, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        const silentRenewUrl = this.getSilentRenewUrl(configuration);\r\n        if (!silentRenewUrl) {\r\n            return null;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ', state);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (authWellKnownEndPoints) {\r\n            return this.createAuthorizeUrl('', silentRenewUrl, nonce, state, configuration, 'none', customParams);\r\n        }\r\n        this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowWithSilentRenew(configuration, customParams) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        this.loggerService.logDebug(configuration, 'RefreshSession created. adding myautostate: ' + state);\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(configuration);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier).pipe(map((codeChallenge) => {\r\n            const silentRenewUrl = this.getSilentRenewUrl(configuration);\r\n            if (!silentRenewUrl) {\r\n                return '';\r\n            }\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n            if (authWellKnownEndPoints) {\r\n                return this.createAuthorizeUrl(codeChallenge, silentRenewUrl, nonce, state, configuration, 'none', customParams);\r\n            }\r\n            this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\r\n            return null;\r\n        }));\r\n    }\r\n    createUrlImplicitFlowAuthorize(configuration, authOptions) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(configuration);\r\n        const nonce = this.flowsDataService.createNonce(configuration);\r\n        this.loggerService.logDebug(configuration, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(configuration, authOptions);\r\n        if (!redirectUrl) {\r\n            return null;\r\n        }\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (authWellKnownEndPoints) {\r\n            const { customParams } = authOptions || {};\r\n            return this.createAuthorizeUrl('', redirectUrl, nonce, state, configuration, null, customParams);\r\n        }\r\n        this.loggerService.logError(configuration, 'authWellKnownEndpoints is undefined');\r\n        return null;\r\n    }\r\n    createUrlCodeFlowAuthorize(config, authOptions) {\r\n        const state = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\r\n        const nonce = this.flowsDataService.createNonce(config);\r\n        this.loggerService.logDebug(config, 'Authorize created. adding myautostate: ' + state);\r\n        const redirectUrl = this.getRedirectUrl(config, authOptions);\r\n        if (!redirectUrl) {\r\n            return of(null);\r\n        }\r\n        return this.getCodeChallenge(config).pipe(map((codeChallenge) => {\r\n            const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n            if (authWellKnownEndPoints) {\r\n                const { customParams } = authOptions || {};\r\n                return this.createAuthorizeUrl(codeChallenge, redirectUrl, nonce, state, config, null, customParams);\r\n            }\r\n            this.loggerService.logError(config, 'authWellKnownEndpoints is undefined');\r\n            return '';\r\n        }));\r\n    }\r\n    getCodeChallenge(config) {\r\n        if (config.disablePkce) {\r\n            return of(null);\r\n        }\r\n        // code_challenge with \"S256\"\r\n        const codeVerifier = this.flowsDataService.createCodeVerifier(config);\r\n        return this.jwtWindowCryptoService.generateCodeChallenge(codeVerifier);\r\n    }\r\n    getRedirectUrl(configuration, authOptions) {\r\n        let { redirectUrl } = configuration;\r\n        if (authOptions?.redirectUrl) {\r\n            // override by redirectUrl from authOptions\r\n            redirectUrl = authOptions.redirectUrl;\r\n        }\r\n        if (!redirectUrl) {\r\n            this.loggerService.logError(configuration, `could not get redirectUrl, was: `, redirectUrl);\r\n            return null;\r\n        }\r\n        return redirectUrl;\r\n    }\r\n    getSilentRenewUrl(configuration) {\r\n        const { silentRenewUrl } = configuration;\r\n        if (!silentRenewUrl) {\r\n            this.loggerService.logError(configuration, `could not get silentRenewUrl, was: `, silentRenewUrl);\r\n            return null;\r\n        }\r\n        return silentRenewUrl;\r\n    }\r\n    getPostLogoutRedirectUrl(configuration) {\r\n        const { postLogoutRedirectUri } = configuration;\r\n        if (!postLogoutRedirectUri) {\r\n            this.loggerService.logError(configuration, `could not get postLogoutRedirectUri, was: `, postLogoutRedirectUri);\r\n            return null;\r\n        }\r\n        return postLogoutRedirectUri;\r\n    }\r\n    getClientId(configuration) {\r\n        const { clientId } = configuration;\r\n        if (!clientId) {\r\n            this.loggerService.logError(configuration, `could not get clientId, was: `, clientId);\r\n            return null;\r\n        }\r\n        return clientId;\r\n    }\r\n    appendCustomParams(customParams, params) {\r\n        for (const [key, value] of Object.entries({ ...customParams })) {\r\n            params = params.append(key, value.toString());\r\n        }\r\n        return params;\r\n    }\r\n    overWriteParam(params, key, value) {\r\n        return params.set(key, value);\r\n    }\r\n    createHttpParams(existingParams) {\r\n        existingParams = existingParams ?? '';\r\n        const params = new HttpParams({\r\n            fromString: existingParams,\r\n            encoder: new UriEncoder(),\r\n        });\r\n        return params;\r\n    }\r\n    isAuth0Endpoint(configuration) {\r\n        const { authority } = configuration;\r\n        if (!authority) {\r\n            return false;\r\n        }\r\n        return authority.endsWith(AUTH0_ENDPOINT);\r\n    }\r\n    composeAuth0Endpoint(configuration) {\r\n        // format: https://YOUR_DOMAIN/v2/logout?client_id=YOUR_CLIENT_ID&returnTo=LOGOUT_URL\r\n        const { authority, clientId } = configuration;\r\n        const postLogoutRedirectUrl = this.getPostLogoutRedirectUrl(configuration);\r\n        return `${authority}/v2/logout?client_id=${clientId}&returnTo=${postLogoutRedirectUrl}`;\r\n    }\r\n}\r\nUrlService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UrlService, deps: [{ token: LoggerService }, { token: FlowsDataService }, { token: FlowHelper }, { token: StoragePersistenceService }, { token: JwtWindowCryptoService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUrlService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UrlService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UrlService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowsDataService }, { type: FlowHelper }, { type: StoragePersistenceService }, { type: JwtWindowCryptoService }]; } });\n\nclass CodeFlowCallbackHandlerService {\r\n    constructor(urlService, loggerService, tokenValidationService, flowsDataService, storagePersistenceService, dataService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.dataService = dataService;\r\n    }\r\n    // STEP 1 Code Flow\r\n    codeFlowCallback(urlToCheck, config) {\r\n        const code = this.urlService.getUrlParameter(urlToCheck, 'code');\r\n        const state = this.urlService.getUrlParameter(urlToCheck, 'state');\r\n        const sessionState = this.urlService.getUrlParameter(urlToCheck, 'session_state');\r\n        if (!state) {\r\n            this.loggerService.logDebug(config, 'no state in url');\r\n            return throwError(() => new Error('no state in url'));\r\n        }\r\n        if (!code) {\r\n            this.loggerService.logDebug(config, 'no code in url');\r\n            return throwError(() => new Error('no code in url'));\r\n        }\r\n        this.loggerService.logDebug(config, 'running validation for callback', urlToCheck);\r\n        const initialCallbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: false,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(initialCallbackContext);\r\n    }\r\n    // STEP 2 Code Flow //  Code Flow Silent Renew starts here\r\n    codeFlowCodeRequest(callbackContext, config) {\r\n        const authStateControl = this.flowsDataService.getAuthStateControl(config);\r\n        const isStateCorrect = this.tokenValidationService.validateStateFromHashCallback(callbackContext.state, authStateControl, config);\r\n        if (!isStateCorrect) {\r\n            return throwError(() => new Error('codeFlowCodeRequest incorrect state'));\r\n        }\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n        const tokenEndpoint = authWellknownEndpoints?.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError(() => new Error('Token Endpoint not defined'));\r\n        }\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const bodyForCodeFlow = this.urlService.createBodyForCodeFlowCodeRequest(callbackContext.code, config, config?.customParamsCodeRequest);\r\n        return this.dataService.post(tokenEndpoint, bodyForCodeFlow, config, headers).pipe(switchMap((response) => {\r\n            let authResult = {\r\n                ...response,\r\n                state: callbackContext.state,\r\n                session_state: callbackContext.sessionState,\r\n            };\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, config)), catchError((error) => {\r\n            const { authority } = config;\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(config, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, config) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = config;\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(config, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CodeFlowCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: TokenValidationService }, { token: FlowsDataService }, { token: StoragePersistenceService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CodeFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CodeFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: TokenValidationService }, { type: FlowsDataService }, { type: StoragePersistenceService }, { type: DataService }]; } });\n\nconst DEFAULT_USERRESULT = { userData: null, allUserData: [] };\r\nclass UserService {\r\n    constructor(oidcDataService, storagePersistenceService, eventService, loggerService, tokenHelperService, flowHelper) {\r\n        this.oidcDataService = oidcDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.eventService = eventService;\r\n        this.loggerService = loggerService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.flowHelper = flowHelper;\r\n        this.userDataInternal$ = new BehaviorSubject(DEFAULT_USERRESULT);\r\n    }\r\n    get userData$() {\r\n        return this.userDataInternal$.asObservable();\r\n    }\r\n    getAndPersistUserDataInStore(currentConfiguration, allConfigs, isRenewProcess = false, idToken, decodedIdToken) {\r\n        idToken = idToken || this.storagePersistenceService.getIdToken(currentConfiguration);\r\n        decodedIdToken = decodedIdToken || this.tokenHelperService.getPayloadFromToken(idToken, false, currentConfiguration);\r\n        const existingUserDataFromStorage = this.getUserDataFromStore(currentConfiguration);\r\n        const haveUserData = !!existingUserDataFromStorage;\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(currentConfiguration);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(currentConfiguration);\r\n        const accessToken = this.storagePersistenceService.getAccessToken(currentConfiguration);\r\n        if (!(isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow)) {\r\n            this.loggerService.logDebug(currentConfiguration, `authCallback idToken flow with accessToken ${accessToken}`);\r\n            this.setUserDataToStore(decodedIdToken, currentConfiguration, allConfigs);\r\n            return of(decodedIdToken);\r\n        }\r\n        const { renewUserInfoAfterTokenRenew } = currentConfiguration;\r\n        if (!isRenewProcess || renewUserInfoAfterTokenRenew || !haveUserData) {\r\n            return this.getUserDataOidcFlowAndSave(decodedIdToken.sub, currentConfiguration, allConfigs).pipe(switchMap((userData) => {\r\n                this.loggerService.logDebug(currentConfiguration, 'Received user data: ', userData);\r\n                if (!!userData) {\r\n                    this.loggerService.logDebug(currentConfiguration, 'accessToken: ', accessToken);\r\n                    return of(userData);\r\n                }\r\n                else {\r\n                    return throwError(() => new Error('Received no user data, request failed'));\r\n                }\r\n            }));\r\n        }\r\n        return of(existingUserDataFromStorage);\r\n    }\r\n    getUserDataFromStore(currentConfiguration) {\r\n        return this.storagePersistenceService.read('userData', currentConfiguration) || null;\r\n    }\r\n    publishUserDataIfExists(currentConfiguration, allConfigs) {\r\n        const userData = this.getUserDataFromStore(currentConfiguration);\r\n        if (userData) {\r\n            this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\r\n        }\r\n    }\r\n    setUserDataToStore(userData, currentConfiguration, allConfigs) {\r\n        this.storagePersistenceService.write('userData', userData, currentConfiguration);\r\n        this.fireUserDataEvent(currentConfiguration, allConfigs, userData);\r\n    }\r\n    resetUserDataInStore(currentConfiguration, allConfigs) {\r\n        this.storagePersistenceService.remove('userData', currentConfiguration);\r\n        this.fireUserDataEvent(currentConfiguration, allConfigs, null);\r\n    }\r\n    getUserDataOidcFlowAndSave(idTokenSub, currentConfiguration, allConfigs) {\r\n        return this.getIdentityUserData(currentConfiguration).pipe(map((data) => {\r\n            if (this.validateUserDataSubIdToken(currentConfiguration, idTokenSub, data?.sub)) {\r\n                this.setUserDataToStore(data, currentConfiguration, allConfigs);\r\n                return data;\r\n            }\r\n            else {\r\n                // something went wrong, user data sub does not match that from id_token\r\n                this.loggerService.logWarning(currentConfiguration, `User data sub does not match sub in id_token, resetting`);\r\n                this.resetUserDataInStore(currentConfiguration, allConfigs);\r\n                return null;\r\n            }\r\n        }));\r\n    }\r\n    getIdentityUserData(currentConfiguration) {\r\n        const token = this.storagePersistenceService.getAccessToken(currentConfiguration);\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\r\n        if (!authWellKnownEndPoints) {\r\n            this.loggerService.logWarning(currentConfiguration, 'init check session: authWellKnownEndpoints is undefined');\r\n            return throwError(() => new Error('authWellKnownEndpoints is undefined'));\r\n        }\r\n        const userInfoEndpoint = authWellKnownEndPoints.userInfoEndpoint;\r\n        if (!userInfoEndpoint) {\r\n            this.loggerService.logError(currentConfiguration, 'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config');\r\n            return throwError(() => new Error('authWellKnownEndpoints.userinfo_endpoint is undefined'));\r\n        }\r\n        return this.oidcDataService.get(userInfoEndpoint, currentConfiguration, token).pipe(retry(2));\r\n    }\r\n    validateUserDataSubIdToken(currentConfiguration, idTokenSub, userDataSub) {\r\n        if (!idTokenSub) {\r\n            return false;\r\n        }\r\n        if (!userDataSub) {\r\n            return false;\r\n        }\r\n        if (idTokenSub !== userDataSub) {\r\n            this.loggerService.logDebug(currentConfiguration, 'validateUserDataSubIdToken failed', idTokenSub, userDataSub);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    fireUserDataEvent(currentConfiguration, allConfigs, passedUserData) {\r\n        const userData = this.composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData);\r\n        this.userDataInternal$.next(userData);\r\n        const { configId } = currentConfiguration;\r\n        this.eventService.fireEvent(EventTypes.UserDataChanged, { configId, userData: passedUserData });\r\n    }\r\n    composeSingleOrMultipleUserDataObject(currentConfiguration, allConfigs, passedUserData) {\r\n        const hasManyConfigs = allConfigs.length > 1;\r\n        if (!hasManyConfigs) {\r\n            const { configId } = currentConfiguration;\r\n            return this.composeSingleUserDataResult(configId, passedUserData);\r\n        }\r\n        const allUserData = allConfigs.map((config) => {\r\n            const { configId } = currentConfiguration;\r\n            if (this.currentConfigIsToUpdate(configId, config)) {\r\n                return { configId: config.configId, userData: passedUserData };\r\n            }\r\n            const alreadySavedUserData = this.storagePersistenceService.read('userData', config) || null;\r\n            return { configId: config.configId, userData: alreadySavedUserData };\r\n        });\r\n        return {\r\n            userData: null,\r\n            allUserData,\r\n        };\r\n    }\r\n    composeSingleUserDataResult(configId, userData) {\r\n        return {\r\n            userData,\r\n            allUserData: [{ configId, userData }],\r\n        };\r\n    }\r\n    currentConfigIsToUpdate(configId, config) {\r\n        return config.configId === configId;\r\n    }\r\n}\r\nUserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UserService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: LoggerService }, { token: TokenHelperService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UserService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UserService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: LoggerService }, { type: TokenHelperService }, { type: FlowHelper }]; } });\n\nclass ResetAuthDataService {\r\n    constructor(authStateService, flowsDataService, userService) {\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n    }\r\n    resetAuthorizationData(currentConfiguration, allConfigs) {\r\n        this.userService.resetUserDataInStore(currentConfiguration, allConfigs);\r\n        this.flowsDataService.resetStorageFlowData(currentConfiguration);\r\n        this.authStateService.setUnauthenticatedAndFireEvent(currentConfiguration, allConfigs);\r\n    }\r\n}\r\nResetAuthDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ResetAuthDataService, deps: [{ token: AuthStateService }, { token: FlowsDataService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResetAuthDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ResetAuthDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ResetAuthDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: FlowsDataService }, { type: UserService }]; } });\n\nclass ImplicitFlowCallbackHandlerService {\r\n    constructor(resetAuthDataService, loggerService, flowsDataService, doc) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.loggerService = loggerService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 1 Code Flow\r\n    // STEP 1 Implicit Flow\r\n    implicitFlowCallback(config, allConfigs, hash) {\r\n        const isRenewProcessData = this.flowsDataService.isSilentRenewRunning(config);\r\n        this.loggerService.logDebug(config, 'BEGIN callback, no auth data');\r\n        if (!isRenewProcessData) {\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n        }\r\n        hash = hash || this.doc.location.hash.substr(1);\r\n        const authResult = hash.split('&').reduce((resultData, item) => {\r\n            const parts = item.split('=');\r\n            resultData[parts.shift()] = parts.join('=');\r\n            return resultData;\r\n        }, {});\r\n        const callbackContext = {\r\n            code: null,\r\n            refreshToken: null,\r\n            state: null,\r\n            sessionState: null,\r\n            authResult,\r\n            isRenewProcess: isRenewProcessData,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return of(callbackContext);\r\n    }\r\n}\r\nImplicitFlowCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, deps: [{ token: ResetAuthDataService }, { token: LoggerService }, { token: FlowsDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ImplicitFlowCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ImplicitFlowCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: LoggerService }, { type: FlowsDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass SigninKeyDataService {\r\n    constructor(storagePersistenceService, loggerService, dataService) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n    }\r\n    getSigningKeys(currentConfiguration) {\r\n        const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', currentConfiguration);\r\n        const jwksUri = authWellKnownEndPoints?.jwksUri;\r\n        if (!jwksUri) {\r\n            const error = `getSigningKeys: authWellKnownEndpoints.jwksUri is: '${jwksUri}'`;\r\n            this.loggerService.logWarning(currentConfiguration, error);\r\n            return throwError(() => new Error(error));\r\n        }\r\n        this.loggerService.logDebug(currentConfiguration, 'Getting signinkeys from ', jwksUri);\r\n        return this.dataService.get(jwksUri, currentConfiguration).pipe(retry(2), catchError((e) => this.handleErrorGetSigningKeys(e, currentConfiguration)));\r\n    }\r\n    handleErrorGetSigningKeys(errorResponse, currentConfiguration) {\r\n        let errMsg = '';\r\n        if (errorResponse instanceof HttpResponse) {\r\n            const body = errorResponse.body || {};\r\n            const err = JSON.stringify(body);\r\n            const { status, statusText } = errorResponse;\r\n            errMsg = `${status || ''} - ${statusText || ''} ${err || ''}`;\r\n        }\r\n        else {\r\n            const { message } = errorResponse;\r\n            errMsg = !!message ? message : `${errorResponse}`;\r\n        }\r\n        this.loggerService.logError(currentConfiguration, errMsg);\r\n        return throwError(() => new Error(errMsg));\r\n    }\r\n}\r\nSigninKeyDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SigninKeyDataService, deps: [{ token: StoragePersistenceService }, { token: LoggerService }, { token: DataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSigninKeyDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SigninKeyDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SigninKeyDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: LoggerService }, { type: DataService }]; } });\n\nconst JWT_KEYS = 'jwtKeys';\r\nclass HistoryJwtKeysCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService, signInKeyDataService, storagePersistenceService, resetAuthDataService, document) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.signInKeyDataService = signInKeyDataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.document = document;\r\n    }\r\n    // STEP 3 Code Flow, STEP 2 Implicit Flow, STEP 3 Refresh Token\r\n    callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs) {\r\n        this.storagePersistenceService.write('authnResult', callbackContext.authResult, config);\r\n        if (config.allowUnsafeReuseRefreshToken && callbackContext.authResult.refresh_token) {\r\n            this.storagePersistenceService.write('reusable_refresh_token', callbackContext.authResult.refresh_token, config);\r\n        }\r\n        if (this.historyCleanUpTurnedOn(config) && !callbackContext.isRenewProcess) {\r\n            this.resetBrowserHistory();\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(config, 'history clean up inactive');\r\n        }\r\n        if (callbackContext.authResult.error) {\r\n            const errorMessage = `AuthCallback AuthResult came with error: ${callbackContext.authResult.error}`;\r\n            this.loggerService.logDebug(config, errorMessage);\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            this.flowsDataService.setNonce('', config);\r\n            this.handleResultErrorFromCallback(callbackContext.authResult, callbackContext.isRenewProcess);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(config, `AuthResult '${JSON.stringify(callbackContext.authResult, null, 2)}'.\r\n      AuthCallback created, begin token validation`);\r\n        return this.signInKeyDataService.getSigningKeys(config).pipe(tap((jwtKeys) => this.storeSigningKeys(jwtKeys, config)), catchError((err) => {\r\n            // fallback: try to load jwtKeys from storage\r\n            const storedJwtKeys = this.readSigningKeys(config);\r\n            if (!!storedJwtKeys) {\r\n                this.loggerService.logWarning(config, `Failed to retrieve signing keys, fallback to stored keys`);\r\n                return of(storedJwtKeys);\r\n            }\r\n            return throwError(() => new Error(err));\r\n        }), switchMap((jwtKeys) => {\r\n            if (jwtKeys) {\r\n                callbackContext.jwtKeys = jwtKeys;\r\n                return of(callbackContext);\r\n            }\r\n            const errorMessage = `Failed to retrieve signing key`;\r\n            this.loggerService.logWarning(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve signing key with error: ${err}`;\r\n            this.loggerService.logWarning(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleResultErrorFromCallback(result, isRenewProcess) {\r\n        let validationResult = ValidationResult.SecureTokenServerError;\r\n        if (result.error === 'login_required') {\r\n            validationResult = ValidationResult.LoginRequired;\r\n        }\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    historyCleanUpTurnedOn(config) {\r\n        const { historyCleanupOff } = config;\r\n        return !historyCleanupOff;\r\n    }\r\n    resetBrowserHistory() {\r\n        this.document.defaultView.history.replaceState({}, this.document.defaultView.title, this.document.defaultView.location.origin + this.document.defaultView.location.pathname);\r\n    }\r\n    storeSigningKeys(jwtKeys, config) {\r\n        this.storagePersistenceService.write(JWT_KEYS, jwtKeys, config);\r\n    }\r\n    readSigningKeys(config) {\r\n        return this.storagePersistenceService.read(JWT_KEYS, config);\r\n    }\r\n}\r\nHistoryJwtKeysCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }, { token: SigninKeyDataService }, { token: StoragePersistenceService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nHistoryJwtKeysCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: HistoryJwtKeysCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }, { type: SigninKeyDataService }, { type: StoragePersistenceService }, { type: ResetAuthDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass UserCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService, userService, resetAuthDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.userService = userService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n    }\r\n    // STEP 5 userData\r\n    callbackUser(callbackContext, configuration, allConfigs) {\r\n        const { isRenewProcess, validationResult, authResult, refreshToken } = callbackContext;\r\n        const { autoUserInfo, renewUserInfoAfterTokenRenew } = configuration;\r\n        if (!autoUserInfo) {\r\n            if (!isRenewProcess || renewUserInfoAfterTokenRenew) {\r\n                // userData is set to the id_token decoded, auto get user data set to false\r\n                if (validationResult.decodedIdToken) {\r\n                    this.userService.setUserDataToStore(validationResult.decodedIdToken, configuration, allConfigs);\r\n                }\r\n            }\r\n            if (!isRenewProcess && !refreshToken) {\r\n                this.flowsDataService.setSessionState(authResult.session_state, configuration);\r\n            }\r\n            this.publishAuthState(validationResult, isRenewProcess);\r\n            return of(callbackContext);\r\n        }\r\n        return this.userService\r\n            .getAndPersistUserDataInStore(configuration, allConfigs, isRenewProcess, validationResult.idToken, validationResult.decodedIdToken)\r\n            .pipe(switchMap((userData) => {\r\n            if (!!userData) {\r\n                if (!refreshToken) {\r\n                    this.flowsDataService.setSessionState(authResult.session_state, configuration);\r\n                }\r\n                this.publishAuthState(validationResult, isRenewProcess);\r\n                return of(callbackContext);\r\n            }\r\n            else {\r\n                this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\r\n                this.publishUnauthenticatedState(validationResult, isRenewProcess);\r\n                const errorMessage = `Called for userData but they were ${userData}`;\r\n                this.loggerService.logWarning(configuration, errorMessage);\r\n                return throwError(() => new Error(errorMessage));\r\n            }\r\n        }), catchError((err) => {\r\n            const errorMessage = `Failed to retrieve user info with error:  ${err}`;\r\n            this.loggerService.logWarning(configuration, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    publishAuthState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: true,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n    publishUnauthenticatedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nUserCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UserCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }, { token: UserService }, { token: ResetAuthDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nUserCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UserCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: UserCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }, { type: UserService }, { type: ResetAuthDataService }]; } });\n\nclass StateValidationResult {\r\n    constructor(accessToken = '', idToken = '', authResponseIsValid = false, decodedIdToken = {\r\n        at_hash: '',\r\n    }, state = ValidationResult.NotSet) {\r\n        this.accessToken = accessToken;\r\n        this.idToken = idToken;\r\n        this.authResponseIsValid = authResponseIsValid;\r\n        this.decodedIdToken = decodedIdToken;\r\n        this.state = state;\r\n    }\r\n}\n\nclass EqualityService {\r\n    isStringEqualOrNonOrderedArrayEqual(value1, value2) {\r\n        if (this.isNullOrUndefined(value1)) {\r\n            return false;\r\n        }\r\n        if (this.isNullOrUndefined(value2)) {\r\n            return false;\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        return this.arraysHaveEqualContent(value1, value2);\r\n    }\r\n    areEqual(value1, value2) {\r\n        if (!value1 || !value2) {\r\n            return false;\r\n        }\r\n        if (this.bothValuesAreArrays(value1, value2)) {\r\n            return this.arraysStrictEqual(value1, value2);\r\n        }\r\n        if (this.bothValuesAreStrings(value1, value2)) {\r\n            return value1 === value2;\r\n        }\r\n        if (this.bothValuesAreObjects(value1, value2)) {\r\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\r\n        }\r\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\r\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\r\n                return value1[0] === value2;\r\n            }\r\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\r\n                return value2[0] === value1;\r\n            }\r\n        }\r\n        return value1 === value2;\r\n    }\r\n    oneValueIsStringAndTheOtherIsArray(value1, value2) {\r\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\r\n    }\r\n    bothValuesAreObjects(value1, value2) {\r\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\r\n    }\r\n    bothValuesAreStrings(value1, value2) {\r\n        return this.valueIsString(value1) && this.valueIsString(value2);\r\n    }\r\n    bothValuesAreArrays(value1, value2) {\r\n        return Array.isArray(value1) && Array.isArray(value2);\r\n    }\r\n    valueIsString(value) {\r\n        return typeof value === 'string' || value instanceof String;\r\n    }\r\n    valueIsObject(value) {\r\n        return typeof value === 'object';\r\n    }\r\n    arraysStrictEqual(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        for (let i = arr1.length; i--;) {\r\n            if (arr1[i] !== arr2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    arraysHaveEqualContent(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n        return arr1.some((v) => arr2.includes(v));\r\n    }\r\n    isNullOrUndefined(val) {\r\n        return val === null || val === undefined;\r\n    }\r\n}\r\nEqualityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: EqualityService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nEqualityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: EqualityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: EqualityService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass StateValidationService {\r\n    constructor(storagePersistenceService, tokenValidationService, tokenHelperService, loggerService, equalityService, flowHelper) {\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.tokenValidationService = tokenValidationService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.loggerService = loggerService;\r\n        this.equalityService = equalityService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    getValidatedStateResult(callbackContext, configuration) {\r\n        if (!callbackContext || callbackContext.authResult.error) {\r\n            return of(new StateValidationResult('', '', false, {}));\r\n        }\r\n        return this.validateState(callbackContext, configuration);\r\n    }\r\n    validateState(callbackContext, configuration) {\r\n        const toReturn = new StateValidationResult();\r\n        const authStateControl = this.storagePersistenceService.read('authStateControl', configuration);\r\n        if (!this.tokenValidationService.validateStateFromHashCallback(callbackContext.authResult.state, authStateControl, configuration)) {\r\n            this.loggerService.logWarning(configuration, 'authCallback incorrect state');\r\n            toReturn.state = ValidationResult.StatesDoNotMatch;\r\n            this.handleUnsuccessfulValidation(configuration);\r\n            return of(toReturn);\r\n        }\r\n        const isCurrentFlowImplicitFlowWithAccessToken = this.flowHelper.isCurrentFlowImplicitFlowWithAccessToken(configuration);\r\n        const isCurrentFlowCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(configuration);\r\n        if (isCurrentFlowImplicitFlowWithAccessToken || isCurrentFlowCodeFlow) {\r\n            toReturn.accessToken = callbackContext.authResult.access_token;\r\n        }\r\n        if (callbackContext.authResult.id_token) {\r\n            const { clientId, issValidationOff, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, ignoreNonceAfterRefresh, disableIdTokenValidation, } = configuration;\r\n            toReturn.idToken = callbackContext.authResult.id_token;\r\n            toReturn.decodedIdToken = this.tokenHelperService.getPayloadFromToken(toReturn.idToken, false, configuration);\r\n            return this.tokenValidationService.validateSignatureIdToken(toReturn.idToken, callbackContext.jwtKeys, configuration).pipe(mergeMap((isSignatureIdTokenValid) => {\r\n                if (!isSignatureIdTokenValid) {\r\n                    this.loggerService.logDebug(configuration, 'authCallback Signature validation failed id_token');\r\n                    toReturn.state = ValidationResult.SignatureFailed;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                const authNonce = this.storagePersistenceService.read('authNonce', configuration);\r\n                if (!this.tokenValidationService.validateIdTokenNonce(toReturn.decodedIdToken, authNonce, ignoreNonceAfterRefresh, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback incorrect nonce, did you call the checkAuth() method multiple times?');\r\n                    toReturn.state = ValidationResult.IncorrectNonce;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateRequiredIdToken(toReturn.decodedIdToken, configuration)) {\r\n                    this.loggerService.logDebug(configuration, 'authCallback Validation, one of the REQUIRED properties missing from id_token');\r\n                    toReturn.state = ValidationResult.RequiredPropertyMissing;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenIatMaxOffset(toReturn.decodedIdToken, maxIdTokenIatOffsetAllowedInSeconds, disableIatOffsetValidation, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback Validation, iat rejected id_token was issued too far away from the current time');\r\n                    toReturn.state = ValidationResult.MaxOffsetExpired;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                const authWellKnownEndPoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n                if (authWellKnownEndPoints) {\r\n                    if (issValidationOff) {\r\n                        this.loggerService.logDebug(configuration, 'iss validation is turned off, this is not recommended!');\r\n                    }\r\n                    else if (!issValidationOff &&\r\n                        !this.tokenValidationService.validateIdTokenIss(toReturn.decodedIdToken, authWellKnownEndPoints.issuer, configuration)) {\r\n                        this.loggerService.logWarning(configuration, 'authCallback incorrect iss does not match authWellKnownEndpoints issuer');\r\n                        toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\r\n                        this.handleUnsuccessfulValidation(configuration);\r\n                        return of(toReturn);\r\n                    }\r\n                }\r\n                else {\r\n                    this.loggerService.logWarning(configuration, 'authWellKnownEndpoints is undefined');\r\n                    toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAud(toReturn.decodedIdToken, clientId, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback incorrect aud');\r\n                    toReturn.state = ValidationResult.IncorrectAud;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAzpExistsIfMoreThanOneAud(toReturn.decodedIdToken)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback missing azp');\r\n                    toReturn.state = ValidationResult.IncorrectAzp;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenAzpValid(toReturn.decodedIdToken, clientId)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback incorrect azp');\r\n                    toReturn.state = ValidationResult.IncorrectAzp;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.isIdTokenAfterRefreshTokenRequestValid(callbackContext, toReturn.decodedIdToken, configuration)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback pre, post id_token claims do not match in refresh');\r\n                    toReturn.state = ValidationResult.IncorrectIdTokenClaimsAfterRefresh;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                if (!this.tokenValidationService.validateIdTokenExpNotExpired(toReturn.decodedIdToken, configuration, maxIdTokenIatOffsetAllowedInSeconds, disableIdTokenValidation)) {\r\n                    this.loggerService.logWarning(configuration, 'authCallback id token expired');\r\n                    toReturn.state = ValidationResult.TokenExpired;\r\n                    this.handleUnsuccessfulValidation(configuration);\r\n                    return of(toReturn);\r\n                }\r\n                return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\r\n            }));\r\n        }\r\n        else {\r\n            this.loggerService.logDebug(configuration, 'No id_token found, skipping id_token validation');\r\n        }\r\n        return this.validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext);\r\n    }\r\n    validateDefault(isCurrentFlowImplicitFlowWithAccessToken, isCurrentFlowCodeFlow, toReturn, configuration, callbackContext) {\r\n        // flow id_token\r\n        if (!isCurrentFlowImplicitFlowWithAccessToken && !isCurrentFlowCodeFlow) {\r\n            toReturn.authResponseIsValid = true;\r\n            toReturn.state = ValidationResult.Ok;\r\n            this.handleSuccessfulValidation(configuration);\r\n            this.handleUnsuccessfulValidation(configuration);\r\n            return of(toReturn);\r\n        }\r\n        // only do check if id_token returned, no always the case when using refresh tokens\r\n        if (callbackContext.authResult.id_token) {\r\n            const idTokenHeader = this.tokenHelperService.getHeaderFromToken(toReturn.idToken, false, configuration);\r\n            if (isCurrentFlowCodeFlow && !toReturn.decodedIdToken.at_hash) {\r\n                this.loggerService.logDebug(configuration, 'Code Flow active, and no at_hash in the id_token, skipping check!');\r\n            }\r\n            else {\r\n                return this.tokenValidationService\r\n                    .validateIdTokenAtHash(toReturn.accessToken, toReturn.decodedIdToken.at_hash, idTokenHeader.alg, // 'RS256'\r\n                configuration)\r\n                    .pipe(map((valid) => {\r\n                    if (!valid || !toReturn.accessToken) {\r\n                        this.loggerService.logWarning(configuration, 'authCallback incorrect at_hash');\r\n                        toReturn.state = ValidationResult.IncorrectAtHash;\r\n                        this.handleUnsuccessfulValidation(configuration);\r\n                        return toReturn;\r\n                    }\r\n                    else {\r\n                        toReturn.authResponseIsValid = true;\r\n                        toReturn.state = ValidationResult.Ok;\r\n                        this.handleSuccessfulValidation(configuration);\r\n                        return toReturn;\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        toReturn.authResponseIsValid = true;\r\n        toReturn.state = ValidationResult.Ok;\r\n        this.handleSuccessfulValidation(configuration);\r\n        return of(toReturn);\r\n    }\r\n    isIdTokenAfterRefreshTokenRequestValid(callbackContext, newIdToken, configuration) {\r\n        const { useRefreshToken, disableRefreshIdTokenAuthTimeValidation } = configuration;\r\n        if (!useRefreshToken) {\r\n            return true;\r\n        }\r\n        if (!callbackContext.existingIdToken) {\r\n            return true;\r\n        }\r\n        const decodedIdToken = this.tokenHelperService.getPayloadFromToken(callbackContext.existingIdToken, false, configuration);\r\n        // Upon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3\r\n        // except that it might not contain an id_token.\r\n        // If an ID Token is returned as a result of a token refresh request, the following requirements apply:\r\n        // its iss Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.iss !== newIdToken.iss) {\r\n            this.loggerService.logDebug(configuration, `iss do not match: ${decodedIdToken.iss} ${newIdToken.iss}`);\r\n            return false;\r\n        }\r\n        // its azp Claim Value MUST be the same as in the ID Token issued when the original authentication occurred;\r\n        //   if no azp Claim was present in the original ID Token, one MUST NOT be present in the new ID Token, and\r\n        // otherwise, the same rules apply as apply when issuing an ID Token at the time of the original authentication.\r\n        if (decodedIdToken.azp !== newIdToken.azp) {\r\n            this.loggerService.logDebug(configuration, `azp do not match: ${decodedIdToken.azp} ${newIdToken.azp}`);\r\n            return false;\r\n        }\r\n        // its sub Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (decodedIdToken.sub !== newIdToken.sub) {\r\n            this.loggerService.logDebug(configuration, `sub do not match: ${decodedIdToken.sub} ${newIdToken.sub}`);\r\n            return false;\r\n        }\r\n        // its aud Claim Value MUST be the same as in the ID Token issued when the original authentication occurred,\r\n        if (!this.equalityService.isStringEqualOrNonOrderedArrayEqual(decodedIdToken?.aud, newIdToken?.aud)) {\r\n            this.loggerService.logDebug(configuration, `aud in new id_token is not valid: '${decodedIdToken?.aud}' '${newIdToken.aud}'`);\r\n            return false;\r\n        }\r\n        if (disableRefreshIdTokenAuthTimeValidation) {\r\n            return true;\r\n        }\r\n        // its iat Claim MUST represent the time that the new ID Token is issued,\r\n        // if the ID Token contains an auth_time Claim, its value MUST represent the time of the original authentication\r\n        // - not the time that the new ID token is issued,\r\n        if (decodedIdToken.auth_time !== newIdToken.auth_time) {\r\n            this.loggerService.logDebug(configuration, `auth_time do not match: ${decodedIdToken.auth_time} ${newIdToken.auth_time}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    handleSuccessfulValidation(configuration) {\r\n        const { autoCleanStateAfterAuthentication } = configuration;\r\n        this.storagePersistenceService.write('authNonce', null, configuration);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configuration);\r\n        }\r\n        this.loggerService.logDebug(configuration, 'authCallback token(s) validated, continue');\r\n    }\r\n    handleUnsuccessfulValidation(configuration) {\r\n        const { autoCleanStateAfterAuthentication } = configuration;\r\n        this.storagePersistenceService.write('authNonce', null, configuration);\r\n        if (autoCleanStateAfterAuthentication) {\r\n            this.storagePersistenceService.write('authStateControl', '', configuration);\r\n        }\r\n        this.loggerService.logDebug(configuration, 'authCallback token(s) invalid');\r\n    }\r\n}\r\nStateValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StateValidationService, deps: [{ token: StoragePersistenceService }, { token: TokenValidationService }, { token: TokenHelperService }, { token: LoggerService }, { token: EqualityService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StateValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StateValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: TokenValidationService }, { type: TokenHelperService }, { type: LoggerService }, { type: EqualityService }, { type: FlowHelper }]; } });\n\nclass StateValidationCallbackHandlerService {\r\n    constructor(loggerService, stateValidationService, authStateService, resetAuthDataService, doc) {\r\n        this.loggerService = loggerService;\r\n        this.stateValidationService = stateValidationService;\r\n        this.authStateService = authStateService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.doc = doc;\r\n    }\r\n    // STEP 4 All flows\r\n    callbackStateValidation(callbackContext, configuration, allConfigs) {\r\n        return this.stateValidationService.getValidatedStateResult(callbackContext, configuration).pipe(map((validationResult) => {\r\n            callbackContext.validationResult = validationResult;\r\n            if (validationResult.authResponseIsValid) {\r\n                this.authStateService.setAuthorizationData(validationResult.accessToken, callbackContext.authResult, configuration, allConfigs);\r\n                return callbackContext;\r\n            }\r\n            else {\r\n                const errorMessage = `authorizedCallback, token(s) validation failed, resetting. Hash: ${this.doc.location.hash}`;\r\n                this.loggerService.logWarning(configuration, errorMessage);\r\n                this.resetAuthDataService.resetAuthorizationData(configuration, allConfigs);\r\n                this.publishUnauthorizedState(callbackContext.validationResult, callbackContext.isRenewProcess);\r\n                throw new Error(errorMessage);\r\n            }\r\n        }));\r\n    }\r\n    publishUnauthorizedState(stateValidationResult, isRenewProcess) {\r\n        this.authStateService.updateAndPublishAuthState({\r\n            isAuthenticated: false,\r\n            validationResult: stateValidationResult.state,\r\n            isRenewProcess,\r\n        });\r\n    }\r\n}\r\nStateValidationCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StateValidationCallbackHandlerService, deps: [{ token: LoggerService }, { token: StateValidationService }, { token: AuthStateService }, { token: ResetAuthDataService }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStateValidationCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StateValidationCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StateValidationCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: StateValidationService }, { type: AuthStateService }, { type: ResetAuthDataService }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass RefreshSessionCallbackHandlerService {\r\n    constructor(loggerService, authStateService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    // STEP 1 Refresh session\r\n    refreshSessionWithRefreshTokens(config) {\r\n        const stateData = this.flowsDataService.getExistingOrCreateAuthStateControl(config);\r\n        this.loggerService.logDebug(config, 'RefreshSession created. Adding myautostate: ' + stateData);\r\n        const refreshToken = this.authStateService.getRefreshToken(config);\r\n        const idToken = this.authStateService.getIdToken(config);\r\n        if (refreshToken) {\r\n            const callbackContext = {\r\n                code: null,\r\n                refreshToken,\r\n                state: stateData,\r\n                sessionState: null,\r\n                authResult: null,\r\n                isRenewProcess: true,\r\n                jwtKeys: null,\r\n                validationResult: null,\r\n                existingIdToken: idToken,\r\n            };\r\n            this.loggerService.logDebug(config, 'found refresh code, obtaining new credentials with refresh code');\r\n            // Nonce is not used with refresh tokens; but Key cloak may send it anyway\r\n            this.flowsDataService.setNonce(TokenValidationService.refreshTokenNoncePlaceholder, config);\r\n            return of(callbackContext);\r\n        }\r\n        else {\r\n            const errorMessage = 'no refresh token found, please login';\r\n            this.loggerService.logError(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n    }\r\n}\r\nRefreshSessionCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionCallbackHandlerService, deps: [{ token: LoggerService }, { token: AuthStateService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: AuthStateService }, { type: FlowsDataService }]; } });\n\nclass RefreshTokenCallbackHandlerService {\r\n    constructor(urlService, loggerService, dataService, storagePersistenceService) {\r\n        this.urlService = urlService;\r\n        this.loggerService = loggerService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    // STEP 2 Refresh Token\r\n    refreshTokensRequestTokens(callbackContext, config, customParamsRefresh) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellknownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n        const tokenEndpoint = authWellknownEndpoints?.tokenEndpoint;\r\n        if (!tokenEndpoint) {\r\n            return throwError(() => new Error('Token Endpoint not defined'));\r\n        }\r\n        const data = this.urlService.createBodyForCodeFlowRefreshTokensRequest(callbackContext.refreshToken, config, customParamsRefresh);\r\n        return this.dataService.post(tokenEndpoint, data, config, headers).pipe(switchMap((response) => {\r\n            this.loggerService.logDebug(config, 'token refresh response: ', response);\r\n            // TODO FGO LOOK AT THIS\r\n            let authResult = new Object();\r\n            authResult = response;\r\n            authResult.state = callbackContext.state;\r\n            callbackContext.authResult = authResult;\r\n            return of(callbackContext);\r\n        }), retryWhen((error) => this.handleRefreshRetry(error, config)), catchError((error) => {\r\n            const { authority } = config;\r\n            const errorMessage = `OidcService code request ${authority}`;\r\n            this.loggerService.logError(config, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n    handleRefreshRetry(errors, config) {\r\n        return errors.pipe(mergeMap((error) => {\r\n            // retry token refresh if there is no internet connection\r\n            if (error && error instanceof HttpErrorResponse && error.error instanceof ProgressEvent && error.error.type === 'error') {\r\n                const { authority, refreshTokenRetryInSeconds } = config;\r\n                const errorMessage = `OidcService code request ${authority} - no internet connection`;\r\n                this.loggerService.logWarning(config, errorMessage, error);\r\n                return timer(refreshTokenRetryInSeconds * 1000);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nRefreshTokenCallbackHandlerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshTokenCallbackHandlerService, deps: [{ token: UrlService }, { token: LoggerService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshTokenCallbackHandlerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshTokenCallbackHandlerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshTokenCallbackHandlerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: LoggerService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass FlowsService {\r\n    constructor(codeFlowCallbackHandlerService, implicitFlowCallbackHandlerService, historyJwtKeysCallbackHandlerService, userHandlerService, stateValidationCallbackHandlerService, refreshSessionCallbackHandlerService, refreshTokenCallbackHandlerService) {\r\n        this.codeFlowCallbackHandlerService = codeFlowCallbackHandlerService;\r\n        this.implicitFlowCallbackHandlerService = implicitFlowCallbackHandlerService;\r\n        this.historyJwtKeysCallbackHandlerService = historyJwtKeysCallbackHandlerService;\r\n        this.userHandlerService = userHandlerService;\r\n        this.stateValidationCallbackHandlerService = stateValidationCallbackHandlerService;\r\n        this.refreshSessionCallbackHandlerService = refreshSessionCallbackHandlerService;\r\n        this.refreshTokenCallbackHandlerService = refreshTokenCallbackHandlerService;\r\n    }\r\n    processCodeFlowCallback(urlToCheck, config, allConfigs) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCallback(urlToCheck, config).pipe(concatMap((callbackContext) => this.codeFlowCallbackHandlerService.codeFlowCodeRequest(callbackContext, config)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n    processSilentRenewCodeFlowCallback(firstContext, config, allConfigs) {\r\n        return this.codeFlowCallbackHandlerService.codeFlowCodeRequest(firstContext, config).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n    processImplicitFlowCallback(config, allConfigs, hash) {\r\n        return this.implicitFlowCallbackHandlerService.implicitFlowCallback(config, allConfigs, hash).pipe(concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n    processRefreshToken(config, allConfigs, customParamsRefresh) {\r\n        return this.refreshSessionCallbackHandlerService.refreshSessionWithRefreshTokens(config).pipe(concatMap((callbackContext) => this.refreshTokenCallbackHandlerService.refreshTokensRequestTokens(callbackContext, config, customParamsRefresh)), concatMap((callbackContext) => this.historyJwtKeysCallbackHandlerService.callbackHistoryAndResetJwtKeys(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.stateValidationCallbackHandlerService.callbackStateValidation(callbackContext, config, allConfigs)), concatMap((callbackContext) => this.userHandlerService.callbackUser(callbackContext, config, allConfigs)));\r\n    }\r\n}\r\nFlowsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowsService, deps: [{ token: CodeFlowCallbackHandlerService }, { token: ImplicitFlowCallbackHandlerService }, { token: HistoryJwtKeysCallbackHandlerService }, { token: UserCallbackHandlerService }, { token: StateValidationCallbackHandlerService }, { token: RefreshSessionCallbackHandlerService }, { token: RefreshTokenCallbackHandlerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nFlowsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowsService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: FlowsService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CodeFlowCallbackHandlerService }, { type: ImplicitFlowCallbackHandlerService }, { type: HistoryJwtKeysCallbackHandlerService }, { type: UserCallbackHandlerService }, { type: StateValidationCallbackHandlerService }, { type: RefreshSessionCallbackHandlerService }, { type: RefreshTokenCallbackHandlerService }]; } });\n\nclass IntervalService {\r\n    constructor(zone) {\r\n        this.zone = zone;\r\n        this.runTokenValidationRunning = null;\r\n    }\r\n    isTokenValidationRunning() {\r\n        return !!this.runTokenValidationRunning;\r\n    }\r\n    stopPeriodicTokenCheck() {\r\n        if (this.runTokenValidationRunning) {\r\n            this.runTokenValidationRunning.unsubscribe();\r\n            this.runTokenValidationRunning = null;\r\n        }\r\n    }\r\n    startPeriodicTokenCheck(repeatAfterSeconds) {\r\n        const millisecondsDelayBetweenTokenCheck = repeatAfterSeconds * 1000;\r\n        return new Observable((subscriber) => {\r\n            let intervalId;\r\n            this.zone.runOutsideAngular(() => {\r\n                intervalId = setInterval(() => this.zone.run(() => subscriber.next()), millisecondsDelayBetweenTokenCheck);\r\n            });\r\n            return () => {\r\n                clearInterval(intervalId);\r\n            };\r\n        });\r\n    }\r\n}\r\nIntervalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: IntervalService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nIntervalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: IntervalService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: IntervalService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass ImplicitFlowCallbackService {\r\n    constructor(flowsService, router, flowsDataService, intervalService) {\r\n        this.flowsService = flowsService;\r\n        this.router = router;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    authenticatedImplicitFlowCallback(config, allConfigs, hash) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = config;\r\n        return this.flowsService.processImplicitFlowCallback(config, allConfigs, hash).pipe(tap((callbackContext) => {\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nImplicitFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ImplicitFlowCallbackService, deps: [{ token: FlowsService }, { token: i2.Router }, { token: FlowsDataService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nImplicitFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ImplicitFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ImplicitFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: i2.Router }, { type: FlowsDataService }, { type: IntervalService }]; } });\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\r\nclass SilentRenewService {\r\n    constructor(iFrameService, flowsService, resetAuthDataService, flowsDataService, authStateService, loggerService, flowHelper, implicitFlowCallbackService, intervalService) {\r\n        this.iFrameService = iFrameService;\r\n        this.flowsService = flowsService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.authStateService = authStateService;\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.intervalService = intervalService;\r\n        this.refreshSessionWithIFrameCompletedInternal$ = new Subject();\r\n    }\r\n    get refreshSessionWithIFrameCompleted$() {\r\n        return this.refreshSessionWithIFrameCompletedInternal$.asObservable();\r\n    }\r\n    getOrCreateIframe(config) {\r\n        const existingIframe = this.getExistingIframe();\r\n        if (!existingIframe) {\r\n            return this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER, config);\r\n        }\r\n        return existingIframe;\r\n    }\r\n    isSilentRenewConfigured(configuration) {\r\n        const { useRefreshToken, silentRenew } = configuration;\r\n        return !useRefreshToken && silentRenew;\r\n    }\r\n    codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs) {\r\n        const params = new HttpParams({\r\n            fromString: urlParts[1],\r\n        });\r\n        const error = params.get('error');\r\n        if (error) {\r\n            this.authStateService.updateAndPublishAuthState({\r\n                isAuthenticated: false,\r\n                validationResult: ValidationResult.LoginRequired,\r\n                isRenewProcess: true,\r\n            });\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            this.flowsDataService.setNonce('', config);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            return throwError(() => new Error(error));\r\n        }\r\n        const code = params.get('code');\r\n        const state = params.get('state');\r\n        const sessionState = params.get('session_state');\r\n        const callbackContext = {\r\n            code,\r\n            refreshToken: null,\r\n            state,\r\n            sessionState,\r\n            authResult: null,\r\n            isRenewProcess: true,\r\n            jwtKeys: null,\r\n            validationResult: null,\r\n            existingIdToken: null,\r\n        };\r\n        return this.flowsService.processSilentRenewCodeFlowCallback(callbackContext, config, allConfigs).pipe(catchError(() => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n    silentRenewEventHandler(e, config, allConfigs) {\r\n        this.loggerService.logDebug(config, 'silentRenewEventHandler');\r\n        if (!e.detail) {\r\n            return;\r\n        }\r\n        let callback$ = of(null);\r\n        const isCodeFlow = this.flowHelper.isCurrentFlowCodeFlow(config);\r\n        if (isCodeFlow) {\r\n            const urlParts = e.detail.toString().split('?');\r\n            callback$ = this.codeFlowCallbackSilentRenewIframe(urlParts, config, allConfigs);\r\n        }\r\n        else {\r\n            callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, e.detail);\r\n        }\r\n        callback$.subscribe({\r\n            next: (callbackContext) => {\r\n                this.refreshSessionWithIFrameCompletedInternal$.next(callbackContext);\r\n                this.flowsDataService.resetSilentRenewRunning(config);\r\n            },\r\n            error: (err) => {\r\n                this.loggerService.logError(config, 'Error: ' + err);\r\n                this.refreshSessionWithIFrameCompletedInternal$.next(null);\r\n                this.flowsDataService.resetSilentRenewRunning(config);\r\n            },\r\n        });\r\n    }\r\n    getExistingIframe() {\r\n        return this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\r\n    }\r\n}\r\nSilentRenewService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SilentRenewService, deps: [{ token: IFrameService }, { token: FlowsService }, { token: ResetAuthDataService }, { token: FlowsDataService }, { token: AuthStateService }, { token: LoggerService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nSilentRenewService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SilentRenewService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: SilentRenewService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: IFrameService }, { type: FlowsService }, { type: ResetAuthDataService }, { type: FlowsDataService }, { type: AuthStateService }, { type: LoggerService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: IntervalService }]; } });\n\nclass CodeFlowCallbackService {\r\n    constructor(flowsService, flowsDataService, intervalService, router) {\r\n        this.flowsService = flowsService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.intervalService = intervalService;\r\n        this.router = router;\r\n    }\r\n    authenticatedCallbackWithCode(urlToCheck, config, allConfigs) {\r\n        const isRenewProcess = this.flowsDataService.isSilentRenewRunning(config);\r\n        const { triggerAuthorizationResultEvent, postLoginRoute, unauthorizedRoute } = config;\r\n        return this.flowsService.processCodeFlowCallback(urlToCheck, config, allConfigs).pipe(tap((callbackContext) => {\r\n            this.flowsDataService.resetCodeFlowInProgress(config);\r\n            if (!triggerAuthorizationResultEvent && !callbackContext.isRenewProcess) {\r\n                this.router.navigateByUrl(postLoginRoute);\r\n            }\r\n        }), catchError((error) => {\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            this.flowsDataService.resetCodeFlowInProgress(config);\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            if (!triggerAuthorizationResultEvent && !isRenewProcess) {\r\n                this.router.navigateByUrl(unauthorizedRoute);\r\n            }\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nCodeFlowCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CodeFlowCallbackService, deps: [{ token: FlowsService }, { token: FlowsDataService }, { token: IntervalService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCodeFlowCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CodeFlowCallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CodeFlowCallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowsService }, { type: FlowsDataService }, { type: IntervalService }, { type: i2.Router }]; } });\n\nclass CallbackService {\r\n    constructor(urlService, flowHelper, implicitFlowCallbackService, codeFlowCallbackService) {\r\n        this.urlService = urlService;\r\n        this.flowHelper = flowHelper;\r\n        this.implicitFlowCallbackService = implicitFlowCallbackService;\r\n        this.codeFlowCallbackService = codeFlowCallbackService;\r\n        this.stsCallbackInternal$ = new Subject();\r\n    }\r\n    get stsCallback$() {\r\n        return this.stsCallbackInternal$.asObservable();\r\n    }\r\n    isCallback(currentUrl) {\r\n        return this.urlService.isCallbackFromSts(currentUrl);\r\n    }\r\n    handleCallbackAndFireEvents(currentCallbackUrl, config, allConfigs) {\r\n        let callback$;\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(config)) {\r\n            callback$ = this.codeFlowCallbackService.authenticatedCallbackWithCode(currentCallbackUrl, config, allConfigs);\r\n        }\r\n        else if (this.flowHelper.isCurrentFlowAnyImplicitFlow(config)) {\r\n            if (currentCallbackUrl?.includes('#')) {\r\n                let hash = currentCallbackUrl.substring(currentCallbackUrl.indexOf('#') + 1);\r\n                callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs, hash);\r\n            }\r\n            else {\r\n                callback$ = this.implicitFlowCallbackService.authenticatedImplicitFlowCallback(config, allConfigs);\r\n            }\r\n        }\r\n        return callback$.pipe(tap(() => this.stsCallbackInternal$.next()));\r\n    }\r\n}\r\nCallbackService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CallbackService, deps: [{ token: UrlService }, { token: FlowHelper }, { token: ImplicitFlowCallbackService }, { token: CodeFlowCallbackService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCallbackService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CallbackService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CallbackService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: UrlService }, { type: FlowHelper }, { type: ImplicitFlowCallbackService }, { type: CodeFlowCallbackService }]; } });\n\nconst WELL_KNOWN_SUFFIX = `/.well-known/openid-configuration`;\r\nclass AuthWellKnownDataService {\r\n    constructor(http, loggerService) {\r\n        this.http = http;\r\n        this.loggerService = loggerService;\r\n    }\r\n    getWellKnownEndPointsForConfig(config) {\r\n        const { authWellknownEndpointUrl } = config;\r\n        if (!authWellknownEndpointUrl) {\r\n            const errorMessage = 'no authWellknownEndpoint given!';\r\n            this.loggerService.logError(config, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        return this.getWellKnownDocument(authWellknownEndpointUrl, config).pipe(map((wellKnownEndpoints) => ({\r\n            issuer: wellKnownEndpoints.issuer,\r\n            jwksUri: wellKnownEndpoints.jwks_uri,\r\n            authorizationEndpoint: wellKnownEndpoints.authorization_endpoint,\r\n            tokenEndpoint: wellKnownEndpoints.token_endpoint,\r\n            userInfoEndpoint: wellKnownEndpoints.userinfo_endpoint,\r\n            endSessionEndpoint: wellKnownEndpoints.end_session_endpoint,\r\n            checkSessionIframe: wellKnownEndpoints.check_session_iframe,\r\n            revocationEndpoint: wellKnownEndpoints.revocation_endpoint,\r\n            introspectionEndpoint: wellKnownEndpoints.introspection_endpoint,\r\n            parEndpoint: wellKnownEndpoints.pushed_authorization_request_endpoint,\r\n        })));\r\n    }\r\n    getWellKnownDocument(wellKnownEndpoint, config) {\r\n        let url = wellKnownEndpoint;\r\n        if (!wellKnownEndpoint.includes(WELL_KNOWN_SUFFIX)) {\r\n            url = `${wellKnownEndpoint}${WELL_KNOWN_SUFFIX}`;\r\n        }\r\n        return this.http.get(url, config).pipe(retry(2));\r\n    }\r\n}\r\nAuthWellKnownDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthWellKnownDataService, deps: [{ token: DataService }, { token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthWellKnownDataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthWellKnownDataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: LoggerService }]; } });\n\nclass AuthWellKnownService {\r\n    constructor(dataService, publicEventsService, storagePersistenceService) {\r\n        this.dataService = dataService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    storeWellKnownEndpoints(config, mappedWellKnownEndpoints) {\r\n        this.storagePersistenceService.write('authWellKnownEndPoints', mappedWellKnownEndpoints, config);\r\n    }\r\n    queryAndStoreAuthWellKnownEndPoints(config) {\r\n        const alreadySavedWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', config);\r\n        if (!!alreadySavedWellKnownEndpoints) {\r\n            return of(alreadySavedWellKnownEndpoints);\r\n        }\r\n        return this.dataService.getWellKnownEndPointsForConfig(config).pipe(tap((mappedWellKnownEndpoints) => this.storeWellKnownEndpoints(config, mappedWellKnownEndpoints)), catchError((error) => {\r\n            this.publicEventsService.fireEvent(EventTypes.ConfigLoadingFailed, null);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nAuthWellKnownService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthWellKnownService, deps: [{ token: AuthWellKnownDataService }, { token: PublicEventsService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthWellKnownService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthWellKnownService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthWellKnownService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthWellKnownDataService }, { type: PublicEventsService }, { type: StoragePersistenceService }]; } });\n\nclass RefreshSessionIframeService {\r\n    constructor(doc, loggerService, urlService, silentRenewService, rendererFactory) {\r\n        this.doc = doc;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.renderer = rendererFactory.createRenderer(null, null);\r\n    }\r\n    refreshSessionWithIframe(config, allConfigs, customParams) {\r\n        this.loggerService.logDebug(config, 'BEGIN refresh session Authorize Iframe renew');\r\n        return this.urlService.getRefreshSessionSilentRenewUrl(config, customParams).pipe(switchMap((url) => {\r\n            return this.sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs);\r\n        }));\r\n    }\r\n    sendAuthorizeRequestUsingSilentRenew(url, config, allConfigs) {\r\n        const sessionIframe = this.silentRenewService.getOrCreateIframe(config);\r\n        this.initSilentRenewRequest(config, allConfigs);\r\n        this.loggerService.logDebug(config, 'sendAuthorizeRequestUsingSilentRenew for URL:' + url);\r\n        return new Observable((observer) => {\r\n            const onLoadHandler = () => {\r\n                sessionIframe.removeEventListener('load', onLoadHandler);\r\n                this.loggerService.logDebug(config, 'removed event listener from IFrame');\r\n                observer.next(true);\r\n                observer.complete();\r\n            };\r\n            sessionIframe.addEventListener('load', onLoadHandler);\r\n            sessionIframe.contentWindow.location.replace(url);\r\n        });\r\n    }\r\n    initSilentRenewRequest(config, allConfigs) {\r\n        const instanceId = Math.random();\r\n        const initDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-init', (e) => {\r\n            if (e.detail !== instanceId) {\r\n                initDestroyHandler();\r\n                renewDestroyHandler();\r\n            }\r\n        });\r\n        const renewDestroyHandler = this.renderer.listen('window', 'oidc-silent-renew-message', (e) => this.silentRenewService.silentRenewEventHandler(e, config, allConfigs));\r\n        this.doc.defaultView.dispatchEvent(new CustomEvent('oidc-silent-renew-init', {\r\n            detail: instanceId,\r\n        }));\r\n    }\r\n}\r\nRefreshSessionIframeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionIframeService, deps: [{ token: DOCUMENT }, { token: LoggerService }, { token: UrlService }, { token: SilentRenewService }, { token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionIframeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionIframeService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionIframeService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }, { type: LoggerService }, { type: UrlService }, { type: SilentRenewService }, { type: i0.RendererFactory2 }]; } });\n\nclass RefreshSessionRefreshTokenService {\r\n    constructor(loggerService, resetAuthDataService, flowsService, intervalService) {\r\n        this.loggerService = loggerService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowsService = flowsService;\r\n        this.intervalService = intervalService;\r\n    }\r\n    refreshSessionWithRefreshTokens(config, allConfigs, customParamsRefresh) {\r\n        this.loggerService.logDebug(config, 'BEGIN refresh session Authorize');\r\n        return this.flowsService.processRefreshToken(config, allConfigs, customParamsRefresh).pipe(catchError((error) => {\r\n            this.intervalService.stopPeriodicTokenCheck();\r\n            this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n    }\r\n}\r\nRefreshSessionRefreshTokenService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionRefreshTokenService, deps: [{ token: LoggerService }, { token: ResetAuthDataService }, { token: FlowsService }, { token: IntervalService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionRefreshTokenService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionRefreshTokenService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionRefreshTokenService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResetAuthDataService }, { type: FlowsService }, { type: IntervalService }]; } });\n\nconst MAX_RETRY_ATTEMPTS = 3;\r\nclass RefreshSessionService {\r\n    constructor(flowHelper, flowsDataService, loggerService, silentRenewService, authStateService, authWellKnownService, refreshSessionIframeService, storagePersistenceService, refreshSessionRefreshTokenService, userService) {\r\n        this.flowHelper = flowHelper;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.authStateService = authStateService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.userService = userService;\r\n    }\r\n    userForceRefreshSession(config, allConfigs, extraCustomParams) {\r\n        this.persistCustomParams(extraCustomParams, config);\r\n        return this.forceRefreshSession(config, allConfigs, extraCustomParams);\r\n    }\r\n    forceRefreshSession(config, allConfigs, extraCustomParams) {\r\n        const { customParamsRefreshTokenRequest, configId } = config;\r\n        const mergedParams = { ...customParamsRefreshTokenRequest, ...extraCustomParams };\r\n        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n            return this.startRefreshSession(config, allConfigs, mergedParams).pipe(map(() => {\r\n                const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\r\n                if (isAuthenticated) {\r\n                    return {\r\n                        idToken: this.authStateService.getIdToken(config),\r\n                        accessToken: this.authStateService.getAccessToken(config),\r\n                        userData: this.userService.getUserDataFromStore(config),\r\n                        isAuthenticated,\r\n                        configId,\r\n                    };\r\n                }\r\n                return null;\r\n            }));\r\n        }\r\n        const { silentRenewTimeoutInSeconds } = config;\r\n        const timeOutTime = silentRenewTimeoutInSeconds * 1000;\r\n        return forkJoin([\r\n            this.startRefreshSession(config, allConfigs, extraCustomParams),\r\n            this.silentRenewService.refreshSessionWithIFrameCompleted$.pipe(take(1)),\r\n        ]).pipe(timeout(timeOutTime), retryWhen(this.timeoutRetryStrategy.bind(this)), map(([_, callbackContext]) => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\r\n            if (isAuthenticated) {\r\n                return {\r\n                    idToken: callbackContext?.authResult?.id_token,\r\n                    accessToken: callbackContext?.authResult?.access_token,\r\n                    userData: this.userService.getUserDataFromStore(config),\r\n                    isAuthenticated,\r\n                    configId,\r\n                };\r\n            }\r\n            return null;\r\n        }));\r\n    }\r\n    persistCustomParams(extraCustomParams, config) {\r\n        const { useRefreshToken } = config;\r\n        if (extraCustomParams) {\r\n            if (useRefreshToken) {\r\n                this.storagePersistenceService.write('storageCustomParamsRefresh', extraCustomParams, config);\r\n            }\r\n            else {\r\n                this.storagePersistenceService.write('storageCustomParamsAuthRequest', extraCustomParams, config);\r\n            }\r\n        }\r\n    }\r\n    startRefreshSession(config, allConfigs, extraCustomParams) {\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\r\n        this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}`);\r\n        const shouldBeExecuted = !isSilentRenewRunning;\r\n        if (!shouldBeExecuted) {\r\n            return of(null);\r\n        }\r\n        return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config).pipe(switchMap(() => {\r\n            this.flowsDataService.setSilentRenewRunning(config);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, extraCustomParams);\r\n            }\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, extraCustomParams);\r\n        }));\r\n    }\r\n    timeoutRetryStrategy(errorAttempts, config) {\r\n        return errorAttempts.pipe(mergeMap((error, index) => {\r\n            const scalingDuration = 1000;\r\n            const currentAttempt = index + 1;\r\n            if (!(error instanceof TimeoutError) || currentAttempt > MAX_RETRY_ATTEMPTS) {\r\n                return throwError(() => new Error(error));\r\n            }\r\n            this.loggerService.logDebug(config, `forceRefreshSession timeout. Attempt #${currentAttempt}`);\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            return timer(currentAttempt * scalingDuration);\r\n        }));\r\n    }\r\n}\r\nRefreshSessionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionService, deps: [{ token: FlowHelper }, { token: FlowsDataService }, { token: LoggerService }, { token: SilentRenewService }, { token: AuthStateService }, { token: AuthWellKnownService }, { token: RefreshSessionIframeService }, { token: StoragePersistenceService }, { token: RefreshSessionRefreshTokenService }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRefreshSessionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RefreshSessionService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: FlowHelper }, { type: FlowsDataService }, { type: LoggerService }, { type: SilentRenewService }, { type: AuthStateService }, { type: AuthWellKnownService }, { type: RefreshSessionIframeService }, { type: StoragePersistenceService }, { type: RefreshSessionRefreshTokenService }, { type: UserService }]; } });\n\nconst DEFAULT_CONFIG = {\r\n    authority: 'https://please_set',\r\n    authWellknownEndpointUrl: '',\r\n    authWellknownEndpoints: null,\r\n    redirectUrl: 'https://please_set',\r\n    clientId: 'please_set',\r\n    responseType: 'code',\r\n    scope: 'openid email profile',\r\n    hdParam: '',\r\n    postLogoutRedirectUri: 'https://please_set',\r\n    startCheckSession: false,\r\n    silentRenew: false,\r\n    silentRenewUrl: 'https://please_set',\r\n    silentRenewTimeoutInSeconds: 20,\r\n    renewTimeBeforeTokenExpiresInSeconds: 0,\r\n    useRefreshToken: false,\r\n    usePushedAuthorisationRequests: false,\r\n    ignoreNonceAfterRefresh: false,\r\n    postLoginRoute: '/',\r\n    forbiddenRoute: '/forbidden',\r\n    unauthorizedRoute: '/unauthorized',\r\n    autoUserInfo: true,\r\n    autoCleanStateAfterAuthentication: true,\r\n    triggerAuthorizationResultEvent: false,\r\n    logLevel: LogLevel.Warn,\r\n    issValidationOff: false,\r\n    historyCleanupOff: false,\r\n    maxIdTokenIatOffsetAllowedInSeconds: 120,\r\n    disableIatOffsetValidation: false,\r\n    customParamsAuthRequest: {},\r\n    customParamsRefreshTokenRequest: {},\r\n    customParamsEndSessionRequest: {},\r\n    customParamsCodeRequest: {},\r\n    disableRefreshIdTokenAuthTimeValidation: false,\r\n    enableIdTokenExpiredValidationInRenew: true,\r\n    tokenRefreshInSeconds: 4,\r\n    refreshTokenRetryInSeconds: 3,\r\n    ngswBypass: false,\r\n};\n\nconst POSITIVE_VALIDATION_RESULT = {\r\n    result: true,\r\n    messages: [],\r\n    level: null,\r\n};\n\nconst ensureAuthority = (passedConfig) => {\r\n    if (!passedConfig.authority) {\r\n        return {\r\n            result: false,\r\n            messages: ['The authority URL MUST be provided in the configuration! '],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureClientId = (passedConfig) => {\r\n    if (!passedConfig.clientId) {\r\n        return {\r\n            result: false,\r\n            messages: ['The clientId is required and missing from your config!'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst createIdentifierToCheck = (passedConfig) => {\r\n    if (!passedConfig) {\r\n        return null;\r\n    }\r\n    const { authority, clientId, scope } = passedConfig;\r\n    return `${authority}${clientId}${scope}`;\r\n};\r\nconst arrayHasDuplicates = (array) => new Set(array).size !== array.length;\r\nconst ensureNoDuplicatedConfigsRule = (passedConfigs) => {\r\n    const allIdentifiers = passedConfigs.map((x) => createIdentifierToCheck(x));\r\n    const someAreNull = allIdentifiers.some((x) => x === null);\r\n    if (someAreNull) {\r\n        return {\r\n            result: false,\r\n            messages: [`Please make sure you add an object with a 'config' property: ....({ config }) instead of ...(config)`],\r\n            level: 'error',\r\n        };\r\n    }\r\n    const hasDuplicates = arrayHasDuplicates(allIdentifiers);\r\n    if (hasDuplicates) {\r\n        return {\r\n            result: false,\r\n            messages: ['You added multiple configs with the same authority, clientId and scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureRedirectRule = (passedConfig) => {\r\n    if (!passedConfig.redirectUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['The redirectUrl is required and missing from your config'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst ensureSilentRenewUrlWhenNoRefreshTokenUsed = (passedConfig) => {\r\n    const usesSilentRenew = passedConfig.silentRenew;\r\n    const usesRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenewUrl = passedConfig.silentRenewUrl;\r\n    if (usesSilentRenew && !usesRefreshToken && !hasSilentRenewUrl) {\r\n        return {\r\n            result: false,\r\n            messages: ['Please provide a silent renew URL if using renew and not refresh tokens'],\r\n            level: 'error',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst useOfflineScopeWithSilentRenew = (passedConfig) => {\r\n    const hasRefreshToken = passedConfig.useRefreshToken;\r\n    const hasSilentRenew = passedConfig.silentRenew;\r\n    const scope = passedConfig.scope || '';\r\n    const hasOfflineScope = scope.split(' ').includes('offline_access');\r\n    if (hasRefreshToken && hasSilentRenew && !hasOfflineScope) {\r\n        return {\r\n            result: false,\r\n            messages: ['When using silent renew and refresh tokens please set the `offline_access` scope'],\r\n            level: 'warning',\r\n        };\r\n    }\r\n    return POSITIVE_VALIDATION_RESULT;\r\n};\n\nconst allRules = [\r\n    ensureAuthority,\r\n    useOfflineScopeWithSilentRenew,\r\n    ensureRedirectRule,\r\n    ensureClientId,\r\n    ensureSilentRenewUrlWhenNoRefreshTokenUsed,\r\n];\r\nconst allMultipleConfigRules = [ensureNoDuplicatedConfigsRule];\n\nclass ConfigValidationService {\r\n    constructor(loggerService) {\r\n        this.loggerService = loggerService;\r\n    }\r\n    validateConfigs(passedConfigs) {\r\n        return this.validateConfigsInternal(passedConfigs ?? [], allMultipleConfigRules);\r\n    }\r\n    validateConfig(passedConfig) {\r\n        return this.validateConfigInternal(passedConfig, allRules);\r\n    }\r\n    validateConfigsInternal(passedConfigs, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfigs));\r\n        let overallErrorCount = 0;\r\n        passedConfigs.forEach((passedConfig) => {\r\n            const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\r\n            overallErrorCount += errorCount;\r\n        });\r\n        return overallErrorCount === 0;\r\n    }\r\n    validateConfigInternal(passedConfig, allRulesToUse) {\r\n        const allValidationResults = allRulesToUse.map((rule) => rule(passedConfig));\r\n        const errorCount = this.processValidationResultsAndGetErrorCount(allValidationResults, passedConfig);\r\n        return errorCount === 0;\r\n    }\r\n    processValidationResultsAndGetErrorCount(allValidationResults, config) {\r\n        const allMessages = allValidationResults.filter((x) => x.messages.length > 0);\r\n        const allErrorMessages = this.getAllMessagesOfType('error', allMessages);\r\n        const allWarnings = this.getAllMessagesOfType('warning', allMessages);\r\n        allErrorMessages.forEach((message) => this.loggerService.logError(config, message));\r\n        allWarnings.forEach((message) => this.loggerService.logWarning(config, message));\r\n        return allErrorMessages.length;\r\n    }\r\n    getAllMessagesOfType(type, results) {\r\n        const allMessages = results.filter((x) => x.level === type).map((result) => result.messages);\r\n        return allMessages.reduce((acc, val) => acc.concat(val), []);\r\n    }\r\n}\r\nConfigValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConfigValidationService, deps: [{ token: LoggerService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConfigValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConfigValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }]; } });\n\nclass PlatformProvider {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n    }\r\n    isBrowser() {\r\n        return isPlatformBrowser(this.platformId);\r\n    }\r\n}\r\nPlatformProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PlatformProvider, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPlatformProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PlatformProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PlatformProvider, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; } });\n\nclass OpenIdConfigLoader {\r\n}\r\nclass StsConfigLoader {\r\n}\r\nclass StsConfigStaticLoader {\r\n    constructor(passedConfigs) {\r\n        this.passedConfigs = passedConfigs;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.passedConfigs)) {\r\n            return of(this.passedConfigs);\r\n        }\r\n        return of([this.passedConfigs]);\r\n    }\r\n}\r\nclass StsConfigHttpLoader {\r\n    constructor(configs$) {\r\n        this.configs$ = configs$;\r\n    }\r\n    loadConfigs() {\r\n        if (Array.isArray(this.configs$)) {\r\n            return forkJoin(this.configs$);\r\n        }\r\n        const singleConfigOrArray = this.configs$;\r\n        return singleConfigOrArray.pipe(map((value) => {\r\n            if (Array.isArray(value)) {\r\n                return value;\r\n            }\r\n            return [value];\r\n        }));\r\n    }\r\n}\n\nclass ConfigurationService {\r\n    constructor(loggerService, publicEventsService, storagePersistenceService, configValidationService, platformProvider, authWellKnownService, loader) {\r\n        this.loggerService = loggerService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.configValidationService = configValidationService;\r\n        this.platformProvider = platformProvider;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.loader = loader;\r\n        this.configsInternal = {};\r\n    }\r\n    hasManyConfigs() {\r\n        return Object.keys(this.configsInternal).length > 1;\r\n    }\r\n    getAllConfigurations() {\r\n        return Object.values(this.configsInternal);\r\n    }\r\n    getOpenIDConfiguration(configId) {\r\n        if (this.configsAlreadySaved()) {\r\n            return of(this.getConfig(configId));\r\n        }\r\n        return this.getOpenIDConfigurations(configId).pipe(map((result) => result.currentConfig));\r\n    }\r\n    getOpenIDConfigurations(configId) {\r\n        return this.loadConfigs().pipe(concatMap((allConfigs) => this.prepareAndSaveConfigs(allConfigs)), map((allPreparedConfigs) => ({\r\n            allConfigs: allPreparedConfigs,\r\n            currentConfig: this.getConfig(configId),\r\n        })));\r\n    }\r\n    hasAtLeastOneConfig() {\r\n        return Object.keys(this.configsInternal).length > 0;\r\n    }\r\n    saveConfig(readyConfig) {\r\n        const { configId } = readyConfig;\r\n        this.configsInternal[configId] = readyConfig;\r\n    }\r\n    loadConfigs() {\r\n        return this.loader.loadConfigs();\r\n    }\r\n    configsAlreadySaved() {\r\n        return this.hasAtLeastOneConfig();\r\n    }\r\n    getConfig(configId) {\r\n        if (!!configId) {\r\n            return this.configsInternal[configId] || null;\r\n        }\r\n        const [, value] = Object.entries(this.configsInternal)[0] || [[null, null]];\r\n        return value || null;\r\n    }\r\n    prepareAndSaveConfigs(passedConfigs) {\r\n        if (!this.configValidationService.validateConfigs(passedConfigs)) {\r\n            return of(null);\r\n        }\r\n        this.createUniqueIds(passedConfigs);\r\n        const allHandleConfigs$ = passedConfigs.map((x) => this.handleConfig(x));\r\n        return forkJoin(allHandleConfigs$);\r\n    }\r\n    createUniqueIds(passedConfigs) {\r\n        passedConfigs.forEach((config, index) => {\r\n            if (!config.configId) {\r\n                config.configId = `${index}-${config.clientId}`;\r\n            }\r\n        });\r\n    }\r\n    handleConfig(passedConfig) {\r\n        if (!this.configValidationService.validateConfig(passedConfig)) {\r\n            this.loggerService.logError(passedConfig, 'Validation of config rejected with errors. Config is NOT set.');\r\n            return of(null);\r\n        }\r\n        if (!passedConfig.authWellknownEndpointUrl) {\r\n            passedConfig.authWellknownEndpointUrl = passedConfig.authority;\r\n        }\r\n        const usedConfig = this.prepareConfig(passedConfig);\r\n        this.saveConfig(usedConfig);\r\n        const configWithAuthWellKnown = this.enhanceConfigWithWellKnownEndpoint(usedConfig);\r\n        this.publicEventsService.fireEvent(EventTypes.ConfigLoaded, configWithAuthWellKnown);\r\n        return of(usedConfig);\r\n    }\r\n    enhanceConfigWithWellKnownEndpoint(configuration) {\r\n        const alreadyExistingAuthWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!!alreadyExistingAuthWellKnownEndpoints) {\r\n            configuration.authWellknownEndpoints = alreadyExistingAuthWellKnownEndpoints;\r\n            return configuration;\r\n        }\r\n        const passedAuthWellKnownEndpoints = configuration.authWellknownEndpoints;\r\n        if (!!passedAuthWellKnownEndpoints) {\r\n            this.authWellKnownService.storeWellKnownEndpoints(configuration, passedAuthWellKnownEndpoints);\r\n            configuration.authWellknownEndpoints = passedAuthWellKnownEndpoints;\r\n            return configuration;\r\n        }\r\n        return configuration;\r\n    }\r\n    prepareConfig(configuration) {\r\n        const openIdConfigurationInternal = { ...DEFAULT_CONFIG, ...configuration };\r\n        this.setSpecialCases(openIdConfigurationInternal);\r\n        return openIdConfigurationInternal;\r\n    }\r\n    setSpecialCases(currentConfig) {\r\n        if (!this.platformProvider.isBrowser()) {\r\n            currentConfig.startCheckSession = false;\r\n            currentConfig.silentRenew = false;\r\n            currentConfig.useRefreshToken = false;\r\n            currentConfig.usePushedAuthorisationRequests = false;\r\n        }\r\n    }\r\n}\r\nConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConfigurationService, deps: [{ token: LoggerService }, { token: PublicEventsService }, { token: StoragePersistenceService }, { token: ConfigValidationService }, { token: PlatformProvider }, { token: AuthWellKnownService }, { token: StsConfigLoader }], target: i0.ɵɵFactoryTarget.Injectable });\r\nConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConfigurationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConfigurationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: PublicEventsService }, { type: StoragePersistenceService }, { type: ConfigValidationService }, { type: PlatformProvider }, { type: AuthWellKnownService }, { type: StsConfigLoader }]; } });\n\nclass PeriodicallyTokenCheckService {\r\n    constructor(resetAuthDataService, flowHelper, flowsDataService, loggerService, userService, authStateService, refreshSessionIframeService, refreshSessionRefreshTokenService, intervalService, storagePersistenceService, publicEventsService, configurationService) {\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.flowHelper = flowHelper;\r\n        this.flowsDataService = flowsDataService;\r\n        this.loggerService = loggerService;\r\n        this.userService = userService;\r\n        this.authStateService = authStateService;\r\n        this.refreshSessionIframeService = refreshSessionIframeService;\r\n        this.refreshSessionRefreshTokenService = refreshSessionRefreshTokenService;\r\n        this.intervalService = intervalService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n        this.configurationService = configurationService;\r\n    }\r\n    startTokenValidationPeriodically(allConfigs, currentConfig) {\r\n        const configsWithSilentRenewEnabled = this.getConfigsWithSilentRenewEnabled(allConfigs);\r\n        if (configsWithSilentRenewEnabled.length <= 0) {\r\n            return;\r\n        }\r\n        if (this.intervalService.isTokenValidationRunning()) {\r\n            return;\r\n        }\r\n        const refreshTimeInSeconds = this.getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled);\r\n        const periodicallyCheck$ = this.intervalService.startPeriodicTokenCheck(refreshTimeInSeconds).pipe(switchMap(() => {\r\n            const objectWithConfigIdsAndRefreshEvent = {};\r\n            configsWithSilentRenewEnabled.forEach((config) => {\r\n                objectWithConfigIdsAndRefreshEvent[config.configId] = this.getRefreshEvent(config, allConfigs);\r\n            });\r\n            return forkJoin(objectWithConfigIdsAndRefreshEvent);\r\n        }));\r\n        this.intervalService.runTokenValidationRunning = periodicallyCheck$\r\n            .pipe(catchError((error) => throwError(() => new Error(error))))\r\n            .subscribe({\r\n            next: (objectWithConfigIds) => {\r\n                for (const [configId, _] of Object.entries(objectWithConfigIds)) {\r\n                    this.configurationService.getOpenIDConfiguration(configId).subscribe((config) => {\r\n                        this.loggerService.logDebug(config, 'silent renew, periodic check finished!');\r\n                        if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n                            this.flowsDataService.resetSilentRenewRunning(config);\r\n                        }\r\n                    });\r\n                }\r\n            },\r\n            error: (error) => {\r\n                this.loggerService.logError(currentConfig, 'silent renew failed!', error);\r\n            },\r\n        });\r\n    }\r\n    getRefreshEvent(config, allConfigs) {\r\n        const shouldStartRefreshEvent = this.shouldStartPeriodicallyCheckForConfig(config);\r\n        if (!shouldStartRefreshEvent) {\r\n            return of(null);\r\n        }\r\n        const refreshEvent$ = this.createRefreshEventForConfig(config, allConfigs);\r\n        this.publicEventsService.fireEvent(EventTypes.SilentRenewStarted);\r\n        const refreshEventWithErrorHandler$ = refreshEvent$.pipe(catchError((error) => {\r\n            this.loggerService.logError(config, 'silent renew failed!', error);\r\n            this.flowsDataService.resetSilentRenewRunning(config);\r\n            return throwError(() => new Error(error));\r\n        }));\r\n        return refreshEventWithErrorHandler$;\r\n    }\r\n    getSmallestRefreshTimeFromConfigs(configsWithSilentRenewEnabled) {\r\n        const result = configsWithSilentRenewEnabled.reduce((prev, curr) => prev.tokenRefreshInSeconds < curr.tokenRefreshInSeconds ? prev : curr);\r\n        return result.tokenRefreshInSeconds;\r\n    }\r\n    getConfigsWithSilentRenewEnabled(allConfigs) {\r\n        return allConfigs.filter((x) => x.silentRenew);\r\n    }\r\n    createRefreshEventForConfig(configuration, allConfigs) {\r\n        this.loggerService.logDebug(configuration, 'starting silent renew...');\r\n        return this.configurationService.getOpenIDConfiguration(configuration.configId).pipe(switchMap((config) => {\r\n            if (!config?.silentRenew) {\r\n                this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n                return of(null);\r\n            }\r\n            this.flowsDataService.setSilentRenewRunning(config);\r\n            if (this.flowHelper.isCurrentFlowCodeFlowWithRefreshTokens(config)) {\r\n                // Retrieve Dynamically Set Custom Params for refresh body\r\n                const customParamsRefresh = this.storagePersistenceService.read('storageCustomParamsRefresh', config) || {};\r\n                const { customParamsRefreshTokenRequest } = config;\r\n                const mergedParams = { ...customParamsRefreshTokenRequest, ...customParamsRefresh };\r\n                // Refresh Session using Refresh tokens\r\n                return this.refreshSessionRefreshTokenService.refreshSessionWithRefreshTokens(config, allConfigs, mergedParams);\r\n            }\r\n            // Retrieve Dynamically Set Custom Params\r\n            const customParams = this.storagePersistenceService.read('storageCustomParamsAuthRequest', config);\r\n            return this.refreshSessionIframeService.refreshSessionWithIframe(config, allConfigs, customParams);\r\n        }));\r\n    }\r\n    shouldStartPeriodicallyCheckForConfig(config) {\r\n        const idToken = this.authStateService.getIdToken(config);\r\n        const isSilentRenewRunning = this.flowsDataService.isSilentRenewRunning(config);\r\n        const isCodeFlowinProgress = this.flowsDataService.isCodeFlowInProgress(config);\r\n        const userDataFromStore = this.userService.getUserDataFromStore(config);\r\n        this.loggerService.logDebug(config, `Checking: silentRenewRunning: ${isSilentRenewRunning}, isCodeFlowInProgress: ${isCodeFlowinProgress} - has idToken: ${!!idToken} - has userData: ${!!userDataFromStore}`);\r\n        const shouldBeExecuted = !!userDataFromStore && !isSilentRenewRunning && !!idToken && !isCodeFlowinProgress;\r\n        if (!shouldBeExecuted) {\r\n            return false;\r\n        }\r\n        const idTokenStillValid = this.authStateService.hasIdTokenExpiredAndRenewCheckIsEnabled(config);\r\n        const accessTokenHasExpired = this.authStateService.hasAccessTokenExpiredIfExpiryExists(config);\r\n        if (!idTokenStillValid && !accessTokenHasExpired) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nPeriodicallyTokenCheckService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PeriodicallyTokenCheckService, deps: [{ token: ResetAuthDataService }, { token: FlowHelper }, { token: FlowsDataService }, { token: LoggerService }, { token: UserService }, { token: AuthStateService }, { token: RefreshSessionIframeService }, { token: RefreshSessionRefreshTokenService }, { token: IntervalService }, { token: StoragePersistenceService }, { token: PublicEventsService }, { token: ConfigurationService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPeriodicallyTokenCheckService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PeriodicallyTokenCheckService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PeriodicallyTokenCheckService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: ResetAuthDataService }, { type: FlowHelper }, { type: FlowsDataService }, { type: LoggerService }, { type: UserService }, { type: AuthStateService }, { type: RefreshSessionIframeService }, { type: RefreshSessionRefreshTokenService }, { type: IntervalService }, { type: StoragePersistenceService }, { type: PublicEventsService }, { type: ConfigurationService }]; } });\n\nclass PopUpService {\r\n    constructor(document) {\r\n        this.document = document;\r\n        this.STORAGE_IDENTIFIER = 'popupauth';\r\n        this.resultInternal$ = new Subject();\r\n    }\r\n    get result$() {\r\n        return this.resultInternal$.asObservable();\r\n    }\r\n    get windowInternal() {\r\n        return this.document.defaultView;\r\n    }\r\n    isCurrentlyInPopup() {\r\n        if (this.canAccessSessionStorage()) {\r\n            const popup = sessionStorage.getItem(this.STORAGE_IDENTIFIER);\r\n            return !!this.windowInternal.opener && this.windowInternal.opener !== this.windowInternal && !!popup;\r\n        }\r\n        return false;\r\n    }\r\n    openPopUp(url, popupOptions) {\r\n        const optionsToPass = this.getOptions(popupOptions);\r\n        this.popUp = this.windowInternal.open(url, '_blank', optionsToPass);\r\n        this.popUp.sessionStorage.setItem(this.STORAGE_IDENTIFIER, 'true');\r\n        const listener = (event) => {\r\n            if (!event?.data || typeof event.data !== 'string') {\r\n                this.cleanUp(listener);\r\n                return;\r\n            }\r\n            this.resultInternal$.next({ userClosed: false, receivedUrl: event.data });\r\n            this.cleanUp(listener);\r\n        };\r\n        this.windowInternal.addEventListener('message', listener, false);\r\n        this.handle = this.windowInternal.setInterval(() => {\r\n            if (this.popUp.closed) {\r\n                this.resultInternal$.next({ userClosed: true });\r\n                this.cleanUp(listener);\r\n            }\r\n        }, 200);\r\n    }\r\n    sendMessageToMainWindow(url) {\r\n        if (this.windowInternal.opener) {\r\n            const href = this.windowInternal.location.href;\r\n            this.sendMessage(url, href);\r\n        }\r\n    }\r\n    cleanUp(listener) {\r\n        this.windowInternal.removeEventListener('message', listener, false);\r\n        this.windowInternal.clearInterval(this.handle);\r\n        if (this.popUp) {\r\n            this.popUp.sessionStorage?.removeItem(this.STORAGE_IDENTIFIER);\r\n            this.popUp.close();\r\n            this.popUp = null;\r\n        }\r\n    }\r\n    sendMessage(url, href) {\r\n        this.windowInternal.opener.postMessage(url, href);\r\n    }\r\n    getOptions(popupOptions) {\r\n        const popupDefaultOptions = { width: 500, height: 500, left: 50, top: 50 };\r\n        const options = { ...popupDefaultOptions, ...(popupOptions || {}) };\r\n        const left = this.windowInternal.screenLeft + (this.windowInternal.outerWidth - options.width) / 2;\r\n        const top = this.windowInternal.screenTop + (this.windowInternal.outerHeight - options.height) / 2;\r\n        options.left = left;\r\n        options.top = top;\r\n        return Object.entries(options)\r\n            .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)\r\n            .join(',');\r\n    }\r\n    canAccessSessionStorage() {\r\n        return typeof navigator !== 'undefined' && navigator.cookieEnabled && typeof Storage !== 'undefined';\r\n    }\r\n}\r\nPopUpService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PopUpService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PopUpService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PopUpService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: Document, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nconst STORAGE_KEY = 'redirect';\r\nclass AutoLoginService {\r\n    constructor(storageService, router) {\r\n        this.storageService = storageService;\r\n        this.router = router;\r\n    }\r\n    checkSavedRedirectRouteAndNavigate(config) {\r\n        const savedRouteForRedirect = this.getStoredRedirectRoute(config);\r\n        if (savedRouteForRedirect) {\r\n            this.deleteStoredRedirectRoute(config);\r\n            this.router.navigateByUrl(savedRouteForRedirect);\r\n        }\r\n    }\r\n    /**\r\n     * Saves the redirect URL to storage.\r\n     *\r\n     * @param url The redirect URL to save.\r\n     */\r\n    saveRedirectRoute(config, url) {\r\n        this.storageService.write(STORAGE_KEY, url, config);\r\n    }\r\n    /**\r\n     * Gets the stored redirect URL from storage.\r\n     */\r\n    getStoredRedirectRoute(config) {\r\n        return this.storageService.read(STORAGE_KEY, config);\r\n    }\r\n    /**\r\n     * Removes the redirect URL from storage.\r\n     */\r\n    deleteStoredRedirectRoute(config) {\r\n        this.storageService.remove(STORAGE_KEY, config);\r\n    }\r\n}\r\nAutoLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginService, deps: [{ token: StoragePersistenceService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: StoragePersistenceService }, { type: i2.Router }]; } });\n\nclass CheckAuthService {\r\n    constructor(checkSessionService, currentUrlService, silentRenewService, userService, loggerService, authStateService, callbackService, refreshSessionService, periodicallyTokenCheckService, popupService, autoLoginService, storagePersistenceService, publicEventsService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.currentUrlService = currentUrlService;\r\n        this.silentRenewService = silentRenewService;\r\n        this.userService = userService;\r\n        this.loggerService = loggerService;\r\n        this.authStateService = authStateService;\r\n        this.callbackService = callbackService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.periodicallyTokenCheckService = periodicallyTokenCheckService;\r\n        this.popupService = popupService;\r\n        this.autoLoginService = autoLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.publicEventsService = publicEventsService;\r\n    }\r\n    checkAuth(configuration, allConfigs, url) {\r\n        this.publicEventsService.fireEvent(EventTypes.CheckingAuth);\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            configuration = this.getConfigurationWithUrlState([configuration], stateParamFromUrl);\r\n            if (!configuration) {\r\n                return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\r\n            }\r\n        }\r\n        return this.checkAuthWithConfig(configuration, allConfigs, url);\r\n    }\r\n    checkAuthMultiple(allConfigs, url) {\r\n        if (this.currentUrlService.currentUrlHasStateParam()) {\r\n            const stateParamFromUrl = this.currentUrlService.getStateParamFromCurrentUrl();\r\n            const config = this.getConfigurationWithUrlState(allConfigs, stateParamFromUrl);\r\n            if (!config) {\r\n                return throwError(() => new Error(`could not find matching config for state ${stateParamFromUrl}`));\r\n            }\r\n            return this.composeMultipleLoginResults(allConfigs, config, url);\r\n        }\r\n        const configs = allConfigs;\r\n        const allChecks$ = configs.map((x) => this.checkAuthWithConfig(x, configs, url));\r\n        return forkJoin(allChecks$);\r\n    }\r\n    checkAuthIncludingServer(configuration, allConfigs) {\r\n        return this.checkAuthWithConfig(configuration, allConfigs).pipe(switchMap((loginResponse) => {\r\n            const { isAuthenticated } = loginResponse;\r\n            if (isAuthenticated) {\r\n                return of(loginResponse);\r\n            }\r\n            return this.refreshSessionService.forceRefreshSession(configuration, allConfigs).pipe(tap((loginResponseAfterRefreshSession) => {\r\n                if (loginResponseAfterRefreshSession?.isAuthenticated) {\r\n                    this.startCheckSessionAndValidation(configuration, allConfigs);\r\n                }\r\n            }));\r\n        }));\r\n    }\r\n    checkAuthWithConfig(config, allConfigs, url) {\r\n        if (!config) {\r\n            const errorMessage = 'Please provide at least one configuration before setting up the module';\r\n            this.loggerService.logError(config, errorMessage);\r\n            return of({ isAuthenticated: false, errorMessage, userData: null, idToken: null, accessToken: null, configId: null });\r\n        }\r\n        const currentUrl = url || this.currentUrlService.getCurrentUrl();\r\n        const { configId, authority } = config;\r\n        this.loggerService.logDebug(config, `Working with config '${configId}' using ${authority}`);\r\n        if (this.popupService.isCurrentlyInPopup()) {\r\n            this.popupService.sendMessageToMainWindow(currentUrl);\r\n            return of(null);\r\n        }\r\n        const isCallback = this.callbackService.isCallback(currentUrl);\r\n        this.loggerService.logDebug(config, 'currentUrl to check auth with: ', currentUrl);\r\n        const callback$ = isCallback ? this.callbackService.handleCallbackAndFireEvents(currentUrl, config, allConfigs) : of(null);\r\n        return callback$.pipe(map(() => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(config);\r\n            if (isAuthenticated) {\r\n                this.startCheckSessionAndValidation(config, allConfigs);\r\n                if (!isCallback) {\r\n                    this.authStateService.setAuthenticatedAndFireEvent(allConfigs);\r\n                    this.userService.publishUserDataIfExists(config, allConfigs);\r\n                }\r\n            }\r\n            this.loggerService.logDebug(config, 'checkAuth completed - firing events now. isAuthenticated: ' + isAuthenticated);\r\n            return {\r\n                isAuthenticated,\r\n                userData: this.userService.getUserDataFromStore(config),\r\n                accessToken: this.authStateService.getAccessToken(config),\r\n                idToken: this.authStateService.getIdToken(config),\r\n                configId,\r\n            };\r\n        }), tap(({ isAuthenticated }) => {\r\n            this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinished);\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\r\n            }\r\n        }), catchError(({ message }) => {\r\n            this.loggerService.logError(config, message);\r\n            this.publicEventsService.fireEvent(EventTypes.CheckingAuthFinishedWithError, message);\r\n            return of({ isAuthenticated: false, errorMessage: message, userData: null, idToken: null, accessToken: null, configId });\r\n        }));\r\n    }\r\n    startCheckSessionAndValidation(config, allConfigs) {\r\n        if (this.checkSessionService.isCheckSessionConfigured(config)) {\r\n            this.checkSessionService.start(config);\r\n        }\r\n        this.periodicallyTokenCheckService.startTokenValidationPeriodically(allConfigs, config);\r\n        if (this.silentRenewService.isSilentRenewConfigured(config)) {\r\n            this.silentRenewService.getOrCreateIframe(config);\r\n        }\r\n    }\r\n    getConfigurationWithUrlState(configurations, stateFromUrl) {\r\n        for (const config of configurations) {\r\n            const storedState = this.storagePersistenceService.read('authStateControl', config);\r\n            if (storedState === stateFromUrl) {\r\n                return config;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    composeMultipleLoginResults(configurations, activeConfig, url) {\r\n        const allOtherConfigs = configurations.filter((x) => x.configId !== activeConfig.configId);\r\n        const currentConfigResult = this.checkAuthWithConfig(activeConfig, configurations, url);\r\n        const allOtherConfigResults = allOtherConfigs.map((config) => {\r\n            const { redirectUrl } = config;\r\n            return this.checkAuthWithConfig(config, configurations, redirectUrl);\r\n        });\r\n        return forkJoin([currentConfigResult, ...allOtherConfigResults]);\r\n    }\r\n}\r\nCheckAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CheckAuthService, deps: [{ token: CheckSessionService }, { token: CurrentUrlService }, { token: SilentRenewService }, { token: UserService }, { token: LoggerService }, { token: AuthStateService }, { token: CallbackService }, { token: RefreshSessionService }, { token: PeriodicallyTokenCheckService }, { token: PopUpService }, { token: AutoLoginService }, { token: StoragePersistenceService }, { token: PublicEventsService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nCheckAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CheckAuthService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: CheckAuthService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CurrentUrlService }, { type: SilentRenewService }, { type: UserService }, { type: LoggerService }, { type: AuthStateService }, { type: CallbackService }, { type: RefreshSessionService }, { type: PeriodicallyTokenCheckService }, { type: PopUpService }, { type: AutoLoginService }, { type: StoragePersistenceService }, { type: PublicEventsService }]; } });\n\nclass ClosestMatchingRouteService {\r\n    getConfigIdForClosestMatchingRoute(route, configurations) {\r\n        for (const config of configurations) {\r\n            const { secureRoutes } = config;\r\n            for (const configuredRoute of secureRoutes) {\r\n                if (route.startsWith(configuredRoute)) {\r\n                    return {\r\n                        matchingRoute: configuredRoute,\r\n                        matchingConfig: config,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            matchingRoute: null,\r\n            matchingConfig: null,\r\n        };\r\n    }\r\n}\r\nClosestMatchingRouteService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ClosestMatchingRouteService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nClosestMatchingRouteService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ClosestMatchingRouteService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ClosestMatchingRouteService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass ConsoleLoggerService {\r\n    logError(message, ...args) {\r\n        console.error(message, ...args);\r\n    }\r\n    logWarning(message, ...args) {\r\n        console.warn(message, ...args);\r\n    }\r\n    logDebug(message, ...args) {\r\n        console.debug(message, ...args);\r\n    }\r\n}\r\nConsoleLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConsoleLoggerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nConsoleLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConsoleLoggerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ConsoleLoggerService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass ResponseTypeValidationService {\r\n    constructor(loggerService, flowHelper) {\r\n        this.loggerService = loggerService;\r\n        this.flowHelper = flowHelper;\r\n    }\r\n    hasConfigValidResponseType(configuration) {\r\n        if (this.flowHelper.isCurrentFlowAnyImplicitFlow(configuration)) {\r\n            return true;\r\n        }\r\n        if (this.flowHelper.isCurrentFlowCodeFlow(configuration)) {\r\n            return true;\r\n        }\r\n        this.loggerService.logWarning(configuration, 'module configured incorrectly, invalid response_type. Check the responseType in the config');\r\n        return false;\r\n    }\r\n}\r\nResponseTypeValidationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ResponseTypeValidationService, deps: [{ token: LoggerService }, { token: FlowHelper }], target: i0.ɵɵFactoryTarget.Injectable });\r\nResponseTypeValidationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ResponseTypeValidationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ResponseTypeValidationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: FlowHelper }]; } });\n\nclass RedirectService {\r\n    constructor(doc) {\r\n        this.doc = doc;\r\n    }\r\n    redirectTo(url) {\r\n        this.doc.location.href = url;\r\n    }\r\n}\r\nRedirectService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RedirectService, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Injectable });\r\nRedirectService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RedirectService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: RedirectService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [DOCUMENT]\r\n                }] }]; } });\n\nclass ParService {\r\n    constructor(loggerService, urlService, dataService, storagePersistenceService) {\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    postParRequest(configuration, customParams) {\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        const authWellKnownEndpoints = this.storagePersistenceService.read('authWellKnownEndPoints', configuration);\r\n        if (!authWellKnownEndpoints) {\r\n            return throwError(() => new Error('Could not read PAR endpoint because authWellKnownEndPoints are not given'));\r\n        }\r\n        const parEndpoint = authWellKnownEndpoints.parEndpoint;\r\n        if (!parEndpoint) {\r\n            return throwError(() => new Error('Could not read PAR endpoint from authWellKnownEndpoints'));\r\n        }\r\n        return this.urlService.createBodyForParCodeFlowRequest(configuration, customParams).pipe(switchMap((data) => {\r\n            return this.dataService.post(parEndpoint, data, configuration, headers).pipe(retry(2), map((response) => {\r\n                this.loggerService.logDebug(configuration, 'par response: ', response);\r\n                return {\r\n                    expiresIn: response.expires_in,\r\n                    requestUri: response.request_uri,\r\n                };\r\n            }), catchError((error) => {\r\n                const errorMessage = `There was an error on ParService postParRequest`;\r\n                this.loggerService.logError(configuration, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ParService, deps: [{ token: LoggerService }, { token: UrlService }, { token: DataService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ParService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ParService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: UrlService }, { type: DataService }, { type: StoragePersistenceService }]; } });\n\nclass ParLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, popupService, checkAuthService, parService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.parService = parService;\r\n    }\r\n    loginPar(configuration, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            this.loggerService.logError(configuration, 'Invalid response type!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.authWellKnownService\r\n            .queryAndStoreAuthWellKnownEndPoints(configuration)\r\n            .pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)))\r\n            .subscribe((response) => {\r\n            this.loggerService.logDebug(configuration, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\r\n            this.loggerService.logDebug(configuration, 'par request url: ', url);\r\n            if (!url) {\r\n                this.loggerService.logError(configuration, `Could not create URL with param ${response.requestUri}: '${url}'`);\r\n                return;\r\n            }\r\n            if (urlHandler) {\r\n                urlHandler(url);\r\n            }\r\n            else {\r\n                this.redirectService.redirectTo(url);\r\n            }\r\n        });\r\n    }\r\n    loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions) {\r\n        const { configId } = configuration;\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configuration, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        const { customParams } = authOptions || {};\r\n        return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => this.parService.postParRequest(configuration, customParams)), switchMap((response) => {\r\n            this.loggerService.logDebug(configuration, 'par response: ', response);\r\n            const url = this.urlService.getAuthorizeParUrl(response.requestUri, configuration);\r\n            this.loggerService.logDebug(configuration, 'par request url: ', url);\r\n            if (!url) {\r\n                const errorMessage = `Could not create URL with param ${response.requestUri}: 'url'`;\r\n                this.loggerService.logError(configuration, errorMessage);\r\n                return throwError(() => new Error(errorMessage));\r\n            }\r\n            this.popupService.openPopUp(url, popupOptions);\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nParLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ParLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }, { token: ParService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nParLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ParLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: ParLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }, { type: ParService }]; } });\n\nclass PopUpLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, authWellKnownService, popupService, checkAuthService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.popupService = popupService;\r\n        this.checkAuthService = checkAuthService;\r\n    }\r\n    loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions) {\r\n        const { configId } = configuration;\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            const errorMessage = 'Invalid response type!';\r\n            this.loggerService.logError(configuration, errorMessage);\r\n            return throwError(() => new Error(errorMessage));\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow with popup, no auth data');\r\n        return this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).pipe(switchMap(() => {\r\n            return this.urlService.getAuthorizeUrl(configuration, authOptions);\r\n        }), tap((authUrl) => this.popupService.openPopUp(authUrl, popupOptions)), switchMap(() => {\r\n            return this.popupService.result$.pipe(take(1), switchMap((result) => {\r\n                const { userClosed, receivedUrl } = result;\r\n                if (userClosed) {\r\n                    return of({\r\n                        isAuthenticated: false,\r\n                        errorMessage: 'User closed popup',\r\n                        userData: null,\r\n                        idToken: null,\r\n                        accessToken: null,\r\n                        configId,\r\n                    });\r\n                }\r\n                return this.checkAuthService.checkAuth(configuration, allConfigs, receivedUrl);\r\n            }));\r\n        }));\r\n    }\r\n}\r\nPopUpLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PopUpLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: AuthWellKnownService }, { token: PopUpService }, { token: CheckAuthService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nPopUpLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PopUpLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: PopUpLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: AuthWellKnownService }, { type: PopUpService }, { type: CheckAuthService }]; } });\n\nclass StandardLoginService {\r\n    constructor(loggerService, responseTypeValidationService, urlService, redirectService, authWellKnownService, flowsDataService) {\r\n        this.loggerService = loggerService;\r\n        this.responseTypeValidationService = responseTypeValidationService;\r\n        this.urlService = urlService;\r\n        this.redirectService = redirectService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.flowsDataService = flowsDataService;\r\n    }\r\n    loginStandard(configuration, authOptions) {\r\n        if (!this.responseTypeValidationService.hasConfigValidResponseType(configuration)) {\r\n            this.loggerService.logError(configuration, 'Invalid response type!');\r\n            return;\r\n        }\r\n        this.loggerService.logDebug(configuration, 'BEGIN Authorize OIDC Flow, no auth data');\r\n        this.flowsDataService.setCodeFlowInProgress(configuration);\r\n        this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(configuration).subscribe(() => {\r\n            const { urlHandler } = authOptions || {};\r\n            this.flowsDataService.resetSilentRenewRunning(configuration);\r\n            this.urlService.getAuthorizeUrl(configuration, authOptions).subscribe((url) => {\r\n                if (!url) {\r\n                    this.loggerService.logError(configuration, 'Could not create URL', url);\r\n                    return;\r\n                }\r\n                if (urlHandler) {\r\n                    urlHandler(url);\r\n                }\r\n                else {\r\n                    this.redirectService.redirectTo(url);\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nStandardLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StandardLoginService, deps: [{ token: LoggerService }, { token: ResponseTypeValidationService }, { token: UrlService }, { token: RedirectService }, { token: AuthWellKnownService }, { token: FlowsDataService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nStandardLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StandardLoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: StandardLoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: LoggerService }, { type: ResponseTypeValidationService }, { type: UrlService }, { type: RedirectService }, { type: AuthWellKnownService }, { type: FlowsDataService }]; } });\n\nclass LoginService {\r\n    constructor(parLoginService, popUpLoginService, standardLoginService, storagePersistenceService) {\r\n        this.parLoginService = parLoginService;\r\n        this.popUpLoginService = popUpLoginService;\r\n        this.standardLoginService = standardLoginService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n    }\r\n    login(configuration, authOptions) {\r\n        const { usePushedAuthorisationRequests } = configuration;\r\n        if (authOptions?.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\r\n        }\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginPar(configuration, authOptions);\r\n        }\r\n        else {\r\n            return this.standardLoginService.loginStandard(configuration, authOptions);\r\n        }\r\n    }\r\n    loginWithPopUp(configuration, allConfigs, authOptions, popupOptions) {\r\n        const { usePushedAuthorisationRequests } = configuration;\r\n        if (authOptions?.customParams) {\r\n            this.storagePersistenceService.write('storageCustomParamsAuthRequest', authOptions.customParams, configuration);\r\n        }\r\n        if (usePushedAuthorisationRequests) {\r\n            return this.parLoginService.loginWithPopUpPar(configuration, allConfigs, authOptions, popupOptions);\r\n        }\r\n        else {\r\n            return this.popUpLoginService.loginWithPopUpStandard(configuration, allConfigs, authOptions, popupOptions);\r\n        }\r\n    }\r\n}\r\nLoginService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LoginService, deps: [{ token: ParLoginService }, { token: PopUpLoginService }, { token: StandardLoginService }, { token: StoragePersistenceService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLoginService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LoginService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LoginService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: ParLoginService }, { type: PopUpLoginService }, { type: StandardLoginService }, { type: StoragePersistenceService }]; } });\n\nclass LogoffRevocationService {\r\n    constructor(dataService, storagePersistenceService, loggerService, urlService, checkSessionService, resetAuthDataService, redirectService) {\r\n        this.dataService = dataService;\r\n        this.storagePersistenceService = storagePersistenceService;\r\n        this.loggerService = loggerService;\r\n        this.urlService = urlService;\r\n        this.checkSessionService = checkSessionService;\r\n        this.resetAuthDataService = resetAuthDataService;\r\n        this.redirectService = redirectService;\r\n    }\r\n    // Logs out on the server and the local client.\r\n    // If the server state has changed, check session, then only a local logout.\r\n    logoff(config, allConfigs, authOptions) {\r\n        const { urlHandler, customParams } = authOptions || {};\r\n        this.loggerService.logDebug(config, 'logoff, remove auth ');\r\n        const endSessionUrl = this.getEndSessionUrl(config, customParams);\r\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n        if (!endSessionUrl) {\r\n            this.loggerService.logDebug(config, 'only local login cleaned up, no end_session_endpoint');\r\n            return;\r\n        }\r\n        if (this.checkSessionService.serverStateChanged(config)) {\r\n            this.loggerService.logDebug(config, 'only local login cleaned up, server session has changed');\r\n        }\r\n        else if (urlHandler) {\r\n            urlHandler(endSessionUrl);\r\n        }\r\n        else {\r\n            this.redirectService.redirectTo(endSessionUrl);\r\n        }\r\n    }\r\n    logoffLocal(config, allConfigs) {\r\n        this.resetAuthDataService.resetAuthorizationData(config, allConfigs);\r\n        this.checkSessionService.stop();\r\n    }\r\n    logoffLocalMultiple(allConfigs) {\r\n        allConfigs.forEach((configuration) => this.logoffLocal(configuration, allConfigs));\r\n    }\r\n    // The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n    // only the access token is revoked. Then the logout run.\r\n    logoffAndRevokeTokens(config, allConfigs, authOptions) {\r\n        const { revocationEndpoint } = this.storagePersistenceService.read('authWellKnownEndPoints', config) || {};\r\n        if (!revocationEndpoint) {\r\n            this.loggerService.logDebug(config, 'revocation endpoint not supported');\r\n            this.logoff(config, allConfigs, authOptions);\r\n            return of(null);\r\n        }\r\n        if (this.storagePersistenceService.getRefreshToken(config)) {\r\n            return this.revokeRefreshToken(config).pipe(switchMap((result) => this.revokeAccessToken(config, result)), catchError((error) => {\r\n                const errorMessage = `revoke token failed`;\r\n                this.loggerService.logError(config, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }), tap(() => this.logoff(config, allConfigs, authOptions)));\r\n        }\r\n        else {\r\n            return this.revokeAccessToken(config).pipe(catchError((error) => {\r\n                const errorMessage = `revoke accessToken failed`;\r\n                this.loggerService.logError(config, errorMessage, error);\r\n                return throwError(() => new Error(errorMessage));\r\n            }), tap(() => this.logoff(config, allConfigs, authOptions)));\r\n        }\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an access token on the STS. If no token is provided, then the token from\r\n    // the storage is revoked. You can pass any token to revoke. This makes it possible to\r\n    // manage your own tokens. The is a public API.\r\n    revokeAccessToken(configuration, accessToken) {\r\n        const accessTok = accessToken || this.storagePersistenceService.getAccessToken(configuration);\r\n        const body = this.urlService.createRevocationEndpointBodyAccessToken(accessTok, configuration);\r\n        return this.sendRevokeRequest(configuration, body);\r\n    }\r\n    // https://tools.ietf.org/html/rfc7009\r\n    // revokes an refresh token on the STS. This is only required in the code flow with refresh tokens.\r\n    // If no token is provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n    // This makes it possible to manage your own tokens.\r\n    revokeRefreshToken(configuration, refreshToken) {\r\n        const refreshTok = refreshToken || this.storagePersistenceService.getRefreshToken(configuration);\r\n        const body = this.urlService.createRevocationEndpointBodyRefreshToken(refreshTok, configuration);\r\n        return this.sendRevokeRequest(configuration, body);\r\n    }\r\n    getEndSessionUrl(configuration, customParams) {\r\n        const idToken = this.storagePersistenceService.getIdToken(configuration);\r\n        const { customParamsEndSessionRequest } = configuration;\r\n        const mergedParams = { ...customParamsEndSessionRequest, ...customParams };\r\n        return this.urlService.createEndSessionUrl(idToken, configuration, mergedParams);\r\n    }\r\n    sendRevokeRequest(configuration, body) {\r\n        const url = this.urlService.getRevocationEndpointUrl(configuration);\r\n        let headers = new HttpHeaders();\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        return this.dataService.post(url, body, configuration, headers).pipe(retry(2), switchMap((response) => {\r\n            this.loggerService.logDebug(configuration, 'revocation endpoint post response: ', response);\r\n            return of(response);\r\n        }), catchError((error) => {\r\n            const errorMessage = `Revocation request failed`;\r\n            this.loggerService.logError(configuration, errorMessage, error);\r\n            return throwError(() => new Error(errorMessage));\r\n        }));\r\n    }\r\n}\r\nLogoffRevocationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LogoffRevocationService, deps: [{ token: DataService }, { token: StoragePersistenceService }, { token: LoggerService }, { token: UrlService }, { token: CheckSessionService }, { token: ResetAuthDataService }, { token: RedirectService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nLogoffRevocationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LogoffRevocationService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: LogoffRevocationService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: DataService }, { type: StoragePersistenceService }, { type: LoggerService }, { type: UrlService }, { type: CheckSessionService }, { type: ResetAuthDataService }, { type: RedirectService }]; } });\n\nclass OidcSecurityService {\r\n    constructor(checkSessionService, checkAuthService, userService, tokenHelperService, configurationService, authStateService, flowsDataService, callbackService, logoffRevocationService, loginService, refreshSessionService, urlService, authWellKnownService) {\r\n        this.checkSessionService = checkSessionService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.userService = userService;\r\n        this.tokenHelperService = tokenHelperService;\r\n        this.configurationService = configurationService;\r\n        this.authStateService = authStateService;\r\n        this.flowsDataService = flowsDataService;\r\n        this.callbackService = callbackService;\r\n        this.logoffRevocationService = logoffRevocationService;\r\n        this.loginService = loginService;\r\n        this.refreshSessionService = refreshSessionService;\r\n        this.urlService = urlService;\r\n        this.authWellKnownService = authWellKnownService;\r\n        this.isLoading = new BehaviorSubject(true);\r\n        this.finishLoading = () => {\r\n            this.isLoading.next(false);\r\n        };\r\n        this.finishLoadingOnError = (err) => {\r\n            this.isLoading.next(false);\r\n            return throwError(() => err);\r\n        };\r\n    }\r\n    /**\r\n     * Provides information about the user after they have logged in.\r\n     *\r\n     * @returns Returns an object containing either the user data directly (single config) or\r\n     * the user data per config in case you are running with multiple configs\r\n     */\r\n    get userData$() {\r\n        return this.userService.userData$;\r\n    }\r\n    /**\r\n     * Emits each time an authorization event occurs.\r\n     *\r\n     * @returns Returns an object containing if you are authenticated or not.\r\n     * Single Config: true if config is authenticated, false if not.\r\n     * Multiple Configs: true is all configs are authenticated, false if only one of them is not\r\n     *\r\n     * The `allConfigsAuthenticated` property contains the auth information _per config_.\r\n     */\r\n    get isAuthenticated$() {\r\n        return this.authStateService.authenticated$;\r\n    }\r\n    /**\r\n     * Emits each time the server sends a CheckSession event and the value changed. This property will always return\r\n     * true.\r\n     */\r\n    get checkSessionChanged$() {\r\n        return this.checkSessionService.checkSessionChanged$;\r\n    }\r\n    /**\r\n     * Emits on a Security Token Service callback. The observable will never contain a value.\r\n     */\r\n    get stsCallback$() {\r\n        return this.callbackService.stsCallback$;\r\n    }\r\n    /**\r\n     * @deprecated This property should not be used. Please use the `PublicEventsService` instead. This property is removed in future versions\r\n     * Emits false when the observable, returned by one of the checkAuth() methods, emits a value, or errors. Initial value: true.\r\n     */\r\n    get isLoading$() {\r\n        return this.isLoading.asObservable();\r\n    }\r\n    preloadAuthWellKnownDocument(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(switchMap((config) => this.authWellKnownService.queryAndStoreAuthWellKnownEndPoints(config)));\r\n    }\r\n    /**\r\n     * Returns the currently active OpenID configurations.\r\n     *\r\n     * @returns an array of OpenIdConfigurations.\r\n     */\r\n    getConfigurations() {\r\n        return this.configurationService.getAllConfigurations();\r\n    }\r\n    /**\r\n     * Returns a single active OpenIdConfiguration.\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being returned\r\n     */\r\n    getConfiguration(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId);\r\n    }\r\n    /**\r\n     * Returns the userData for a configuration\r\n     *\r\n     * @param configId The configId to identify the config. If not passed, the first one is being used\r\n     */\r\n    getUserData(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.userService.getUserDataFromStore(config)));\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for one configuration. Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An object `LoginResponse` containing all information about the login\r\n     */\r\n    checkAuth(url, configId) {\r\n        return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({ allConfigs, currentConfig }) => this.checkAuthService.checkAuth(currentConfig, allConfigs, url)), tap(this.finishLoading), catchError(this.finishLoadingOnError));\r\n    }\r\n    /**\r\n     * Starts the complete setup flow for multiple configurations.\r\n     * Calling will start the entire authentication flow, and the returned observable\r\n     * will denote whether the user was successfully authenticated including the user data, the access token, the configId and\r\n     * an error message in case an error happened in an array for each config which was provided\r\n     *\r\n     * @param url The URL to perform the authorization on the behalf of.\r\n     * @param configId The configId to perform the authorization on the behalf of. If not passed, all of the current\r\n     * configured ones will be used to check.\r\n     *\r\n     * @returns An array of `LoginResponse` objects containing all information about the logins\r\n     */\r\n    checkAuthMultiple(url) {\r\n        return this.configurationService.getOpenIDConfigurations().pipe(switchMap(({ allConfigs }) => this.checkAuthService.checkAuthMultiple(allConfigs, url)), tap(this.finishLoading), catchError(this.finishLoadingOnError));\r\n    }\r\n    /**\r\n     * Provides information about the current authenticated state\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A boolean whether the config is authenticated or not.\r\n     */\r\n    isAuthenticated(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.isAuthenticated(config)));\r\n    }\r\n    /**\r\n     * Checks the server for an authenticated session using the iframe silent renew if not locally authenticated.\r\n     */\r\n    checkAuthIncludingServer(configId) {\r\n        return this.configurationService.getOpenIDConfigurations(configId).pipe(switchMap(({ allConfigs, currentConfig }) => this.checkAuthService.checkAuthIncludingServer(currentConfig, allConfigs)), tap(this.finishLoading), catchError(this.finishLoadingOnError));\r\n    }\r\n    /**\r\n     * Returns the access token for the login scenario.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the access token.\r\n     */\r\n    getAccessToken(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.getAccessToken(config)));\r\n    }\r\n    /**\r\n     * Returns the ID token for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the id token.\r\n     */\r\n    getIdToken(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.getIdToken(config)));\r\n    }\r\n    /**\r\n     * Returns the refresh token, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the refresh token.\r\n     */\r\n    getRefreshToken(configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => this.authStateService.getRefreshToken(config)));\r\n    }\r\n    /**\r\n     * Returns the authentication result, if present, for the sign-in.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A object with the authentication result\r\n     */\r\n    getAuthenticationResult(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.authStateService.getAuthenticationResult(config)));\r\n    }\r\n    /**\r\n     * Returns the payload from the ID token.\r\n     *\r\n     * @param encode Set to true if the payload is base64 encoded\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The payload from the id token.\r\n     */\r\n    getPayloadFromIdToken(encode = false, configId) {\r\n        return this.configurationService.getOpenIDConfiguration(configId).pipe(map((config) => {\r\n            const token = this.authStateService.getIdToken(config);\r\n            return this.tokenHelperService.getPayloadFromToken(token, encode, config);\r\n        }));\r\n    }\r\n    /**\r\n     * Sets a custom state for the authorize request.\r\n     *\r\n     * @param state The state to set.\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     */\r\n    setState(state, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.flowsDataService.setAuthStateControl(state, config)));\r\n    }\r\n    /**\r\n     * Gets the state value used for the authorize request.\r\n     *\r\n     * @param configId The configId to check the information for. If not passed, the first configs will be taken\r\n     *\r\n     * @returns The state value used for the authorize request.\r\n     */\r\n    getState(configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.flowsDataService.getAuthStateControl(config)));\r\n    }\r\n    /**\r\n     * Redirects the user to the Security Token Service to begin the authentication process.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the the authentication request.\r\n     */\r\n    authorize(configId, authOptions) {\r\n        this.configurationService.getOpenIDConfiguration(configId).subscribe((config) => this.loginService.login(config, authOptions));\r\n    }\r\n    /**\r\n     * Opens the Security Token Service in a new window to begin the authentication process.\r\n     *\r\n     * @param authOptions The custom options for the authentication request.\r\n     * @param popupOptions The configuration for the popup window.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    authorizeWithPopUp(authOptions, popupOptions, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(switchMap(({ allConfigs, currentConfig }) => this.loginService.loginWithPopUp(currentConfig, allConfigs, authOptions, popupOptions)));\r\n    }\r\n    /**\r\n     * Manually refreshes the session.\r\n     *\r\n     * @param customParams Custom parameters to pass to the refresh request.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An `Observable<LoginResponse>` containing all information about the login\r\n     */\r\n    forceRefreshSession(customParams, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(switchMap(({ allConfigs, currentConfig }) => this.refreshSessionService.userForceRefreshSession(currentConfig, allConfigs, customParams)));\r\n    }\r\n    /**\r\n     * Revokes the refresh token (if present) and the access token on the server and then performs the logoff operation.\r\n     * The refresh token and and the access token are revoked on the server. If the refresh token does not exist\r\n     * only the access token is revoked. Then the logout run.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions The custom options for the request.\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    logoffAndRevokeTokens(configId, authOptions) {\r\n        return this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .pipe(switchMap(({ allConfigs, currentConfig }) => this.logoffRevocationService.logoffAndRevokeTokens(currentConfig, allConfigs, authOptions)));\r\n    }\r\n    /**\r\n     * Logs out on the server and the local client. If the server state has changed, confirmed via check session,\r\n     * then only a local logout is performed.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     * @param authOptions with custom parameters and/or an custom url handler\r\n     */\r\n    logoff(configId, authOptions) {\r\n        this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .subscribe(({ allConfigs, currentConfig }) => this.logoffRevocationService.logoff(currentConfig, allConfigs, authOptions));\r\n    }\r\n    /**\r\n     * Logs the user out of the application without logging them out of the server.\r\n     * Use this method if you have _one_ config enabled.\r\n     *\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     */\r\n    logoffLocal(configId) {\r\n        this.configurationService\r\n            .getOpenIDConfigurations(configId)\r\n            .subscribe(({ allConfigs, currentConfig }) => this.logoffRevocationService.logoffLocal(currentConfig, allConfigs));\r\n    }\r\n    /**\r\n     * Logs the user out of the application for all configs without logging them out of the server.\r\n     * Use this method if you have _multiple_ configs enabled.\r\n     */\r\n    logoffLocalMultiple() {\r\n        this.configurationService\r\n            .getOpenIDConfigurations()\r\n            .subscribe(({ allConfigs }) => this.logoffRevocationService.logoffLocalMultiple(allConfigs));\r\n    }\r\n    /**\r\n     * Revokes an access token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param accessToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeAccessToken(accessToken, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(switchMap((config) => this.logoffRevocationService.revokeAccessToken(config, accessToken)));\r\n    }\r\n    /**\r\n     * Revokes a refresh token on the Security Token Service. This is only required in the code flow with refresh tokens. If no token is\r\n     * provided, then the token from the storage is revoked. You can pass any token to revoke.\r\n     * https://tools.ietf.org/html/rfc7009\r\n     *\r\n     * @param refreshToken The access token to revoke.\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns An observable when the action is finished\r\n     */\r\n    revokeRefreshToken(refreshToken, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(switchMap((config) => this.logoffRevocationService.revokeRefreshToken(config, refreshToken)));\r\n    }\r\n    /**\r\n     * Creates the end session URL which can be used to implement an alternate server logout.\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the end session url or null\r\n     */\r\n    getEndSessionUrl(customParams, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(map((config) => this.logoffRevocationService.getEndSessionUrl(config, customParams)));\r\n    }\r\n    /**\r\n     * Creates the authorize URL based on your flow\r\n     *\r\n     * @param customParams\r\n     * @param configId The configId to perform the action in behalf of. If not passed, the first configs will be taken\r\n     *\r\n     * @returns A string with the authorize URL or null\r\n     */\r\n    getAuthorizeUrl(customParams, configId) {\r\n        return this.configurationService\r\n            .getOpenIDConfiguration(configId)\r\n            .pipe(switchMap((config) => this.urlService.getAuthorizeUrl(config, customParams ? { customParams } : undefined)));\r\n    }\r\n}\r\nOidcSecurityService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: OidcSecurityService, deps: [{ token: CheckSessionService }, { token: CheckAuthService }, { token: UserService }, { token: TokenHelperService }, { token: ConfigurationService }, { token: AuthStateService }, { token: FlowsDataService }, { token: CallbackService }, { token: LogoffRevocationService }, { token: LoginService }, { token: RefreshSessionService }, { token: UrlService }, { token: AuthWellKnownService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOidcSecurityService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: OidcSecurityService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: OidcSecurityService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: CheckSessionService }, { type: CheckAuthService }, { type: UserService }, { type: TokenHelperService }, { type: ConfigurationService }, { type: AuthStateService }, { type: FlowsDataService }, { type: CallbackService }, { type: LogoffRevocationService }, { type: LoginService }, { type: RefreshSessionService }, { type: UrlService }, { type: AuthWellKnownService }]; } });\n\nclass DefaultSessionStorageService {\r\n    read(key) {\r\n        return sessionStorage.getItem(key);\r\n    }\r\n    write(key, value) {\r\n        sessionStorage.setItem(key, value);\r\n    }\r\n    remove(key) {\r\n        sessionStorage.removeItem(key);\r\n    }\r\n    clear() {\r\n        sessionStorage.clear();\r\n    }\r\n}\r\nDefaultSessionStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DefaultSessionStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nDefaultSessionStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DefaultSessionStorageService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: DefaultSessionStorageService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\nfunction createStaticLoader(passedConfig) {\r\n    return new StsConfigStaticLoader(passedConfig.config);\r\n}\r\nconst PASSED_CONFIG = new InjectionToken('PASSED_CONFIG');\r\nclass AuthModule {\r\n    static forRoot(passedConfig) {\r\n        return {\r\n            ngModule: AuthModule,\r\n            providers: [\r\n                // Make the PASSED_CONFIG available through injection\r\n                { provide: PASSED_CONFIG, useValue: passedConfig },\r\n                // Create the loader: Either the one getting passed or a static one\r\n                passedConfig?.loader || { provide: StsConfigLoader, useFactory: createStaticLoader, deps: [PASSED_CONFIG] },\r\n                ConfigurationService,\r\n                PublicEventsService,\r\n                FlowHelper,\r\n                OidcSecurityService,\r\n                TokenValidationService,\r\n                PlatformProvider,\r\n                CheckSessionService,\r\n                FlowsDataService,\r\n                FlowsService,\r\n                SilentRenewService,\r\n                LogoffRevocationService,\r\n                UserService,\r\n                RandomService,\r\n                HttpBaseService,\r\n                UrlService,\r\n                AuthStateService,\r\n                SigninKeyDataService,\r\n                StoragePersistenceService,\r\n                TokenHelperService,\r\n                IFrameService,\r\n                EqualityService,\r\n                LoginService,\r\n                ParService,\r\n                AuthWellKnownDataService,\r\n                AuthWellKnownService,\r\n                DataService,\r\n                StateValidationService,\r\n                ConfigValidationService,\r\n                CheckAuthService,\r\n                ResetAuthDataService,\r\n                ImplicitFlowCallbackService,\r\n                HistoryJwtKeysCallbackHandlerService,\r\n                ResponseTypeValidationService,\r\n                UserCallbackHandlerService,\r\n                StateValidationCallbackHandlerService,\r\n                RefreshSessionCallbackHandlerService,\r\n                RefreshTokenCallbackHandlerService,\r\n                CodeFlowCallbackHandlerService,\r\n                ImplicitFlowCallbackHandlerService,\r\n                ParLoginService,\r\n                PopUpLoginService,\r\n                StandardLoginService,\r\n                AutoLoginService,\r\n                JwkExtractor,\r\n                JwkWindowCryptoService,\r\n                JwtWindowCryptoService,\r\n                CurrentUrlService,\r\n                ClosestMatchingRouteService,\r\n                DefaultSessionStorageService,\r\n                BrowserStorageService,\r\n                CryptoService,\r\n                LoggerService,\r\n                { provide: AbstractSecurityStorage, useClass: DefaultSessionStorageService },\r\n                { provide: AbstractLoggerService, useClass: ConsoleLoggerService },\r\n            ],\r\n        };\r\n    }\r\n}\r\nAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\nAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthModule, imports: [CommonModule, HttpClientModule] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule, HttpClientModule],\r\n                    declarations: [],\r\n                    exports: [],\r\n                }]\r\n        }] });\n\nclass AutoLoginAllRoutesGuard {\r\n    constructor(autoLoginService, checkAuthService, loginService, configurationService, router) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.checkAuthService = checkAuthService;\r\n        this.loginService = loginService;\r\n        this.configurationService = configurationService;\r\n        this.router = router;\r\n    }\r\n    canLoad() {\r\n        return this.checkAuth(this.router.getCurrentNavigation()?.extractedUrl.toString().substring(1) ?? '');\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        return this.configurationService.getOpenIDConfiguration().pipe(switchMap((config) => {\r\n            const allconfigs = this.configurationService.getAllConfigurations();\r\n            return this.checkAuthService.checkAuth(config, allconfigs).pipe(take(1), map(({ isAuthenticated }) => {\r\n                if (isAuthenticated) {\r\n                    this.autoLoginService.checkSavedRedirectRouteAndNavigate(config);\r\n                }\r\n                if (!isAuthenticated) {\r\n                    this.autoLoginService.saveRedirectRoute(config, url);\r\n                    this.loginService.login(config);\r\n                }\r\n                return isAuthenticated;\r\n            }));\r\n        }));\r\n    }\r\n}\r\nAutoLoginAllRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginAllRoutesGuard, deps: [{ token: AutoLoginService }, { token: CheckAuthService }, { token: LoginService }, { token: ConfigurationService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginAllRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginAllRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginAllRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: CheckAuthService }, { type: LoginService }, { type: ConfigurationService }, { type: i2.Router }]; } });\n\nclass AutoLoginPartialRoutesGuard {\r\n    constructor(autoLoginService, authStateService, loginService, configurationService, router) {\r\n        this.autoLoginService = autoLoginService;\r\n        this.authStateService = authStateService;\r\n        this.loginService = loginService;\r\n        this.configurationService = configurationService;\r\n        this.router = router;\r\n    }\r\n    canLoad() {\r\n        return this.checkAuth(this.router.getCurrentNavigation()?.extractedUrl.toString().substring(1) ?? '');\r\n    }\r\n    canActivate(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    canActivateChild(route, state) {\r\n        return this.checkAuth(state.url);\r\n    }\r\n    checkAuth(url) {\r\n        return this.configurationService.getOpenIDConfiguration().pipe(map((configuration) => {\r\n            const isAuthenticated = this.authStateService.areAuthStorageTokensValid(configuration);\r\n            if (isAuthenticated) {\r\n                this.autoLoginService.checkSavedRedirectRouteAndNavigate(configuration);\r\n            }\r\n            if (!isAuthenticated) {\r\n                this.autoLoginService.saveRedirectRoute(configuration, url);\r\n                this.loginService.login(configuration);\r\n            }\r\n            return isAuthenticated;\r\n        }));\r\n    }\r\n}\r\nAutoLoginPartialRoutesGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginPartialRoutesGuard, deps: [{ token: AutoLoginService }, { token: AuthStateService }, { token: LoginService }, { token: ConfigurationService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAutoLoginPartialRoutesGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginPartialRoutesGuard, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AutoLoginPartialRoutesGuard, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: AutoLoginService }, { type: AuthStateService }, { type: LoginService }, { type: ConfigurationService }, { type: i2.Router }]; } });\n\nclass AuthInterceptor {\r\n    constructor(authStateService, configurationService, loggerService, closestMatchingRouteService) {\r\n        this.authStateService = authStateService;\r\n        this.configurationService = configurationService;\r\n        this.loggerService = loggerService;\r\n        this.closestMatchingRouteService = closestMatchingRouteService;\r\n    }\r\n    intercept(req, next) {\r\n        if (!this.configurationService.hasAtLeastOneConfig()) {\r\n            return next.handle(req);\r\n        }\r\n        const allConfigurations = this.configurationService.getAllConfigurations();\r\n        const allRoutesConfigured = allConfigurations.map((x) => x.secureRoutes || []);\r\n        const allRoutesConfiguredFlat = [].concat(...allRoutesConfigured);\r\n        if (allRoutesConfiguredFlat.length === 0) {\r\n            this.loggerService.logDebug(allConfigurations[0], `No routes to check configured`);\r\n            return next.handle(req);\r\n        }\r\n        const { matchingConfig, matchingRoute } = this.closestMatchingRouteService.getConfigIdForClosestMatchingRoute(req.url, allConfigurations);\r\n        if (!matchingConfig) {\r\n            this.loggerService.logDebug(allConfigurations[0], `Did not find any configured route for route ${req.url}`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}'`);\r\n        const token = this.authStateService.getAccessToken(matchingConfig);\r\n        if (!token) {\r\n            this.loggerService.logDebug(matchingConfig, `Wanted to add token to ${req.url} but found no token: '${token}'`);\r\n            return next.handle(req);\r\n        }\r\n        this.loggerService.logDebug(matchingConfig, `'${req.url}' matches configured route '${matchingRoute}', adding token`);\r\n        req = req.clone({\r\n            headers: req.headers.set('Authorization', 'Bearer ' + token),\r\n        });\r\n        return next.handle(req);\r\n    }\r\n}\r\nAuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthInterceptor, deps: [{ token: AuthStateService }, { token: ConfigurationService }, { token: LoggerService }, { token: ClosestMatchingRouteService }], target: i0.ɵɵFactoryTarget.Injectable });\r\nAuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthInterceptor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.1.0\", ngImport: i0, type: AuthInterceptor, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: AuthStateService }, { type: ConfigurationService }, { type: LoggerService }, { type: ClosestMatchingRouteService }]; } });\n\n// Public classes.\n\n/*\r\n * Public API Surface of angular-auth-oidc-client\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AbstractLoggerService, AbstractSecurityStorage, AuthInterceptor, AuthModule, AutoLoginAllRoutesGuard, AutoLoginPartialRoutesGuard, ConfigurationService, EventTypes, LogLevel, OidcSecurityService, OpenIdConfigLoader, PASSED_CONFIG, PopUpService, PublicEventsService, StateValidationResult, StsConfigHttpLoader, StsConfigLoader, StsConfigStaticLoader, ValidationResult, createStaticLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}